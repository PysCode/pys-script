<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>SandSpiel - PowderGame v3.14</title>
<style>
:root {
    --md-sys-color-primary: #6750A4;
    --md-sys-color-on-primary: #FFFFFF;
    --md-sys-color-primary-container: #EADDFF;
    --md-sys-color-on-primary-container: #21005D;
    --md-sys-color-secondary: #625B71;
    --md-sys-color-secondary-container: #E8DEF8;
    --md-sys-color-on-secondary-container: #1D192B;
    --md-sys-color-surface: #1C1B1F;
    --md-sys-color-surface-container: #25232A;
    --md-sys-color-on-surface: #E6E1E5;
    --md-sys-color-outline: #79747E;
    --md-sys-color-surface-variant: #49454F;
}

* {
    box-sizing: border-box;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
}

body {
    margin: 0;
    padding: 0;
    background: var(--md-sys-color-surface);
    color: var(--md-sys-color-on-surface);
    font-family: 'Roboto', sans-serif;
    height: 100vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

header {
    height: 64px;
    display: flex;
    align-items: center;
    padding: 0 16px;
    background: var(--md-sys-color-surface);
    font: 400 22px/28px 'Roboto', sans-serif;
    justify-content: space-between;
}

.icon-btn {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    border: none;
    background: transparent;
    color: var(--md-sys-color-on-surface);
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    position: relative;
    overflow: hidden;
}

.icon-btn svg {
    width: 24px;
    height: 24px;
    fill: currentColor;
}

#game-container {
    flex: 1;
    position: relative;
    background: #000;
    margin: 0 16px 16px 16px;
    border-radius: 16px;
    overflow: hidden;
    touch-action: none;
}

canvas {
    width: 100%;
    height: 100%;
    image-rendering: pixelated;
    display: block;
    transform-origin: 0 0;
    transition: transform 0.1s;
}

.controls-area {
    background: var(--md-sys-color-surface-container);
    padding: 12px 16px 24px 16px;
    border-radius: 24px 24px 0 0;
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.chip-scroll {
    display: flex;
    overflow-x: auto;
    gap: 8px;
    padding-bottom: 4px;
    scrollbar-width: none;
}

.chip-scroll::-webkit-scrollbar {
    display: none;
}

.chip {
    height: 32px;
    padding: 0 16px;
    border-radius: 8px;
    border: 1px solid var(--md-sys-color-outline);
    background: transparent;
    color: var(--md-sys-color-on-surface);
    font: 500 14px/20px 'Roboto', sans-serif;
    display: flex;
    align-items: center;
    white-space: nowrap;
    cursor: pointer;
    transition: all .2s;
}

.chip.active {
    background: var(--md-sys-color-secondary-container);
    color: var(--md-sys-color-on-secondary-container);
    border-color: transparent;
}

.chip.active::before {
    content: "✓";
    margin-right: 6px;
    font-weight: bold;
}

#more-sheet {
    position: fixed;
    bottom: -100%;
    left: 0;
    right: 0;
    background: var(--md-sys-color-surface-container);
    border-radius: 28px 28px 0 0;
    padding: 24px;
    transition: bottom .3s;
    z-index: 100;
    max-height: 70vh;
    overflow-y: auto;
}

#more-sheet.open {
    bottom: 0;
}

.sheet-handle {
    width: 32px;
    height: 4px;
    background: var(--md-sys-color-outline);
    opacity: .4;
    border-radius: 2px;
    margin: -10px auto 20px auto;
}

.grid-elements {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
    gap: 12px;
}

.element-card {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 16px;
    background: var(--md-sys-color-surface);
    border-radius: 12px;
    gap: 8px;
    cursor: pointer;
}

.element-color-dot {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    border: 1px solid rgba(0,0,0,.1);
}

.backdrop {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,.4);
    z-index: 90;
    opacity: 0;
    pointer-events: none;
    transition: opacity .3s;
}

.backdrop.open {
    opacity: 1;
    pointer-events: auto;
}

.brush-size-slider {
    -webkit-appearance: none;
    appearance: none;
    width: 100%;
    height: 4px;
    background: var(--md-sys-color-surface-variant);
    border-radius: 2px;
    outline: none;
}

.brush-size-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: var(--md-sys-color-primary);
    border: 2px solid var(--md-sys-color-on-primary);
    cursor: grab;
    box-shadow: 0 0 4px rgba(0,0,0,.35);
    transition: transform .2s;
}

.brush-size-slider:active::-webkit-slider-thumb {
    cursor: grabbing;
    transform: scale(1.15);
}

.brush-size-slider::-moz-range-thumb {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: var(--md-sys-color-primary);
    border: 2px solid var(--md-sys-color-on-primary);
    cursor: grab;
    box-shadow: 0 0 4px rgba(0,0,0,.35);
    transition: transform .2s;
}

.brush-size-slider:active::-moz-range-thumb {
    cursor: grabbing;
    transform: scale(1.15);
}

#fps-display {
    position: absolute;
    top: 5px;
    right: 5px;
    color: white;
    font-family: 'Roboto', sans-serif;
    font-size: 12px;
    font-weight: 400;
    background: rgba(0,0,0,0.6);
    padding: 2px 6px;
    border-radius: 3px;
    z-index: 10;
    pointer-events: none;
}

.control-buttons {
    display: flex;
    gap: 8px;
    margin-left: auto;
}

.paused-indicator {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
    font-size: 24px;
    font-weight: bold;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
    display: none;
    z-index: 20;
}

.temp-display {
    position: absolute;
    top: 30px;
    right: 5px;
    color: white;
    font-family: 'Roboto', sans-serif;
    font-size: 12px;
    font-weight: 400;
    background: rgba(0,0,0,0.6);
    padding: 2px 6px;
    border-radius: 3px;
    z-index: 10;
    pointer-events: none;
}

.temp-settings {
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin-top: 8px;
    padding: 8px;
    background: rgba(0,0,0,0.1);
    border-radius: 8px;
}

.temp-slider-container {
    display: flex;
    align-items: center;
    gap: 8px;
}

.temp-label {
    font-size: 11px;
    opacity: 0.7;
    min-width: 80px;
}

.temp-value {
    font-size: 11px;
    min-width: 30px;
    text-align: right;
}

.temp-toggle {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 12px;
}

#grid-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-image: linear-gradient(rgba(255,255,255,0.1) 1px, transparent 1px),
                      linear-gradient(90deg, rgba(255,255,255,0.1) 1px, transparent 1px);
    background-size: 12px 12px;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.3s;
}

#grid-overlay.active {
    opacity: 1;
}

#element-counter {
    font-size: 12px;
    opacity: 0.7;
    text-align: center;
    margin-top: 8px;
}

.element-dot {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    margin-bottom: 4px;
}

#settings-overlay, #about-overlay, #source-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s;
}

#settings-overlay.show, #about-overlay.show, #source-overlay.show {
    opacity: 1;
    pointer-events: auto;
}

.settings-panel {
    background: var(--md-sys-color-surface-container);
    border-radius: 24px;
    padding: 24px;
    width: 90%;
    max-width: 400px;
    max-height: 80vh;
    overflow-y: auto;
}

.settings-title {
    margin: 0 0 20px 0;
    font-size: 20px;
    text-align: center;
}

.setting-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 0;
    border-bottom: 1px solid var(--md-sys-color-outline);
}

.setting-item:last-child {
    border-bottom: none;
}

.setting-label {
    font-size: 14px;
}

.source-code-view {
    width: 90%;
    height: 70vh;
    max-width: 600px;
    background: #1e1e1e;
    color: #d4d4d4;
    font-family: 'Courier New', monospace;
    padding: 20px;
    border-radius: 8px;
    border: none;
    resize: none;
    font-size: 12px;
    line-height: 1.4;
}

.copy-button {
    background: var(--md-sys-color-primary);
    color: var(--md-sys-color-on-primary);
    border: none;
    border-radius: 8px;
    padding: 12px 24px;
    font-size: 14px;
    cursor: pointer;
    margin-top: 16px;
    display: flex;
    align-items: center;
    gap: 8px;
}

.advanced-controls {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 8px;
}

.advanced-btn {
    flex: 1;
    min-width: 80px;
    height: 36px;
    border-radius: 8px;
    border: 1px solid var(--md-sys-color-outline);
    background: transparent;
    color: var(--md-sys-color-on-surface);
    font-size: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 4px;
    cursor: pointer;
}

#fps-counter {
    position: absolute;
    top: 5px;
    left: 5px;
    color: white;
    font-size: 12px;
    background: rgba(0,0,0,0.6);
    padding: 2px 6px;
    border-radius: 3px;
    display: none;
}

.toggle-switch {
    position: relative;
    display: inline-block;
    width: 50px;
    height: 24px;
}

.toggle-switch input {
    opacity: 0;
    width: 0;
    height: 0;
}

.toggle-slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: var(--md-sys-color-outline);
    transition: .4s;
    border-radius: 24px;
}

.toggle-slider:before {
    position: absolute;
    content: "";
    height: 16px;
    width: 16px;
    left: 4px;
    bottom: 4px;
    background-color: white;
    transition: .4s;
    border-radius: 50%;
}

input:checked + .toggle-slider {
    background-color: var(--md-sys-color-primary);
}

input:checked + .toggle-slider:before {
    transform: translateX(26px);
}

@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
}

.material-symbols-outlined {
    font-family: 'Material Symbols Outlined';
    font-weight: normal;
    font-style: normal;
    font-size: 24px;
    line-height: 1;
    letter-spacing: normal;
    text-transform: none;
    display: inline-block;
    white-space: nowrap;
    word-wrap: normal;
    direction: ltr;
    -webkit-font-feature-settings: 'liga';
    -webkit-font-smoothing: antialiased;
}

.advanced-btn.active {
    background: var(--md-sys-color-primary);
    color: var(--md-sys-color-on-primary);
}
</style>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
</head>

<body>
<header>
    <div style="display:flex; align-items:center; gap:12px;">
        <span>SandSpiel v1.2.0</span>
    </div>
    <div class="control-buttons">
        <button class="icon-btn" onclick="togglePause()" title="暂停/继续" id="pause-btn">
            <svg viewBox="0 0 24 24" id="pauseIcon">
                <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
            </svg>
        </button>
        <button class="icon-btn" onclick="clearCanvas()" title="清空">
            <svg viewBox="0 0 24 24">
                <path d="M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z"/>
            </svg>
        </button>
        <button class="icon-btn" onclick="openSettings()" title="设置">
            <span class="material-symbols-outlined">settings</span>
        </button>
    </div>
</header>

<div id="game-container">
    <canvas id="sandbox"></canvas>
    <div id="grid-overlay"></div>
    <div id="fps-display">0 FPS</div>
    <div id="temp-display">温度系统: 开启</div>
    <div id="fps-counter">0 FPS</div>
    <div class="paused-indicator" id="pausedIndicator">暂停中</div>
</div>

<div class="controls-area">
    <div style="display:flex; align-items:center; gap:12px; margin-bottom:8px;">
        <span style="font-size:12px; opacity:.7">笔刷大小</span>
        <input type="range" class="brush-size-slider" min="1" max="20" value="5" id="brushSize">
        <button class="icon-btn" onclick="toggleBrushShape()" title="切换笔刷形状" id="shape-toggle" style="width:32px;height:32px;">
            <span class="material-symbols-outlined" style="font-size:18px;">circle</span>
        </button>
    </div>

    <div class="temp-settings">
        <div class="temp-toggle">
            <input type="checkbox" id="tempToggle" checked onchange="toggleTemperatureSystem()">
            <label for="tempToggle">温度系统</label>
        </div>

        <div class="temp-slider-container">
            <span class="temp-label">热传导</span>
            <input type="range" min="1" max="10" value="5" class="brush-size-slider" id="heatTransferSpeed">
            <span class="temp-value" id="heatTransferValue">5</span>
        </div>

        <div class="temp-slider-container">
            <span class="temp-label">环境温度</span>
            <input type="range" min="-273" max="2000" value="20" class="brush-size-slider" id="ambientTemp">
            <span class="temp-value" id="ambientTempValue">20°C</span>
        </div>
    </div>

    <div class="advanced-controls">
        <button class="advanced-btn" onclick="toggleGravity()" title="零重力" id="gravity-btn">
            <span class="material-symbols-outlined" style="font-size:16px;">gps_off</span>
            <span>零重力</span>
        </button>
        <button class="advanced-btn" onclick="toggleGrid()" title="显示网格" id="grid-btn">
            <span class="material-symbols-outlined" style="font-size:16px;">grid_on</span>
            <span>网格</span>
        </button>
    </div>

    <div class="chip-scroll" id="quick-bar"></div>
    <button class="icon-btn" style="width:100%; border-radius:12px; height:48px; background:var(--md-sys-color-primary); color:var(--md-sys-color-on-primary); margin-top:8px;" onclick="toggleSheet(true)">
        <span class="material-symbols-outlined" style="margin-right:8px;">add</span>
        更多元素
    </button>
    <div id="element-counter"></div>
</div>

<div class="backdrop" id="backdrop" onclick="closeAllOverlays()"></div>

<div id="more-sheet">
    <div class="sheet-handle"></div>
    <h3 style="margin:0 0 16px 0; font-size:20px;">所有元素</h3>
    <div class="grid-elements" id="all-elements-grid"></div>
</div>

<!-- 设置面板 -->
<div id="settings-overlay" onclick="closeSettings(event)">
    <div class="settings-panel">
        <h3 class="settings-title">设置</h3>
        
        <div class="setting-item">
            <span class="setting-label">分辨率</span>
            <select id="resolution-select" onchange="changeResolution(this.value)">
                <option value="2">高 (2x)</option>
                <option value="3" selected>中 (3x)</option>
                <option value="4">低 (4x)</option>
            </select>
        </div>
        
        <div class="setting-item">
            <span class="setting-label">平滑模式</span>
            <label class="toggle-switch">
                <input type="checkbox" id="smooth-toggle" onchange="toggleSmoothMode()">
                <span class="toggle-slider"></span>
            </label>
        </div>
        
        <button class="copy-button" onclick="openSourceView()" style="width:100%;">
            <span class="material-symbols-outlined">code</span>
            <span>查看源代码</span>
        </button>
        
        <button class="copy-button" onclick="openAbout()" style="width:100%; margin-top:12px;">
            <span class="material-symbols-outlined">info</span>
            <span>关于</span>
        </button>
    </div>
</div>

<!-- 源代码查看面板 -->
<div id="source-overlay" onclick="closeSource(event)">
    <div style="text-align:center;">
        <textarea class="source-code-view" id="source-code-view" readonly></textarea>
        <button class="copy-button" onclick="copySource()">
            <span class="material-symbols-outlined">content_copy</span>
            <span id="copy-btn-text">复制代码</span>
        </button>
    </div>
</div>

<!-- 关于面板 -->
<div id="about-overlay" onclick="closeAbout(event)">
    <div class="settings-panel">
        <h3 class="settings-title">关于 SandSpiel v3.14</h3>
        <p style="text-align:center; font-size:14px; line-height:1.6;">
            这是一个粒子物理化学模拟沙盒游戏<br>
            包含多种不同的元素<br>
            更多的金属、更丰富的物流效果<br><br>
            版本：1.2.0<br>
            更新日期：2026
        </p>
    </div>
</div>

<script>
// ================= 配置与元素定义 =================
let canvasScale = 3;
let isPaused = false;
let brushShape = 'circle';
let zeroGravity = false;
let showGrid = false;
let isSmoothMode = false;

let scale = 1;
let pointX = 0, pointY = 0, startX = 0, startY = 0;

const TYPES = {
    EMPTY: 0,
    SOLID: 1,
    POWDER: 2,
    LIQUID: 3,
    GAS: 4,
    ACID: 5,
    LAVA: 6,
    INDESTRUCTIBLE: 7,
    CLONE: 8,
    LIFE: 9,
    STEAM: 10,
    METAL_SOLID: 11,
    METAL_LIQUID: 12,
    EXPLOSIVE: 13
};

// 完整的元素定义
const ELEMENTS = {
    // ================= 基础元素 =================
    AIR: { 
        id: 0,  name: '空气',   
        color: [0,0,0,0],          
        type: TYPES.EMPTY, 
        heatResistance: 0.1, 
        defaultTemp: 20, 
        density: 0.00129 
    },
    
    SAND: { 
        id: 1,  name: '沙子',   
        color: [226,197,139,255],  
        type: TYPES.POWDER, 
        variance: 20, 
        heatResistance: 0.3, 
        defaultTemp: 20, 
        meltsAt: 1600, 
        meltTo: 'GLASS', 
        density: 1.6,
        acidResistance: 0.2
    },
    
    WATER: { 
        id: 2,  name: '水',     
        color: [79,151,232,255],   
        type: TYPES.LIQUID, 
        variance: 10, 
        heatResistance: 0.4, 
        defaultTemp: 20, 
        boilsAt: 100, 
        boilTo: 'STEAM', 
        freezesAt: 0, 
        freezeTo: 'ICE', 
        density: 1.0,
        acidResistance: 0.1
    },
    
    STONE: { 
        id: 3,  name: '石头',   
        color: [119,119,119,255],  
        type: TYPES.SOLID, 
        heatResistance: 0.5, 
        defaultTemp: 20, 
        density: 2.5,
        acidResistance: 0.8
    },
    
    WALL: { 
        id: 4,  name: '墙',     
        color: [150,150,150,255],  
        type: TYPES.SOLID, 
        heatResistance: 0.8, 
        defaultTemp: 20, 
        density: 2.4,
        acidResistance: 0.9
    },
    
    FIRE: { 
        id: 5,  name: '火焰',   
        color: [255,69,0,255],     
        type: TYPES.GAS, 
        variance: 50, 
        life: 50, 
        heatResistance: 0.0, 
        defaultTemp: 500, 
        heatEmission: 80, 
        burnTime: 50, 
        density: 0.001,
        acidResistance: 0.0
    },
    
    SMOKE: { 
        id: 6,  name: '烟雾',   
        color: [200,200,200,150],  
        type: TYPES.GAS, 
        life: 200, 
        heatResistance: 0.2, 
        defaultTemp: 80, 
        density: 0.0012,
        acidResistance: 0.0
    },
    
    ACID: { 
        id: 7,  name: '酸液',   
        color: [124,252,0,200],    
        type: TYPES.ACID, 
        acidity: true,
        heatResistance: 0.3, 
        defaultTemp: 20, 
        density: 1.3
    },
    
    WOOD: { 
        id: 8,  name: '木头',   
        color: [139,69,19,255],    
        type: TYPES.SOLID, 
        flammable: true, 
        heatResistance: 0.2, 
        defaultTemp: 20, 
        ignitesAt: 150, 
        burnTo: 'FIRE', 
        density: 0.7,
        acidResistance: 0.4
    },
    
    PLANT: { 
        id: 9,  name: '植物',   
        color: [34,139,34,255],    
        type: TYPES.SOLID, 
        flammable: true, 
        heatResistance: 0.2, 
        defaultTemp: 20, 
        ignitesAt: 120, 
        burnTo: 'FIRE', 
        density: 0.5,
        acidResistance: 0.3
    },
    
    OIL: { 
        id: 10, name: '石油',   
        color: [30,30,30,255],     
        type: TYPES.LIQUID, 
        flammable: true, 
        variance: 10, 
        heatResistance: 0.3, 
        defaultTemp: 20, 
        ignitesAt: 200, 
        burnTo: 'FIRE', 
        density: 0.9,
        acidResistance: 0.6
    },
    
    SEED: { 
        id: 11, name: '种子',   
        color: [139,90,43,255],    
        type: TYPES.POWDER, 
        flammable: true, 
        heatResistance: 0.2, 
        defaultTemp: 20, 
        ignitesAt: 100, 
        burnTo: 'FIRE', 
        density: 1.2,
        acidResistance: 0.3
    },
    
    GUNPOWDER: { 
        id: 12, name: '火药',   
        color: [180,150,120,255],
        type: TYPES.POWDER, 
        explosive: true,          // 标记为爆炸物
        variance: 15, 
        heatResistance: 0.1, 
        defaultTemp: 20, 
        ignitesAt: 150,           // 在150°C时爆炸
        burnTo: 'FIRE', 
        density: 1.7,
        acidResistance: 0.5,
        explosivePower: 5         // 爆炸威力
    },
    
    GAS_FUEL: { 
        id: 13, name: '燃气',   
        color: [255,213,79,180],   
        type: TYPES.GAS, 
        variance: 25, 
        flammable: true, 
        heatResistance: 0.0, 
        defaultTemp: 20, 
        ignitesAt: 60, 
        burnTo: 'FIRE', 
        density: 0.0011,
        acidResistance: 0.0,
        explosive: true           // 燃气也是爆炸物
    },
    
    ICE: { 
        id: 14, name: '冰',     
        color: [173,216,230,255],  
        type: TYPES.SOLID, 
        meltable: true,
        heatResistance: 0.6, 
        defaultTemp: -10, 
        meltsAt: 0, 
        meltTo: 'WATER', 
        density: 0.92,
        acidResistance: 0.7
    },
    
    LAVA: { 
        id: 15, name: '岩浆',   
        color: [255,80,0,255],     
        type: TYPES.LAVA, 
        hot: true, 
        variance: 30, 
        heatResistance: 0.0, 
        defaultTemp: 1200, 
        heatEmission: 100, 
        density: 2.8,
        acidResistance: 0.9
    },
    
    FLOWER: { 
        id: 16, name: '花',     
        color: [255,105,180,255],  
        type: TYPES.SOLID, 
        flammable: true, 
        heatResistance: 0.2, 
        defaultTemp: 20, 
        ignitesAt: 100, 
        burnTo: 'FIRE', 
        density: 0.6,
        acidResistance: 0.3
    },
    
    VINE: { 
        id: 17, name: '藤蔓',   
        color: [50,205,50,180],    
        type: TYPES.SOLID, 
        flammable: true, 
        heatResistance: 0.2, 
        defaultTemp: 20, 
        ignitesAt: 110, 
        burnTo: 'FIRE', 
        density: 0.4,
        acidResistance: 0.3
    },
    
    LEAF: { 
        id: 18, name: '叶子',   
        color: [144,238,144,200],  
        type: TYPES.SOLID, 
        flammable: true, 
        heatResistance: 0.2, 
        defaultTemp: 20, 
        ignitesAt: 90, 
        burnTo: 'FIRE', 
        density: 0.3,
        acidResistance: 0.3
    },
    
    CLONE: { 
        id: 19, name: '克隆',   
        color: [138,43,226,255],   
        type: TYPES.CLONE, 
        clonePower: 5, 
        pulse: true, 
        heatResistance: 0.5, 
        defaultTemp: 20, 
        density: 1.0,
        acidResistance: 0.8
    },
    
    SUPER_ACID: { 
        id: 20, name: '超酸',  
        color: [255,255,0,255],   
        type: TYPES.ACID, 
        superAcidic: true,
        heatResistance: 0.3, 
        defaultTemp: 20, 
        density: 1.8
    },
    
    BEDROCK: { 
        id: 21, name: '基岩',  
        color: [60,60,60,255],    
        type: TYPES.INDESTRUCTIBLE, 
        indestructible: true,
        heatResistance: 1.0, 
        defaultTemp: 20, 
        density: 3.0,
        acidResistance: 1.0
    },
    
    GLASS: { 
        id: 22, name: '玻璃',  
        color: [200,220,240,180], 
        type: TYPES.SOLID, 
        transparent: true,
        heatResistance: 0.4, 
        defaultTemp: 20, 
        meltsAt: 1500, 
        density: 2.5,
        acidResistance: 0.9
    },
    
    LIFE: { 
        id: 23, name: '生命',  
        color: [255,100,100,255], 
        type: TYPES.LIFE, 
        lifeForm: true,
        heatResistance: 0.3, 
        defaultTemp: 37, 
        diesAt: 60, 
        freezeAt: 0, 
        density: 1.1,
        acidResistance: 0.1
    },
    
    STEAM: { 
        id: 24, name: '蒸汽',  
        color: [220,240,255,200], 
        type: TYPES.GAS, 
        variance: 15, 
        life: 300, 
        heatResistance: 0.0, 
        defaultTemp: 120, 
        condensesAt: 99, 
        condenseTo: 'WATER', 
        density: 0.0006,
        acidResistance: 0.0
    },

    SODIUM: {
        id: 25, name: '钠',
        color: [200,200,220,255],
        type: TYPES.POWDER,
        reactive: true,
        heatResistance: 0.1,
        defaultTemp: 20,
        density: 0.97,
        acidResistance: 0.1
    },

    // ================= 金属元素 =================
    IRON: {
        id: 26, name: '铁',
        color: [200,200,200,255],
        type: TYPES.METAL_SOLID,
        heatResistance: 0.6,
        defaultTemp: 20,
        meltsAt: 1538,
        meltTo: 'IRON_LIQUID',
        density: 7.87,
        acidResistance: 0.7
    },
    
    IRON_LIQUID: {
        id: 27, name: '熔铁',
        color: [255,150,100,255],
        type: TYPES.METAL_LIQUID,
        heatResistance: 0.0,
        defaultTemp: 1600,
        freezesAt: 1535,
        freezeTo: 'IRON',
        density: 7.0,
        acidResistance: 0.5
    },
    
    COPPER: {
        id: 28, name: '铜',
        color: [184,115,51,255],
        type: TYPES.METAL_SOLID,
        heatResistance: 0.5,
        defaultTemp: 20,
        meltsAt: 1085,
        meltTo: 'COPPER_LIQUID',
        density: 8.96,
        acidResistance: 0.6,
        oxidizable: true
    },
    
    COPPER_LIQUID: {
        id: 29, name: '熔铜',
        color: [255,140,60,255],
        type: TYPES.METAL_LIQUID,
        heatResistance: 0.0,
        defaultTemp: 1100,
        freezesAt: 1080,
        freezeTo: 'COPPER',
        density: 8.0,
        acidResistance: 0.4
    },
    
    ZINC: {
        id: 30, name: '锌',
        color: [200,200,180,255],
        type: TYPES.METAL_SOLID,
        heatResistance: 0.4,
        defaultTemp: 20,
        meltsAt: 420,
        meltTo: 'ZINC_LIQUID',
        density: 7.14,
        acidResistance: 0.3
    },
    
    ZINC_LIQUID: {
        id: 31, name: '熔锌',
        color: [255,220,150,255],
        type: TYPES.METAL_LIQUID,
        heatResistance: 0.0,
        defaultTemp: 450,
        freezesAt: 415,
        freezeTo: 'ZINC',
        density: 6.5,
        acidResistance: 0.2
    },
    
    ALUMINUM: {
        id: 32, name: '铝',
        color: [220,220,220,255],
        type: TYPES.METAL_SOLID,
        heatResistance: 0.5,
        defaultTemp: 20,
        meltsAt: 660,
        meltTo: 'ALUMINUM_LIQUID',
        density: 2.7,
        acidResistance: 0.8
    },
    
    ALUMINUM_LIQUID: {
        id: 33, name: '熔铝',
        color: [255,200,150,255],
        type: TYPES.METAL_LIQUID,
        heatResistance: 0.0,
        defaultTemp: 700,
        freezesAt: 655,
        freezeTo: 'ALUMINUM',
        density: 2.4,
        acidResistance: 0.6
    },
    
    MAGNESIUM: {
        id: 34, name: '镁',
        color: [255,255,200,255],
        type: TYPES.METAL_SOLID,
        heatResistance: 0.3,
        defaultTemp: 20,
        meltsAt: 650,
        meltTo: 'MAGNESIUM_LIQUID',
        ignitesAt: 473,
        burnTo: 'FIRE',
        density: 1.74,
        acidResistance: 0.4,
        flammable: true
    },
    
    MAGNESIUM_LIQUID: {
        id: 35, name: '熔镁',
        color: [255,255,100,255],
        type: TYPES.METAL_LIQUID,
        heatResistance: 0.0,
        defaultTemp: 680,
        freezesAt: 645,
        freezeTo: 'MAGNESIUM',
        ignitesAt: 473,
        density: 1.6,
        acidResistance: 0.3,
        flammable: true
    },
    
    SILVER: {
        id: 36, name: '银',
        color: [230,230,230,255],
        type: TYPES.METAL_SOLID,
        heatResistance: 0.7,
        defaultTemp: 20,
        meltsAt: 962,
        meltTo: 'SILVER_LIQUID',
        density: 10.49,
        acidResistance: 0.9
    },
    
    SILVER_LIQUID: {
        id: 37, name: '熔银',
        color: [255,255,240,255],
        type: TYPES.METAL_LIQUID,
        heatResistance: 0.0,
        defaultTemp: 1000,
        freezesAt: 960,
        freezeTo: 'SILVER',
        density: 9.5,
        acidResistance: 0.8
    },
    
    GOLD: {
        id: 38, name: '金',
        color: [255,215,0,255],
        type: TYPES.METAL_SOLID,
        heatResistance: 0.8,
        defaultTemp: 20,
        meltsAt: 1064,
        meltTo: 'GOLD_LIQUID',
        density: 19.32,
        acidResistance: 1.0
    },
    
    GOLD_LIQUID: {
        id: 39, name: '熔金',
        color: [255,230,80,255],
        type: TYPES.METAL_LIQUID,
        heatResistance: 0.0,
        defaultTemp: 1100,
        freezesAt: 1060,
        freezeTo: 'GOLD',
        density: 17.5,
        acidResistance: 0.9
    },
    
    ERASER: { 
        id: 99, name: '橡皮擦', 
        color: [255,255,255,50], 
        type: TYPES.SOLID, 
        isEraser: true, 
        density: 0 
    }
};

// 快速访问栏元素
const QUICK_KEYS = ['SAND', 'WATER', 'STONE', 'WALL', 'ICE', 'LAVA', 'FIRE', 'STEAM', 'SUPER_ACID', 'BEDROCK', 'GLASS', 'LIFE', 'CLONE', 'IRON', 'COPPER', 'ERASER'];

// 全局变量
let currentElement = ELEMENTS.SAND;
let brushSize = 5;
const canvas = document.getElementById('sandbox');
const ctx = canvas.getContext('2d', { alpha: false });
let width, height, grid, imageData, animationId;
let fps = 0, frameCount = 0, lastTime = performance.now();
const fpsUpdateInterval = 500;
const fpsDisplay = document.getElementById('fps-display');
const tempDisplay = document.getElementById('temp-display');

// 温度系统
let temperatureSystemEnabled = true;
let temperatures;
let heatTransferSpeed = 5;
let ambientTemperature = 20;

// 粒子数组
let particles = [];

// 冲击波数组
let shockWave = [];

// 铜氧化状态存储
let copperOxidation = new Uint8Array(0);

// 镁燃烧状态存储
let magnesiumBurn = new Uint8Array(0);

// 种子生长状态存储
let seedGrowth = {
    positions: [],
    heights: [],
    directions: [],
    maxHeights: [],
    growthTime: []
};

const SEED_GROW_INTERVAL = 120;
const GROWTH_LIMITS = {
    MAX_SEED_GROWTH_HEIGHT: 12
};

// 生命元素状态
let lifeElements = {
    positions: [],
    lastMoveTime: [],
    directions: [],
    hunger: [],
    age: [],
    health: []
};

const LIFE_MAX_HUNGER = 100;
const LIFE_MAX_AGE = 1000;
const LIFE_MAX_HEALTH = 100;
const LIFE_MOVE_INTERVAL = 100;
const LIFE_BREED_CHANCE = 0.05;

// 克隆元素状态
let cloneElements = {
    positions: [],
    lastCopyTime: [],
    targetElements: [],
    copyCount: [],
    maxCopyCount: []
};

const CLONE_COPY_INTERVAL = 100;
const MAX_CLONE_COUNT = 50;

// 被破坏的植物记录
let destroyedPlants = {
    positions: [],
    timestamps: []
};
const DESTROYED_PLANT_TTL = 5000;

// 石头被炸飞状态
let flyingStones = {
    positions: [],
    velocitiesX: [],
    velocitiesY: [],
    timestamps: []
};
const FLYING_STONE_TTL = 3000;

// 爆炸传播标记 - 防止无限循环
let explosionPropagationGrid = new Uint8Array(0);

// ================= 初始化函数 =================
function initGrid() {
    const container = document.getElementById('game-container');
    width = Math.floor(container.clientWidth / canvasScale);
    height = Math.floor(container.clientHeight / canvasScale);
    canvas.width = width;
    canvas.height = height;
    
    // 初始化网格
    grid = new Array(width * height).fill(0);
    
    // 初始化温度数组
    temperatures = new Float32Array(width * height);
    temperatures.fill(ambientTemperature);
    
    // 初始化冲击波数组
    shockWave = new Uint8Array(width * height);
    
    // 初始化铜氧化状态
    copperOxidation = new Uint8Array(width * height);
    
    // 初始化镁燃烧状态
    magnesiumBurn = new Uint8Array(width * height);
    
    // 初始化爆炸传播标记
    explosionPropagationGrid = new Uint8Array(width * height);
    
    // 初始化图像数据
    imageData = ctx.createImageData(width, height);
    for(let i = 0; i < imageData.data.length; i += 4) {
        imageData.data[i] = 0;
        imageData.data[i+1] = 0;
        imageData.data[i+2] = 0;
        imageData.data[i+3] = 255;
    }
    
    // 重置网格叠加层
    const gridOverlay = document.getElementById('grid-overlay');
    gridOverlay.style.backgroundSize = `${canvasScale}px ${canvasScale}px`;
}

// ================= 辅助函数 =================
const idx = (x, y) => x + y * width;
const inBounds = (x, y) => x >= 0 && x < width && y >= 0 && y < height;
const getElById = (id) => Object.values(ELEMENTS).find(e => e.id === id);

// 重力方向函数
const getDir = () => 1;
const getDown = (y) => y + getDir();
const isDownValid = (y) => y < height;

// 火花效果
let sparks = [];
class Spark {
    constructor(x, y, vx, vy, restoreId = 0) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.life = 20;
        this.restoreId = restoreId;
    }
    
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.2;
        this.life--;
        
        if (this.y >= height - 1 || this.life <= 0) {
            const ix = Math.floor(this.x);
            const iy = Math.floor(this.y);
            if (inBounds(ix, iy)) {
                const i = idx(ix, iy);
                if (grid[i] === 0) {
                    const el = getElById(this.restoreId);
                    if (el && (el.type === TYPES.LIQUID || el.type === TYPES.POWDER)) {
                        grid[i] = this.restoreId;
                    } else {
                        grid[i] = ELEMENTS.FIRE.id;
                    }
                }
            }
            return true;
        }
        return false;
    }
}

// 飞行的石头类
class FlyingStone {
    constructor(x, y, vx, vy) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.life = FLYING_STONE_TTL;
        this.startTime = performance.now();
    }

    update() {
        const now = performance.now();
        const elapsed = now - this.startTime;
        this.life = FLYING_STONE_TTL - elapsed;

        if (this.life <= 0) {
            // 落地变成沙子
            const ix = Math.floor(this.x);
            const iy = Math.floor(this.y);
            if (inBounds(ix, iy)) {
                const i = idx(ix, iy);
                if (grid[i] === 0) {
                    grid[i] = ELEMENTS.SAND.id;
                }
            }
            return true;
        }

        // 更新位置（抛物线运动）
        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.2; // 重力

        // 边界检查
        if (this.x < 0 || this.x >= width || this.y >= height) {
            // 出界变成沙子
            const ix = Math.max(0, Math.min(width - 1, Math.floor(this.x)));
            const iy = Math.max(0, Math.min(height - 1, Math.floor(this.y)));
            if (inBounds(ix, iy)) {
                const i = idx(ix, iy);
                if (grid[i] === 0) {
                    grid[i] = ELEMENTS.SAND.id;
                }
            }
            return true;
        }

        // 碰撞检查
        const ix = Math.floor(this.x);
        const iy = Math.floor(this.y);
        if (inBounds(ix, iy)) {
            const i = idx(ix, iy);
            if (grid[i] !== 0 && grid[i] !== ELEMENTS.AIR.id) {
                // 碰到其他元素，变成沙子
                grid[i] = ELEMENTS.SAND.id;
                return true;
            }
        }

        return false;
    }
}

// ================= 物质移动函数 =================
function updatePowder(x, y, i) {
    if (zeroGravity) return;
    
    const below = idx(x, y + 1);
    if (y + 1 < height && (grid[below] === 0 || isLiquid(grid[below]))) {
        swap(i, below);
        return;
    }
    
    const side = Math.random() > 0.5 ? 1 : -1;
    const diag = idx(x + side, y + 1);
    if (inBounds(x + side, y + 1) && (grid[diag] === 0 || isLiquid(grid[diag]))) {
        swap(i, diag);
    }
}

function updateLiquid(x, y, i, typeId) {
    if (typeId === ELEMENTS.LAVA.id) return;
    
    const below = idx(x, y + 1);
    if (y + 1 < height && grid[below] === 0) {
        swap(i, below);
        return;
    }
    
    const dir = Math.random() > 0.5 ? 1 : -1;
    const sideA = idx(x + dir, y);
    const sideB = idx(x - dir, y);
    
    if (inBounds(x + dir, y) && grid[sideA] === 0) {
        swap(i, sideA);
    } else if (inBounds(x - dir, y) && grid[sideB] === 0) {
        swap(i, sideB);
    }
}

// 修改：岩浆无法落地（悬浮在空中）
function updateLava(x, y, i) {
    const below = idx(x, y + 1);
    if (y + 1 < height) {
        const belowElem = getElById(grid[below]);
        if (grid[below] === ELEMENTS.WATER.id) { 
            grid[below] = ELEMENTS.STONE.id; 
            return; 
        }
        else if (grid[below] === 0 || (belowElem && (belowElem.type === TYPES.LIQUID || belowElem.type === TYPES.GAS))) {
            const temp = grid[below];
            grid[below] = ELEMENTS.LAVA.id; 
            grid[i] = 0;
            if (temp !== 0 && temp !== ELEMENTS.LAVA.id) {
                const dir = Math.random() > 0.5 ? 1 : -1;
                const side = idx(x + dir, y);
                if (inBounds(x + dir, y) && grid[side] === 0) grid[side] = temp;
            }
            return;
        }
    }
    
    const dir = Math.random() > 0.5 ? 1 : -1;
    const sideA = idx(x + dir, y);
    const sideB = idx(x - dir, y);
    
    if (inBounds(x + dir, y)) {
        const sideAElem = getElById(grid[sideA]);
        if (grid[sideA] === ELEMENTS.WATER.id) { 
            grid[sideA] = ELEMENTS.STONE.id; 
            return; 
        }
        else if (grid[sideA] === 0 || (sideAElem && (sideAElem.type === TYPES.LIQUID || sideAElem.type === TYPES.GAS))) {
            const temp = grid[sideA];
            grid[sideA] = ELEMENTS.LAVA.id; 
            grid[i] = 0;
            if (temp !== 0 && temp !== ELEMENTS.LAVA.id) {
                const up = idx(x + dir, y - 1);
                if (inBounds(x + dir, y - 1) && grid[up] === 0) grid[up] = temp;
            }
            return;
        }
    }
    
    if (inBounds(x - dir, y)) {
        const sideBElem = getElById(grid[sideB]);
        if (grid[sideB] === ELEMENTS.WATER.id) { 
            grid[sideB] = ELEMENTS.STONE.id; 
            return; 
        }
        else if (grid[sideB] === 0 || (sideBElem && (sideBElem.type === TYPES.LIQUID || sideBElem.type === TYPES.GAS))) {
            const temp = grid[sideB];
            grid[sideB] = ELEMENTS.LAVA.id; 
            grid[i] = 0;
            if (temp !== 0 && temp !== ELEMENTS.LAVA.id) {
                const up = idx(x - dir, y - 1);
                if (inBounds(x - dir, y - 1) && grid[up] === 0) grid[up] = temp;
            }
            return;
        }
    }
    
    const diagA = idx(x + dir, y + 1);
    const diagB = idx(x - dir, y + 1);
    
    if (y + 1 < height) {
        if (inBounds(x + dir, y + 1) && (grid[diagA] === 0 || grid[diagA] === ELEMENTS.WATER.id)) {
            if (grid[diagA] === ELEMENTS.WATER.id) grid[diagA] = ELEMENTS.STONE.id;
            else { grid[diagA] = ELEMENTS.LAVA.id; grid[i] = 0; }
            return;
        }
        if (inBounds(x - dir, y + 1) && (grid[diagB] === 0 || grid[diagB] === ELEMENTS.WATER.id)) {
            if (grid[diagB] === ELEMENTS.WATER.id) grid[diagB] = ELEMENTS.STONE.id;
            else { grid[diagB] = ELEMENTS.LAVA.id; grid[i] = 0; }
            return;
        }
    }
}

function updateHeavySolid(x, y, i) {
    if (zeroGravity) return;
    
    const below = idx(x, y + 1);
    if (y + 1 < height && grid[below] === 0) {
        swap(i, below);
    }
}

function updateStone(x, y, i) {
    if (zeroGravity) return;
    
    const below = idx(x, y + 1);
    if (y + 1 < height) {
        const belowElem = getElById(grid[below]);
        if (grid[below] === 0 || (belowElem && (belowElem.type === TYPES.LIQUID || belowElem.type === TYPES.GAS || belowElem.type === TYPES.LAVA))) {
            swap(i, below);
        }
    }
}

function updateMetalSolid(x, y, i, elem) {
    if (zeroGravity) return;
    
    const below = idx(x, y + 1);
    if (y + 1 < height) {
        const belowElem = getElById(grid[below]);
        if (grid[below] === 0 || (belowElem && (belowElem.type === TYPES.LIQUID || belowElem.type === TYPES.GAS))) {
            swap(i, below);
        }
    }
}

function updateMetalLiquid(x, y, i, elem) {
    const below = idx(x, y + 1);
    if (y + 1 < height && grid[below] === 0) {
        swap(i, below);
        return;
    }
    
    const dir = Math.random() > 0.5 ? 1 : -1;
    const sideA = idx(x + dir, y);
    const sideB = idx(x - dir, y);
    
    if (inBounds(x + dir, y) && grid[sideA] === 0) {
        swap(i, sideA);
    } else if (inBounds(x - dir, y) && grid[sideB] === 0) {
        swap(i, sideB);
    }
}

// ================= 气体移动函数 =================
function updateFireImproved(x, y, i) {
    // 火焰生命周期
    if (Math.random() < 0.12) { 
        grid[i] = ELEMENTS.SMOKE.id; 
        return; 
    }
    
    // 火焰产生热量
    if (temperatureSystemEnabled) {
        temperatures[i] = Math.min(800, temperatures[i] + 5);
    }
    
    // 火焰传播
    const around = [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [-1, 1], [1, -1], [-1, -1]];
    for (let [dx, dy] of around) {
        const ni = idx(x + dx, y + dy);
        if (!inBounds(x + dx, y + dy)) continue;
        const neighborId = grid[ni];
        if (neighborId === ELEMENTS.LAVA.id) continue;
        const neighbor = getElById(neighborId);
        if (neighbor && neighbor.flammable && Math.random() < 0.25) {
            grid[ni] = ELEMENTS.FIRE.id;
        }
        if (neighbor && neighbor.meltable && Math.random() < 0.15) {
            grid[ni] = ELEMENTS.WATER.id;
        }
    }
    
    // 火焰向上飘
    const dirs = [
        [0, -1, 0.6],  // 向上概率60%
        [-1, -1, 0.15], // 左上概率15%
        [1, -1, 0.15],  // 右上概率15%
        [-1, 0, 0.05],  // 左概率5%
        [1, 0, 0.05]    // 右概率5%
    ];
    
    let rand = Math.random();
    let selectedDir = [0, 0];
    for (const [dx, dy, prob] of dirs) {
        if (rand < prob) {
            selectedDir = [dx, dy];
            break;
        }
        rand -= prob;
    }
    
    const newX = x + selectedDir[0];
    const newY = y + selectedDir[1];
    
    if (inBounds(newX, newY)) {
        const ni = idx(newX, newY);
        if (grid[ni] === 0 || isLiquid(grid[ni]) || isWaterLike(grid[ni])) {
            swap(i, ni);
        }
    }
}

function updateSmokeImproved(x, y, i) {
    // 烟雾会逐渐消失
    if (Math.random() < 0.02) { 
        grid[i] = 0; 
        return; 
    }
    
    // 烟雾向上飘
    const dirs = [
        [0, -1, 0.5],  // 向上50%
        [-1, -1, 0.2], // 左上20%
        [1, -1, 0.2],  // 右上20%
        [-1, 0, 0.05], // 左5%
        [1, 0, 0.05]   // 右5%
    ];
    
    let rand = Math.random();
    let selectedDir = [0, 0];
    for (const [dx, dy, prob] of dirs) {
        if (rand < prob) {
            selectedDir = [dx, dy];
            break;
        }
        rand -= prob;
    }
    
    const newX = x + selectedDir[0];
    const newY = y + selectedDir[1];
    
    if (inBounds(newX, newY)) {
        const ni = idx(newX, newY);
        if (grid[ni] === 0) {
            swap(i, ni);
        }
    }
}

function updateFuelGasImproved(x, y, i) {
    // 检查是否接触火焰
    const aroundFire = [[0, 1], [0, -1], [1, 0], [-1, 0]].some(([dx, dy]) => {
        const ni = idx(x + dx, y + dy);
        return inBounds(x + dx, y + dy) && grid[ni] === ELEMENTS.FIRE.id;
    });
    
    if (aroundFire) {
        // 燃气爆炸
        doExplode(x, y, 3, 120);
        return;
    }
    
    // 燃气几乎不向上，主要是随机左右移动
    const dirs = [
        [0, -1, 0.05],   // 向上5% - 几乎不向上
        [0, 1, 0.1],     // 向下10%
        [-1, 0, 0.425],  // 左42.5%
        [1, 0, 0.425]    // 右42.5%
    ];
    
    let rand = Math.random();
    let selectedDir = [0, 0];
    for (const [dx, dy, prob] of dirs) {
        if (rand < prob) {
            selectedDir = [dx, dy];
            break;
        }
        rand -= prob;
    }
    
    const newX = x + selectedDir[0];
    const newY = y + selectedDir[1];
    
    if (inBounds(newX, newY)) {
        const ni = idx(newX, newY);
        const tgt = grid[ni];
        const tgtEl = getElById(tgt);
        if (tgt === 0 || tgtEl?.type === TYPES.LIQUID || tgtEl?.type === TYPES.POWDER) { 
            swap(i, ni); 
            return; 
        }
    }
}

function updateSteamImproved(x, y, i) {
    // 蒸汽像云雾一样扩散
    const dirs = [
        [0, -1, 0.35],   // 向上35%
        [-1, -1, 0.08],  // 左上8%
        [1, -1, 0.08],   // 右上8%
        [-1, 0, 0.16],   // 左16%
        [1, 0, 0.16],    // 右16%
        [0, 1, 0.1],     // 向下10%
        [-1, 1, 0.05],   // 左下5%
        [1, 1, 0.05]     // 右下5%
    ];
    
    // 如果温度较高，更倾向于向上
    if (temperatureSystemEnabled && temperatures[i] > 120) {
        dirs[0][2] = 0.45;
        dirs[5][2] = 0.05;
    }
    
    let rand = Math.random();
    let selectedDir = [0, 0];
    for (const [dx, dy, prob] of dirs) {
        if (rand < prob) {
            selectedDir = [dx, dy];
            break;
        }
        rand -= prob;
    }
    
    const newX = x + selectedDir[0];
    const newY = y + selectedDir[1];
    
    if (inBounds(newX, newY)) {
        const ni = idx(newX, newY);
        const targetId = grid[ni];
        
        if (targetId === 0 || 
            targetId === ELEMENTS.AIR.id ||
            targetId === ELEMENTS.SMOKE.id ||
            targetId === ELEMENTS.GAS_FUEL.id) {
            swap(i, ni);
        }
    }
}

function updateGasImproved(x, y, i, elem) {
    if (elem.id === ELEMENTS.FIRE.id) {
        updateFireImproved(x, y, i);
        return;
    }
    if (elem.id === ELEMENTS.SMOKE.id) {
        updateSmokeImproved(x, y, i);
        return;
    }
    if (elem.id === ELEMENTS.GAS_FUEL.id) {
        updateFuelGasImproved(x, y, i);
        return;
    }
    if (elem.id === ELEMENTS.STEAM.id) {
        updateSteamImproved(x, y, i);
        return;
    }
    
    // 普通气体的随机移动
    const directions = [
        [0, -1, 0.4],
        [0, 1, 0.1],
        [-1, 0, 0.25],
        [1, 0, 0.25]
    ];
    
    let rand = Math.random();
    let selectedDir = [0, 0];
    for (const [dx, dy, prob] of directions) {
        if (rand < prob) {
            selectedDir = [dx, dy];
            break;
        }
        rand -= prob;
    }
    
    const newX = x + selectedDir[0];
    const newY = y + selectedDir[1];
    
    if (inBounds(newX, newY)) {
        const ni = idx(newX, newY);
        if (grid[ni] === 0) {
            swap(i, ni);
        }
    }
}

// ================= 辅助函数 =================
function isLiquid(id) {
    const e = getElById(id);
    return e && (e.type === TYPES.LIQUID || e.type === TYPES.LAVA || e.type === TYPES.ACID);
}

function isLiquidOrGas(id) {
    const e = getElById(id);
    return e && (e.type === TYPES.LIQUID || e.type === TYPES.GAS || e.type === TYPES.LAVA);
}

function isWaterLike(id) {
    return id === ELEMENTS.WATER.id || id === ELEMENTS.OIL.id || id === ELEMENTS.ACID.id || id === ELEMENTS.SEED.id;
}

function swap(i, j) {
    const temp = grid[i];
    grid[i] = grid[j];
    grid[j] = temp;
    
    // 交换温度
    if (temperatureSystemEnabled) {
        const tempT = temperatures[i];
        temperatures[i] = temperatures[j];
        temperatures[j] = tempT;
    }
    
    // 交换铜氧化状态
    const tempO = copperOxidation[i];
    copperOxidation[i] = copperOxidation[j];
    copperOxidation[j] = tempO;
    
    // 交换镁燃烧状态
    const tempM = magnesiumBurn[i];
    magnesiumBurn[i] = magnesiumBurn[j];
    magnesiumBurn[j] = tempM;
}

// ================= 化学反应函数 =================
// 水碰到石油变成石油
function checkWaterOilReaction(x, y) {
    const i = idx(x, y);
    const elemId = grid[i];
    
    if (elemId !== ELEMENTS.WATER.id) return;
    
    const neighbors = [
        [x, y + 1], [x, y - 1], [x + 1, y], [x - 1, y]
    ];
    
    for (const [nx, ny] of neighbors) {
        if (inBounds(nx, ny)) {
            const ni = idx(nx, ny);
            if (grid[ni] === ELEMENTS.OIL.id && Math.random() < 0.15) {
                grid[i] = ELEMENTS.OIL.id;
                return;
            }
        }
    }
}

// 钠碰到水会爆炸
function checkSodiumWaterReaction(x, y) {
    const i = idx(x, y);
    const elemId = grid[i];
    
    if (elemId !== ELEMENTS.SODIUM.id) return;
    
    const neighbors = [
        [x, y + 1], [x, y - 1], [x + 1, y], [x - 1, y]
    ];
    
    for (const [nx, ny] of neighbors) {
        if (inBounds(nx, ny)) {
            const ni = idx(nx, ny);
            if (grid[ni] === ELEMENTS.WATER.id) {
                // 爆炸效果
                grid[i] = ELEMENTS.FIRE.id;
                grid[ni] = ELEMENTS.FIRE.id;
                
                // 产生冲击波
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        const tx = x + dx, ty = y + dy;
                        if (!inBounds(tx, ty)) continue;
                        const ti = idx(tx, ty);
                        if (grid[ti] === 0) {
                            grid[ti] = ELEMENTS.FIRE.id;
                        }
                    }
                }
                return;
            }
        }
    }
}

// 超酸可以腐蚀任何东西（除基岩）
function checkSuperAcidReaction(x, y) {
    const i = idx(x, y);
    const elemId = grid[i];
    
    if (elemId !== ELEMENTS.SUPER_ACID.id) return;
    
    const neighbors = [
        [x, y + 1], [x, y - 1], [x + 1, y], [x - 1, y]
    ];
    
    for (const [nx, ny] of neighbors) {
        if (inBounds(nx, ny)) {
            const ni = idx(nx, ny);
            const neighborId = grid[ni];
            
            // 超酸与水反应：水变成酸液，超酸消失
            if (neighborId === ELEMENTS.WATER.id && Math.random() < 0.3) {
                grid[ni] = ELEMENTS.ACID.id;
                grid[i] = 0;
                return;
            }
            
            // 超酸与酸液不反应
            if (neighborId === ELEMENTS.ACID.id) {
                continue;
            }
            
            // 超酸腐蚀其他所有粒子（除了基岩）
            if (neighborId !== 0 && neighborId !== ELEMENTS.AIR.id &&
                neighborId !== ELEMENTS.BEDROCK.id && neighborId !== ELEMENTS.SUPER_ACID.id) {
                // 基岩不会被腐蚀
                const neighbor = getElById(neighborId);
                if (neighbor && !neighbor.indestructible) {
                    if (Math.random() < 0.8) { // 80%腐蚀概率
                        grid[ni] = 0;
                        // 如果腐蚀的是植物，移除生长记录
                        if (neighborId === ELEMENTS.PLANT.id ||
                            neighborId === ELEMENTS.VINE.id ||
                            neighborId === ELEMENTS.LEAF.id ||
                            neighborId === ELEMENTS.FLOWER.id ||
                            neighborId === ELEMENTS.SEED.id) {
                            removeGrowthRecords(ni);
                        }
                        // 超酸本身不受影响
                    }
                }
            }
        }
    }
}

// 酸液可以腐蚀任何物质（除墙）
function checkAcidReaction(x, y) {
    const i = idx(x, y);
    const elemId = grid[i];
    
    if (elemId !== ELEMENTS.ACID.id) return;
    
    const neighbors = [
        [x, y + 1], [x, y - 1], [x + 1, y], [x - 1, y]
    ];
    
    for (const [nx, ny] of neighbors) {
        if (inBounds(nx, ny)) {
            const ni = idx(nx, ny);
            const neighborId = grid[ni];
            
            // 酸液不腐蚀墙
            if (neighborId === ELEMENTS.WALL.id) continue;
            
            // 酸液与其他物质反应
            if (neighborId !== 0 && neighborId !== ELEMENTS.AIR.id &&
                neighborId !== ELEMENTS.ACID.id && neighborId !== ELEMENTS.SUPER_ACID.id) {
                const neighbor = getElById(neighborId);
                if (neighbor && !neighbor.indestructible) {
                    if (Math.random() < 0.05) { // 5%腐蚀概率
                        grid[ni] = 0;
                        // 如果腐蚀的是植物，移除生长记录
                        if (neighborId === ELEMENTS.PLANT.id ||
                            neighborId === ELEMENTS.VINE.id ||
                            neighborId === ELEMENTS.LEAF.id ||
                            neighborId === ELEMENTS.FLOWER.id ||
                            neighborId === ELEMENTS.SEED.id) {
                            removeGrowthRecords(ni);
                        }
                        // 酸液本身也可能消失
                        if (Math.random() < 0.2) {
                            grid[i] = 0;
                        }
                    }
                }
            }
        }
    }
}

// 种子可以在沙子上生长
function checkSeedGrowth(x, y) {
    const i = idx(x, y);
    
    if (grid[i] !== ELEMENTS.SEED.id) return;
    
    const below = idx(x, y + 1);
    if (y + 1 < height && (grid[below] === ELEMENTS.SAND.id ||
        grid[below] === ELEMENTS.PLANT.id ||
        grid[below] === ELEMENTS.VINE.id ||
        grid[below] === ELEMENTS.STONE.id)) {
        const existingIdx = seedGrowth.positions.indexOf(i);
        if (existingIdx === -1) {
            seedGrowth.positions.push(i);
            seedGrowth.heights.push(0);
            seedGrowth.directions.push(0);
            seedGrowth.maxHeights.push(8 + Math.floor(Math.random() * (GROWTH_LIMITS.MAX_SEED_GROWTH_HEIGHT - 8 + 1)));
            seedGrowth.growthTime.push(performance.now());
        }
    }
}

// 更新种子生长
function updateSeedGrowth(now) {
    for (let j = 0; j < seedGrowth.positions.length; j++) {
        const pos = seedGrowth.positions[j];
        const lastTime = seedGrowth.growthTime[j];
        const currentHeight = seedGrowth.heights[j];
        const currentDir = seedGrowth.directions[j];
        const maxHeight = seedGrowth.maxHeights[j];
        
        if (now - lastTime >= SEED_GROW_INTERVAL && currentHeight < maxHeight) {
            const x = pos % width;
            const y = Math.floor(pos / width);
            
            if (y - currentHeight < 0) {
                seedGrowth.heights[j] = maxHeight;
                continue;
            }
            
            const growY = y - currentHeight - 1;
            
            if (growY >= 0) {
                const growIdx = idx(x, growY);
                
                let newDir = currentDir;
                if (Math.random() < 0.3) {
                    newDir = Math.floor(Math.random() * 3) - 1;
                }
                
                const newX = Math.max(0, Math.min(width - 1, x + newDir));
                const finalGrowIdx = idx(newX, growY);
                
                if (grid[finalGrowIdx] === 0) {
                    if (Math.random() < 0.7) {
                        grid[finalGrowIdx] = ELEMENTS.PLANT.id;
                    } else {
                        grid[finalGrowIdx] = ELEMENTS.VINE.id;
                    }
                    
                    seedGrowth.heights[j] = currentHeight + 1;
                    seedGrowth.directions[j] = newDir;
                    seedGrowth.growthTime[j] = now;
                    
                    if (Math.random() < 0.2 && currentHeight > 3) {
                        const leafDir = Math.random() > 0.5 ? 1 : -1;
                        const leafX = Math.max(0, Math.min(width - 1, newX + leafDir));
                        const leafIdx = idx(leafX, growY);
                        if (grid[leafIdx] === 0) {
                            grid[leafIdx] = ELEMENTS.LEAF.id;
                        }
                    }
                    
                    if (seedGrowth.heights[j] === maxHeight) {
                        grid[finalGrowIdx] = ELEMENTS.FLOWER.id;
                        seedGrowth.positions.splice(j, 1);
                        seedGrowth.heights.splice(j, 1);
                        seedGrowth.directions.splice(j, 1);
                        seedGrowth.maxHeights.splice(j, 1);
                        seedGrowth.growthTime.splice(j, 1);
                        j--;
                    }
                }
            }
        }
    }
}

// 检查生命元素
function checkLifeElement(x, y) {
    const i = idx(x, y);
    
    if (grid[i] !== ELEMENTS.LIFE.id) return;
    
    const existingIdx = lifeElements.positions.indexOf(i);
    if (existingIdx === -1) {
        lifeElements.positions.push(i);
        lifeElements.lastMoveTime.push(performance.now());
        lifeElements.directions.push(Math.floor(Math.random() * 3) - 1);
        lifeElements.hunger.push(LIFE_MAX_HUNGER / 2);
        lifeElements.age.push(0);
        lifeElements.health.push(LIFE_MAX_HEALTH);
    }
}

// 更新生命元素
function updateLifeElements(now) {
    for (let j = 0; j < lifeElements.positions.length; j++) {
        const pos = lifeElements.positions[j];
        const lastTime = lifeElements.lastMoveTime[j];
        let dir = lifeElements.directions[j];
        let hunger = lifeElements.hunger[j];
        let age = lifeElements.age[j];
        let health = lifeElements.health[j];
        
        // 检查元素是否还存在
        if (grid[pos] !== ELEMENTS.LIFE.id) {
            lifeElements.positions.splice(j, 1);
            lifeElements.lastMoveTime.splice(j, 1);
            lifeElements.directions.splice(j, 1);
            lifeElements.hunger.splice(j, 1);
            lifeElements.age.splice(j, 1);
            lifeElements.health.splice(j, 1);
            j--;
            continue;
        }
        
        // 增加年龄
        age += 1;
        if (age > LIFE_MAX_AGE) {
            // 死亡，变成空气
            grid[pos] = 0;
            lifeElements.positions.splice(j, 1);
            lifeElements.lastMoveTime.splice(j, 1);
            lifeElements.directions.splice(j, 1);
            lifeElements.hunger.splice(j, 1);
            lifeElements.age.splice(j, 1);
            lifeElements.health.splice(j, 1);
            j--;
            continue;
        }
        
        // 减少饥饿值
        hunger -= 0.5;
        if (hunger <= 0) {
            // 饿死，变成空气
            grid[pos] = 0;
            lifeElements.positions.splice(j, 1);
            lifeElements.lastMoveTime.splice(j, 1);
            lifeElements.directions.splice(j, 1);
            lifeElements.hunger.splice(j, 1);
            lifeElements.age.splice(j, 1);
            lifeElements.health.splice(j, 1);
            j--;
            continue;
        }
        
        // 检查是否应该移动
        if (now - lastTime >= LIFE_MOVE_INTERVAL) {
            const x = pos % width;
            const y = Math.floor(pos / width);
            
            // 检查周围是否有植物可以吃
            const neighbors = [
                [x, y + 1],
                [x, y - 1],
                [x + 1, y],
                [x - 1, y]
            ];
            
            let atePlant = false;
            for (const [nx, ny] of neighbors) {
                if (inBounds(nx, ny)) {
                    const ni = idx(nx, ny);
                    const elemId = grid[ni];
                    // 可以吃的植物
                    if (elemId === ELEMENTS.PLANT.id ||
                        elemId === ELEMENTS.FLOWER.id ||
                        elemId === ELEMENTS.VINE.id ||
                        elemId === ELEMENTS.LEAF.id ||
                        elemId === ELEMENTS.SEED.id) {
                        // 吃掉植物
                        grid[ni] = 0;
                        // 从种子生长记录中移除
                        const seedIdx = seedGrowth.positions.indexOf(ni);
                        if (seedIdx !== -1) {
                            seedGrowth.positions.splice(seedIdx, 1);
                            seedGrowth.heights.splice(seedIdx, 1);
                            seedGrowth.directions.splice(seedIdx, 1);
                            seedGrowth.maxHeights.splice(seedIdx, 1);
                            seedGrowth.growthTime.splice(seedIdx, 1);
                        }
                        hunger = Math.min(LIFE_MAX_HUNGER, hunger + 30); // 增加饥饿值
                        atePlant = true;
                        break;
                    }
                }
            }
            
            if (!atePlant) {
                // 随机移动
                if (Math.random() < 0.3) { // 30%概率改变方向
                    dir = Math.floor(Math.random() * 3) - 1;
                    lifeElements.directions[j] = dir;
                }
                
                // 尝试移动
                const moveX = Math.max(0, Math.min(width - 1, x + dir));
                const moveIdx = idx(moveX, y);
                
                // 检查是否可以移动
                if (grid[moveIdx] === 0) {
                    // 移动到新位置
                    grid[pos] = 0;
                    grid[moveIdx] = ELEMENTS.LIFE.id;
                    lifeElements.positions[j] = moveIdx;
                    
                    // 检查繁殖
                    if (Math.random() < LIFE_BREED_CHANCE && hunger > LIFE_MAX_HUNGER * 0.7) {
                        // 检查周围是否有空位繁殖
                        const breedSpots = [];
                        const breedOffsets = [
                            [0, 1], [0, -1], [1, 0], [-1, 0]
                        ];
                        
                        for (const [dx, dy] of breedOffsets) {
                            const bx = moveX + dx;
                            const by = y + dy;
                            if (inBounds(bx, by)) {
                                const bi = idx(bx, by);
                                if (grid[bi] === 0) {
                                    breedSpots.push([bx, by, bi]);
                                }
                            }
                        }
                        
                        if (breedSpots.length > 0) {
                            // 繁殖一个新生命
                            const randomSpot = breedSpots[Math.floor(Math.random() * breedSpots.length)];
                            const [bx, by, bi] = randomSpot;
                            grid[bi] = ELEMENTS.LIFE.id;
                            hunger -= 20; // 繁殖消耗能量
                            
                            // 记录新生命
                            lifeElements.positions.push(bi);
                            lifeElements.lastMoveTime.push(now);
                            lifeElements.directions.push(Math.floor(Math.random() * 3) - 1);
                            lifeElements.hunger.push(LIFE_MAX_HUNGER * 0.5);
                            lifeElements.age.push(0);
                            lifeElements.health.push(LIFE_MAX_HEALTH);
                        }
                    }
                } else {
                    // 不能移动，尝试向上或向下
                    const tryUp = y - 1 >= 0 ? idx(moveX, y - 1) : -1;
                    const tryDown = y + 1 < height ? idx(moveX, y + 1) : -1;
                    
                    if (tryUp !== -1 && grid[tryUp] === 0) {
                        // 向上跳
                        grid[pos] = 0;
                        grid[tryUp] = ELEMENTS.LIFE.id;
                        lifeElements.positions[j] = tryUp;
                    } else if (tryDown !== -1 && grid[tryDown] === 0) {
                        // 向下跳
                        grid[pos] = 0;
                        grid[tryDown] = ELEMENTS.LIFE.id;
                        lifeElements.positions[j] = tryDown;
                    }
                }
            }
            
            // 更新状态
            lifeElements.hunger[j] = hunger;
            lifeElements.age[j] = age;
            lifeElements.health[j] = health;
            lifeElements.lastMoveTime[j] = now;
        }
    }
}

// 检查克隆元素并开始复制周围元素
function checkCloneElement(x, y) {
    const i = idx(x, y);
    
    if (grid[i] !== ELEMENTS.CLONE.id) return;
    
    const existingIdx = cloneElements.positions.indexOf(i);
    if (existingIdx === -1) {
        cloneElements.positions.push(i);
        cloneElements.lastCopyTime.push(performance.now());
        cloneElements.targetElements.push(0);
        cloneElements.copyCount.push(0);
        cloneElements.maxCopyCount.push(MAX_CLONE_COUNT);
    }
}

// 更新克隆元素
function updateCloneElements(now) {
    for (let j = 0; j < cloneElements.positions.length; j++) {
        const pos = cloneElements.positions[j];
        const lastTime = cloneElements.lastCopyTime[j];
        let targetElement = cloneElements.targetElements[j];
        const copyCount = cloneElements.copyCount[j];
        const maxCopyCount = cloneElements.maxCopyCount[j];
        
        // 检查元素是否还存在
        if (grid[pos] !== ELEMENTS.CLONE.id) {
            cloneElements.positions.splice(j, 1);
            cloneElements.lastCopyTime.splice(j, 1);
            cloneElements.targetElements.splice(j, 1);
            cloneElements.copyCount.splice(j, 1);
            cloneElements.maxCopyCount.splice(j, 1);
            j--;
            continue;
        }
        
        if (copyCount >= maxCopyCount) {
            cloneElements.positions.splice(j, 1);
            cloneElements.lastCopyTime.splice(j, 1);
            cloneElements.targetElements.splice(j, 1);
            cloneElements.copyCount.splice(j, 1);
            cloneElements.maxCopyCount.splice(j, 1);
            j--;
            continue;
        }
        
        if (now - lastTime >= CLONE_COPY_INTERVAL) {
            const x = pos % width;
            const y = Math.floor(pos / width);
            
            if (targetElement === 0) {
                const neighbors = [
                    [x, y + 1],
                    [x, y - 1],
                    [x + 1, y],
                    [x - 1, y],
                    [x + 1, y + 1],
                    [x - 1, y + 1],
                    [x + 1, y - 1],
                    [x - 1, y - 1]
                ];
                
                const nearbyElements = [];
                for (const [nx, ny] of neighbors) {
                    if (inBounds(nx, ny)) {
                        const ni = idx(nx, ny);
                        const elemId = grid[ni];
                        if (elemId !== 0 && elemId !== ELEMENTS.CLONE.id && elemId !== ELEMENTS.ERASER.id) {
                            nearbyElements.push(elemId);
                        }
                    }
                }
                
                if (nearbyElements.length > 0) {
                    targetElement = nearbyElements[Math.floor(Math.random() * nearbyElements.length)];
                    cloneElements.targetElements[j] = targetElement;
                } else {
                    cloneElements.lastCopyTime[j] = now;
                    continue;
                }
            }
            
            const emptySpots = [];
            const neighborOffsets = [
                [0, 1],
                [0, -1],
                [1, 0],
                [-1, 0],
                [1, 1],
                [-1, 1],
                [1, -1],
                [-1, -1]
            ];
            
            for (const [dx, dy] of neighborOffsets) {
                const nx = x + dx;
                const ny = y + dy;
                if (inBounds(nx, ny)) {
                    const ni = idx(nx, ny);
                    if (grid[ni] === 0 ||
                        grid[ni] === ELEMENTS.SMOKE.id ||
                        grid[ni] === ELEMENTS.GAS_FUEL.id) {
                        emptySpots.push([nx, ny, ni]);
                    }
                }
            }
            
            if (emptySpots.length > 0) {
                const numCopies = Math.min(emptySpots.length, Math.floor(Math.random() * 3) + 1);
                
                for (let k = 0; k < numCopies; k++) {
                    if (emptySpots.length === 0) break;
                    
                    const randomIndex = Math.floor(Math.random() * emptySpots.length);
                    const [copyX, copyY, copyIdx] = emptySpots[randomIndex];
                    
                    grid[copyIdx] = targetElement;
                    
                    emptySpots.splice(randomIndex, 1);
                    
                    cloneElements.copyCount[j]++;
                    
                    if (targetElement === ELEMENTS.SEED.id) {
                        checkSeedGrowth(copyX, copyY);
                    }
                    
                    if (targetElement === ELEMENTS.LIFE.id) {
                        checkLifeElement(copyX, copyY);
                    }
                }
                
                cloneElements.lastCopyTime[j] = now;
            } else {
                cloneElements.lastCopyTime[j] = now;
            }
        }
    }
}

// 移除生长记录
function removeGrowthRecords(index) {
    // 移除种子生长记录
    const seedIdx = seedGrowth.positions.indexOf(index);
    if (seedIdx !== -1) {
        seedGrowth.positions.splice(seedIdx, 1);
        seedGrowth.heights.splice(seedIdx, 1);
        seedGrowth.directions.splice(seedIdx, 1);
        seedGrowth.maxHeights.splice(seedIdx, 1);
        seedGrowth.growthTime.splice(seedIdx, 1);
    }
    
    // 移除生命元素记录
    const lifeIdx = lifeElements.positions.indexOf(index);
    if (lifeIdx !== -1) {
        lifeElements.positions.splice(lifeIdx, 1);
        lifeElements.lastMoveTime.splice(lifeIdx, 1);
        lifeElements.directions.splice(lifeIdx, 1);
        lifeElements.hunger.splice(lifeIdx, 1);
        lifeElements.age.splice(lifeIdx, 1);
        lifeElements.health.splice(lifeIdx, 1);
    }
    
    // 移除克隆元素记录
    const cloneIdx = cloneElements.positions.indexOf(index);
    if (cloneIdx !== -1) {
        cloneElements.positions.splice(cloneIdx, 1);
        cloneElements.lastCopyTime.splice(cloneIdx, 1);
        cloneElements.targetElements.splice(cloneIdx, 1);
        cloneElements.copyCount.splice(cloneIdx, 1);
        cloneElements.maxCopyCount.splice(cloneIdx, 1);
    }
}

// ================= 爆炸函数 =================
function doExplode(cx, cy, r, strength) {
    // 清除爆炸传播标记
    explosionPropagationGrid.fill(0);
    
    // 开始爆炸
    explodeAt(cx, cy, r, strength, 0);
}

function explodeAt(cx, cy, r, strength, depth) {
    // 防止无限递归
    if (depth > 5) return;
    
    const i = idx(cx, cy);
    if (explosionPropagationGrid[i] > 0) return; // 已经处理过
    explosionPropagationGrid[i] = 1;
    
    // 添加冲击波
    addShockWave(cx, cy, r, strength);
    
    // 爆炸效果
    for (let dy = -r; dy <= r; dy++) {
        for (let dx = -r; dx <= r; dx++) {
            const tx = cx + dx, ty = cy + dy;
            if (!inBounds(tx, ty)) continue;
            const d2 = dx * dx + dy * dy;
            if (d2 > r * r) continue;
            
            const ti = idx(tx, ty);
            const target = grid[ti];
            const tgtEl = getElById(target);
            
            if (!tgtEl) continue;
            
            if (target === ELEMENTS.WALL.id) { 
                grid[ti] = ELEMENTS.STONE.id; 
                continue; 
            }
            
            if (target === 0 || tgtEl.type === TYPES.LIQUID || tgtEl.type === TYPES.POWDER || tgtEl.type === TYPES.GAS) {
                // 爆炸效果
                if (grid[ti] === 0) {
                    // 空位产生火焰
                    if (Math.random() < 0.3) {
                        grid[ti] = ELEMENTS.FIRE.id;
                    }
                } else {
                    // 有物质的位置产生火花
                    const vx = (dx + Math.random() * 0.4 - 0.2) * 0.8;
                    const vy = (dy + Math.random() * 0.4 - 0.2) * 0.8 - 1;
                    sparks.push(new Spark(tx, ty, vx, vy, target));
                    grid[ti] = 0; // 清除原物质
                }
                
                // 移除生长记录
                removeGrowthRecords(ti);
            }
            
            // 检查是否引爆其他爆炸物
            if (tgtEl.explosive && explosionPropagationGrid[ti] === 0) {
                // 连锁爆炸 - 传播
                const chainStrength = strength * 0.7;
                const chainRadius = Math.max(2, r - 1);
                setTimeout(() => {
                    explodeAt(tx, ty, chainRadius, chainStrength, depth + 1);
                }, 10);
            }
        }
    }
}

function addShockWave(cx, cy, r, strength) {
    const r2 = r * r;
    for (let dy = -r; dy <= r; dy++) {
        for (let dx = -r; dx <= r; dx++) {
            const tx = cx + dx, ty = cy + dy;
            if (!inBounds(tx, ty)) continue;
            const d2 = dx * dx + dy * dy;
            if (d2 > r2) continue;
            const i = idx(tx, ty);
            const s = Math.floor(strength * (1 - Math.sqrt(d2) / r));
            shockWave[i] = Math.min(255, shockWave[i] + s);
            
            // 新增：石头被冲击波炸飞
            const elemId = grid[i];
            if (elemId === ELEMENTS.STONE.id) {
                // 石头被炸飞，变成沙子
                grid[i] = ELEMENTS.SAND.id;

                // 添加飞行的石头效果
                const force = strength * (1 - Math.sqrt(d2) / r) * 0.1;
                const angle = Math.atan2(dy, dx) + (Math.random() - 0.5) * 0.5;
                const vx = Math.cos(angle) * force;
                const vy = Math.sin(angle) * force - 1.5;

                flyingStones.positions.push([tx, ty]);
                flyingStones.velocitiesX.push(vx);
                flyingStones.velocitiesY.push(vy);
                flyingStones.timestamps.push(performance.now());
            }
        }
    }
}

function decayShockWave() {
    for (let i = 0; i < shockWave.length; i++) {
        if (shockWave[i] > 0) {
            shockWave[i] = Math.max(0, shockWave[i] - 8);
        }
    }
}

// 更新飞行的石头
function updateFlyingStones() {
    for (let i = flyingStones.positions.length - 1; i >= 0; i--) {
        const now = performance.now();
        const elapsed = now - flyingStones.timestamps[i];

        if (elapsed > FLYING_STONE_TTL) {
            // 飞行时间结束，变成沙子
            const [x, y] = flyingStones.positions[i];
            const ix = Math.floor(x);
            const iy = Math.floor(y);
            if (inBounds(ix, iy)) {
                const idxPos = idx(ix, iy);
                if (grid[idxPos] === 0) {
                    grid[idxPos] = ELEMENTS.SAND.id;
                }
            }

            flyingStones.positions.splice(i, 1);
            flyingStones.velocitiesX.splice(i, 1);
            flyingStones.velocitiesY.splice(i, 1);
            flyingStones.timestamps.splice(i, 1);
            continue;
        }

        // 更新位置
        let [x, y] = flyingStones.positions[i];
        let vx = flyingStones.velocitiesX[i];
        let vy = flyingStones.velocitiesY[i];

        // 应用重力
        vy += 0.2;

        // 更新位置
        x += vx;
        y += vy;

        // 边界检查
        if (x < 0 || x >= width || y >= height) {
            // 出界变成沙子
            const ix = Math.max(0, Math.min(width - 1, Math.floor(x)));
            const iy = Math.max(0, Math.min(height - 1, Math.floor(y)));
            if (inBounds(ix, iy)) {
                const idxPos = idx(ix, iy);
                if (grid[idxPos] === 0) {
                    grid[idxPos] = ELEMENTS.SAND.id;
                }
            }

            flyingStones.positions.splice(i, 1);
            flyingStones.velocitiesX.splice(i, 1);
            flyingStones.velocitiesY.splice(i, 1);
            flyingStones.timestamps.splice(i, 1);
            continue;
        }

        // 碰撞检查
        const ix = Math.floor(x);
        const iy = Math.floor(y);
        if (inBounds(ix, iy)) {
            const idxPos = idx(ix, iy);
            const elemId = grid[idxPos];

            if (elemId !== 0 && elemId !== ELEMENTS.AIR.id) {
                // 碰到其他元素，变成沙子
                grid[idxPos] = ELEMENTS.SAND.id;

                flyingStones.positions.splice(i, 1);
                flyingStones.velocitiesX.splice(i, 1);
                flyingStones.velocitiesY.splice(i, 1);
                flyingStones.timestamps.splice(i, 1);
                continue;
            }
        }

        // 保存更新后的位置和速度
        flyingStones.positions[i] = [x, y];
        flyingStones.velocitiesX[i] = vx;
        flyingStones.velocitiesY[i] = vy;
    }
}

// ================= 游戏主循环 =================
function update() {
    if (isPaused) return;
    
    const now = performance.now();
    
    // 更新温度系统
    updateTemperature();
    
    // 更新铜氧化
    updateCopperOxidation();
    
    // 更新镁燃烧
    updateMagnesiumBurn(now);
    
    decayShockWave();
    
    // 更新火花
    for (let i = sparks.length - 1; i >= 0; i--) {
        if (sparks[i].update()) sparks.splice(i, 1);
    }
    
    // 更新飞行的石头
    updateFlyingStones();
    
    // 更新种子生长
    updateSeedGrowth(now);
    
    // 更新生命元素
    updateLifeElements(now);
    
    // 更新克隆元素
    updateCloneElements(now);
    
    // 物理更新
    updatePhysics();
    
    // 后处理：绝对零度效果
    postFreezeGravity();
    
    draw();
    animationId = requestAnimationFrame(update);
}

function updatePhysics() {
    const startRow = height - 1;
    const endRow = -1;
    const stepRow = -1;

    for (let y = startRow; y !== endRow; y += stepRow) {
        const scanLeft = Math.random() > 0.5;
        const startX = scanLeft ? 0 : width - 1;
        const endX = scanLeft ? width : -1;
        const stepX = scanLeft ? 1 : -1;

        for (let x = startX; x !== endX; x += stepX) {
            const i = idx(x, y);
            const id = grid[i];
            if (id === 0) continue;

            const el = getElById(id);
            if (!el) continue;

            // 跳过不可破坏的元素
            if (el.indestructible || el.type === TYPES.INDESTRUCTIBLE) {
                continue;
            }

            // 处理零重力
            if (zeroGravity) {
                continue;
            }

            // 检查化学反应
            checkWaterOilReaction(x, y);
            checkSodiumWaterReaction(x, y);
            checkSuperAcidReaction(x, y);
            checkAcidReaction(x, y);
            
            // 检查种子生长
            if (el.id === ELEMENTS.SEED.id) {
                checkSeedGrowth(x, y);
            }
            
            // 检查生命元素
            if (el.id === ELEMENTS.LIFE.id) {
                checkLifeElement(x, y);
            }
            
            // 检查克隆元素
            if (el.id === ELEMENTS.CLONE.id) {
                checkCloneElement(x, y);
            }
            
            // 检查火药 - 温度爆炸
            if (el.id === ELEMENTS.GUNPOWDER.id && temperatureSystemEnabled) {
                const temp = temperatures[i];
                if (temp > el.ignitesAt) {
                    // 温度达到燃点，爆炸
                    doExplode(x, y, 4, 180);
                    continue;
                }
            }
            
            // 检查火药 - 接触岩浆爆炸
            if (el.id === ELEMENTS.GUNPOWDER.id) {
                const aroundLava = [[0, 1], [0, -1], [1, 0], [-1, 0]].some(([dx, dy]) => {
                    const ni = idx(x + dx, y + dy);
                    return inBounds(x + dx, y + dy) && grid[ni] === ELEMENTS.LAVA.id;
                });
                
                if (aroundLava) {
                    // 接触岩浆，爆炸
                    doExplode(x, y, 4, 180);
                    continue;
                }
            }
            
            // 检查火
            if (el.id === ELEMENTS.FIRE.id) {
                updateFireImproved(x, y, i);
                continue;
            }
            
            // 检查烟雾
            if (el.id === ELEMENTS.SMOKE.id) {
                updateSmokeImproved(x, y, i);
                continue;
            }
            
            // 检查酸
            if (el.acidity) {
                updateLiquid(x, y, i, el.id);
                continue;
            }
            
            // 检查燃气
            if (el.id === ELEMENTS.GAS_FUEL.id) {
                updateFuelGasImproved(x, y, i);
                continue;
            }
            
            // 检查可熔化物质
            if (el.meltable) {
                const aroundHot = [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [-1, 1], [1, -1], [-1, -1]].some(([dx, dy]) => {
                    const ni = idx(x + dx, y + dy);
                    if (!inBounds(x + dx, y + dy)) return false;
                    const neighbor = getElById(grid[ni]);
                    return neighbor && (neighbor.id === ELEMENTS.FIRE.id || neighbor.id === ELEMENTS.LAVA.id);
                });
                if (aroundHot && Math.random() < 0.05) {
                    grid[i] = ELEMENTS.WATER.id;
                    continue;
                }
            }
            
            // 检查岩浆
            if (el.id === ELEMENTS.LAVA.id) {
                updateLava(x, y, i);
                continue;
            }
            
            // 检查石头
            if (el.id === ELEMENTS.STONE.id) {
                updateStone(x, y, i);
                continue;
            }
            
            // 检查蒸汽
            if (el.id === ELEMENTS.STEAM.id) {
                updateSteamImproved(x, y, i);
                continue;
            }
            
            // 检查金属固体
            if (el.type === TYPES.METAL_SOLID) {
                updateMetalSolid(x, y, i, el);
                continue;
            }
            
            // 检查金属液体
            if (el.type === TYPES.METAL_LIQUID) {
                updateMetalLiquid(x, y, i, el);
                continue;
            }
            
            // 根据类型处理运动
            switch(el.type) {
                case TYPES.POWDER:
                    updatePowder(x, y, i);
                    break;
                case TYPES.LIQUID:
                case TYPES.ACID:
                    updateLiquid(x, y, i, el.id);
                    break;
                case TYPES.GAS:
                    updateGasImproved(x, y, i, el);
                    break;
                case TYPES.SOLID:
                    // 固体不移动
                    break;
            }
        }
    }
}

// ================= 温度系统函数 =================
function updateTemperature() {
    // 全局急冻守护
    enforceGlobalFreeze();
    
    if (!temperatureSystemEnabled) return;
    
    const transferRate = heatTransferSpeed * 0.02;
    const ambientEffect = 0.01;
    
    const newTemps = new Float32Array(temperatures);
    
    for (let i = 0; i < grid.length; i++) {
        if (grid[i] === 0) continue;
        
        const x = i % width;
        const y = Math.floor(i / width);
        const elem = getElById(grid[i]);
        if (!elem) continue;
        
        // 高度隔热材料跳过
        if (elem.heatResistance >= 0.95) continue;
        
        const currentTemp = temperatures[i];
        let totalTemp = 0;
        let neighborCount = 0;
        
        // 检查四个方向的邻居
        const neighbors = [
            idx(x, y - 1), idx(x, y + 1),
            idx(x - 1, y), idx(x + 1, y)
        ];
        
        for (const ni of neighbors) {
            if (ni !== -1 && ni >= 0 && ni < grid.length) {
                const neighborElem = getElById(grid[ni]);
                if (neighborElem && neighborElem.heatResistance < 0.95) {
                    totalTemp += temperatures[ni];
                    neighborCount++;
                }
            }
        }
        
        if (neighborCount > 0) {
            const avgTemp = totalTemp / neighborCount;
            const tempDiff = avgTemp - currentTemp;
            const heatTransfer = tempDiff * transferRate * (1 - elem.heatResistance);
            
            newTemps[i] += heatTransfer;
        }
        
        // 环境温度影响
        newTemps[i] += (ambientTemperature - newTemps[i]) * ambientEffect;
        
        // 发热元素
        if (elem.heatEmission) {
            newTemps[i] += elem.heatEmission * 0.1;
        }
        
        // 应用温度效应
        applyTemperatureEffects(i, x, y, newTemps[i]);
    }
    
    // 更新温度数组
    temperatures.set(newTemps);
    
    // 限制温度范围
    for (let i = 0; i < temperatures.length; i++) {
        if (temperatures[i] < -273) temperatures[i] = -273;
        if (temperatures[i] > 5000) temperatures[i] = 5000;
    }
}

// 更新铜氧化
function updateCopperOxidation() {
    if (!temperatureSystemEnabled) return;
    
    for (let i = 0; i < grid.length; i++) {
        if (grid[i] === ELEMENTS.COPPER.id || grid[i] === ELEMENTS.COPPER_LIQUID.id) {
            const temp = temperatures[i];
            // 铜在高温下会氧化（变黑）
            if (temp > 200) {
                copperOxidation[i] = Math.min(255, copperOxidation[i] + 1);
            }
        }
    }
}

// 更新镁燃烧
function updateMagnesiumBurn(now) {
    for (let i = 0; i < grid.length; i++) {
        if (grid[i] === ELEMENTS.MAGNESIUM.id || grid[i] === ELEMENTS.MAGNESIUM_LIQUID.id) {
            const temp = temperatures[i];
            const elem = getElById(grid[i]);
            
            // 检查是否达到燃点
            if (elem.ignitesAt && temp > elem.ignitesAt) {
                // 开始燃烧
                if (magnesiumBurn[i] === 0) {
                    magnesiumBurn[i] = 1;
                }
                
                // 燃烧效果（冲击波效果）
                if (Math.random() < 0.1) {
                    const x = i % width;
                    const y = Math.floor(i / width);
                    addShockWave(x, y, 2, 50);
                }
                
                // 逐渐消耗
                if (Math.random() < 0.01) {
                    grid[i] = 0;
                    magnesiumBurn[i] = 0;
                }
            } else {
                magnesiumBurn[i] = 0;
            }
        }
    }
}

// ===== 全局急冻守护：温度系统开启且环境温度＜-50℃ 时，把水/蒸汽瞬间冻成冰 =====
function enforceGlobalFreeze() {
    if (!temperatureSystemEnabled || ambientTemperature >= -50) return;
    
    for (let i = 0; i < grid.length; i++) {
        const id = grid[i];
        if (id === ELEMENTS.WATER.id || id === ELEMENTS.STEAM.id) {
            grid[i] = ELEMENTS.ICE.id;
            temperatures[i] = ambientTemperature;
        }
    }
}

// 绝对零度：液体/气体强制只向下掉一格（不改 ID，不改 type）
function postFreezeGravity() {
    if (!temperatureSystemEnabled || ambientTemperature > -273) return;
    
    const h = height, w = width;
    // 从下往上扫，避免覆盖干扰
    for (let y = h - 2; y >= 0; y--) {
        for (let x = 0; x < w; x++) {
            const i = idx(x, y);
            const id = grid[i];
            if (id === 0) continue;
            
            const el = getElById(id);
            // 只处理液体/气体
            if (!el || (el.type !== TYPES.LIQUID && el.type !== TYPES.GAS)) continue;
            
            const below = idx(x, y + 1);
            if (y + 1 < h && grid[below] === 0) {
                // 直接交换，实现"只掉一格"
                grid[i] = 0;
                grid[below] = id;
                // 温度也跟着走
                temperatures[below] = temperatures[i];
                temperatures[i] = ambientTemperature;
            }
        }
    }
}

function applyTemperatureEffects(i, x, y, temp) {
    const elemId = grid[i];
    const elem = getElById(elemId);
    if (!elem) return;
    
    // 冰融化（当温度大于0°C时）
    if (elemId === ELEMENTS.ICE.id && temp > 0) {
        if (Math.random() < 0.01) {
            grid[i] = ELEMENTS.WATER.id;
            temperatures[i] = Math.max(temp, 5);
        }
        return;
    }
    
    // 水结冰（当温度小于等于0°C时）
    if (elemId === ELEMENTS.WATER.id && temp <= 0) {
        if (Math.random() < 0.01) {
            grid[i] = ELEMENTS.ICE.id;
            temperatures[i] = Math.min(temp, -5);
        }
        return;
    }
    
    // 水沸腾变成蒸汽
    if (elemId === ELEMENTS.WATER.id && elem.boilsAt && temp > elem.boilsAt) {
        if (Math.random() < 0.05) {
            grid[i] = ELEMENTS.STEAM.id;
            temperatures[i] = 120;
        }
        return;
    }
    
    // 蒸汽凝结
    if (elemId === ELEMENTS.STEAM.id && elem.condensesAt && temp < elem.condensesAt) {
        if (Math.random() < 0.05) {
            grid[i] = ELEMENTS.WATER.id;
            temperatures[i] = Math.min(temp, 95);
        }
        return;
    }
    
    // 物质燃烧
    if (elem.flammable && elem.ignitesAt && temp > elem.ignitesAt) {
        if (Math.random() < 0.01) {
            grid[i] = ELEMENTS.FIRE.id;
            temperatures[i] = 500;
        }
        return;
    }
    
    // 沙子熔化形成玻璃
    if (elemId === ELEMENTS.SAND.id && elem.meltsAt && temp > elem.meltsAt) {
        if (Math.random() < 0.001) {
            grid[i] = ELEMENTS.GLASS.id;
        }
        return;
    }
    
    // 生命死亡
    if (elemId === ELEMENTS.LIFE.id) {
        if ((elem.diesAt && temp > elem.diesAt) || (elem.freezeAt && temp < elem.freezeAt)) {
            if (Math.random() < 0.01) {
                grid[i] = 0;
                removeGrowthRecords(i);
            }
        }
    }
    
    // 金属熔化
    if (elem.meltsAt && temp > elem.meltsAt) {
        if (elem.meltTo && Math.random() < 0.01) {
            const meltElem = ELEMENTS[elem.meltTo];
            if (meltElem) {
                grid[i] = meltElem.id;
                temperatures[i] = elem.meltsAt + 50;
            }
        }
        return;
    }
    
    // 金属凝固
    if (elem.freezesAt && temp < elem.freezesAt) {
        if (elem.freezeTo && Math.random() < 0.01) {
            const freezeElem = ELEMENTS[elem.freezeTo];
            if (freezeElem) {
                grid[i] = freezeElem.id;
                temperatures[i] = elem.freezesAt - 50;
            }
        }
        return;
    }
}

// ================= 绘制函数 =================
function draw() {
    const data = imageData.data;
    
    // 清空画布
    for (let i = 0; i < data.length; i += 4) {
        data[i] = 0;
        data[i + 1] = 0;
        data[i + 2] = 0;
        data[i + 3] = 255;
    }
    
    // 绘制网格元素
    for (let i = 0; i < grid.length; i++) {
        const id = grid[i];
        if (id === 0) continue;
        
        const el = getElById(id);
        if (!el) continue;
        
        const p = i * 4;
        let r = el.color[0] || 0;
        let g = el.color[1] || 0;
        let b = el.color[2] || 0;
        let a = el.color[3] !== undefined ? el.color[3] : 255;
        
        // 添加变化
        if (!isSmoothMode && el.variance) {
            const v = (Math.random() * el.variance - el.variance / 2);
            r = clamp(r + v);
            g = clamp(g + v);
            b = clamp(b + v);
        }
        
        // 铜氧化效果
        if ((id === ELEMENTS.COPPER.id || id === ELEMENTS.COPPER_LIQUID.id) && copperOxidation[i] > 0) {
            const oxidation = copperOxidation[i] / 255;
            r = clamp(r * (1 - oxidation * 0.5));
            g = clamp(g * (1 - oxidation * 0.7));
            b = clamp(b * (1 - oxidation * 0.3));
        }
        
        // 镁燃烧效果
        if ((id === ELEMENTS.MAGNESIUM.id || id === ELEMENTS.MAGNESIUM_LIQUID.id) && magnesiumBurn[i] > 0) {
            const burnIntensity = magnesiumBurn[i];
            r = clamp(r + 100 * burnIntensity);
            g = clamp(g + 50 * burnIntensity);
            b = clamp(b - 50 * burnIntensity);
        }
        
        // 温度着色
        if (temperatureSystemEnabled && temperatures[i] !== ambientTemperature) {
            const temp = temperatures[i];
            if (temp > 100) {
                const heatIntensity = Math.min(1, (temp - 100) / 500);
                r = clamp(r + 100 * heatIntensity);
                g = clamp(g - 50 * heatIntensity);
                b = clamp(b - 80 * heatIntensity);
            } else if (temp < 0) {
                const coldIntensity = Math.min(1, Math.abs(temp) / 50);
                r = clamp(r - 30 * coldIntensity);
                g = clamp(g + 20 * coldIntensity);
                b = clamp(b + 50 * coldIntensity);
            }
        }
        
        // 岩浆发光效果
        if (el.id === ELEMENTS.LAVA.id) {
            const pulse = Math.sin(performance.now() * 0.01) * 30;
            r = clamp(r + pulse);
            g = clamp(g + pulse * 0.5);
        }
        
        // 克隆元素脉冲效果
        if (el.id === ELEMENTS.CLONE.id) {
            const pulse = Math.sin(performance.now() * 0.008) * 30;
            r = clamp(r + pulse);
            g = clamp(g - pulse * 0.3);
            b = clamp(b + pulse * 0.5);
        }
        
        // 冲击波效果
        if (shockWave[i] > 30) {
            const waveIntensity = shockWave[i] / 255;
            r = clamp(r + 255 * waveIntensity);
            g = clamp(g + 200 * waveIntensity);
            b = clamp(b + 100 * waveIntensity);
        }
        
        // 生命元素脉动效果
        if (el.id === ELEMENTS.LIFE.id) {
            const pulse = Math.sin(performance.now() * 0.015 + i * 0.03) * 20;
            r = clamp(r + pulse);
            g = clamp(g - pulse * 0.5);
            b = clamp(b - pulse * 0.5);
        }
        
        // 火药危险状态效果（温度接近燃点时闪烁）
        if (el.id === ELEMENTS.GUNPOWDER.id && temperatureSystemEnabled) {
            const temp = temperatures[i];
            if (temp > el.ignitesAt * 0.8) {
                const danger = Math.sin(performance.now() * 0.02) * 30 + 30;
                r = clamp(r + danger);
                g = clamp(g + danger * 0.5);
            }
        }
        
        // 设置像素颜色
        data[p] = r;
        data[p + 1] = g;
        data[p + 2] = b;
        data[p + 3] = a;
    }
    
    // 绘制飞行的石头
    for (let i = 0; i < flyingStones.positions.length; i++) {
        const [x, y] = flyingStones.positions[i];
        const ix = Math.floor(x);
        const iy = Math.floor(y);
        if (inBounds(ix, iy)) {
            const idxPos = idx(ix, iy);
            const p = idxPos * 4;
            // 飞行的石头颜色（比普通石头亮）
            data[p] = 150;
            data[p + 1] = 150;
            data[p + 2] = 150;
            data[p + 3] = 255;
        }
    }
    
    // 绘制火花
    for (const s of sparks) {
        const sx = Math.floor(s.x), sy = Math.floor(s.y);
        if (inBounds(sx, sy)) {
            const i = idx(sx, sy);
            const p = i * 4;
            data[p] = 255;
            data[p + 1] = 200;
            data[p + 2] = 0;
            data[p + 3] = 255;
        }
    }
    
    // 绘制冲击波
    for (let i = 0; i < shockWave.length; i++) {
        if (shockWave[i] > 30) {
            const px = (i % width) * 4;
            const py = Math.floor(i / width) * 4;
            const base = (py * width + px) * 4;
            const waveIntensity = shockWave[i] / 255;
            data[base] = Math.min(255, data[base] + 255 * waveIntensity);
            data[base + 1] = Math.min(255, data[base + 1] + 200 * waveIntensity);
            data[base + 2] = Math.min(255, data[base + 2] + 100 * waveIntensity);
        }
    }
    
    // 更新画布
    ctx.putImageData(imageData, 0, 0);
    
    // 更新FPS计数
    updateFPS();
}

function updateFPS() {
    const currentTime = performance.now();
    const elapsed = currentTime - lastTime;
    
    if (elapsed >= fpsUpdateInterval) {
        fps = Math.round((frameCount * 1000) / elapsed);
        frameCount = 0;
        lastTime = currentTime;
        
        fpsDisplay.textContent = `FPS: ${fps}`;
        document.getElementById('fps-counter').textContent = `${fps} FPS`;
    }
    frameCount++;
}

const clamp = v => Math.max(0, Math.min(255, v));

function loop() {
    update();
}

// ================= UI控制函数 =================
function initUI() {
    initGrid();
    
    const quickBar = document.getElementById('quick-bar');
    const allGrid = document.getElementById('all-elements-grid');
    
    // 创建快速栏
    QUICK_KEYS.forEach(key => {
        const el = ELEMENTS[key];
        const btn = document.createElement('button');
        btn.className = 'chip';
        btn.dataset.key = key;
        btn.innerText = el.name;
        btn.onclick = () => selectElement(key);
        if (key === 'SAND') btn.classList.add('active');
        quickBar.appendChild(btn);
    });
    
    // 创建所有元素网格
    Object.keys(ELEMENTS).forEach(key => {
        if (key === 'AIR') return;
        const el = ELEMENTS[key];
        const card = document.createElement('div');
        card.className = 'element-card';
        card.onclick = () => selectElement(key);
        
        const dot = document.createElement('div');
        dot.className = 'element-color-dot';
        
        if (el.isEraser) {
            dot.style.background = '#fff';
            dot.style.border = '2px solid #ccc';
            dot.style.backgroundImage = 'linear-gradient(45deg, #ccc 25%, transparent 25%, transparent 75%, #ccc 75%, #ccc), linear-gradient(45deg, #ccc 25%, transparent 25%, transparent 75%, #ccc 75%, #ccc)';
            dot.style.backgroundSize = '10px 10px';
            dot.style.backgroundPosition = '0 0, 5px 5px';
        } else {
            const [r, g, b, a = 255] = el.color;
            dot.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${a / 255})`;
            
            // 添加特殊效果
            if (el.hot) {
                dot.style.boxShadow = `0 0 8px rgba(${Math.min(r+50, 255)}, ${Math.min(g+50, 255)}, ${Math.min(b+50, 255)}, 0.8)`;
            }
            
            if (el.type === TYPES.ACID) {
                dot.style.boxShadow = `0 0 6px rgba(${r}, ${g}, ${b}, 0.6)`;
            }
            
            // 火药特殊效果
            if (el.id === ELEMENTS.GUNPOWDER.id) {
                dot.style.boxShadow = '0 0 8px rgba(255, 200, 0, 0.8)';
                dot.style.animation = 'pulse 2s infinite';
            }
        }
        
        const name = document.createElement('span');
        name.style.fontSize = '14px';
        name.innerText = el.name;
        
        card.appendChild(dot);
        card.appendChild(name);
        allGrid.appendChild(card);
    });
    
    // 更新元素计数器
    const totalElements = Object.keys(ELEMENTS).length - 1; // 减去AIR
    document.getElementById('element-counter').textContent = `当前共有 ${totalElements} 种元素`;
    
    updateActiveState();
}

function selectElement(key) {
    currentElement = ELEMENTS[key];
    updateActiveState();
    toggleSheet(false);
}

function updateActiveState() {
    const currentKey = Object.keys(ELEMENTS).find(k => ELEMENTS[k] === currentElement);
    document.querySelectorAll('.chip').forEach(chip => {
        chip.classList.toggle('active', chip.dataset.key === currentKey);
    });
}

// ================= 控制函数 =================
function togglePause() {
    isPaused = !isPaused;
    const pauseIcon = document.getElementById('pauseIcon');
    const pausedIndicator = document.getElementById('pausedIndicator');
    const btn = document.getElementById('pause-btn');
    
    if (isPaused) {
        btn.innerHTML = '<span class="material-symbols-outlined">play_arrow</span>';
        pausedIndicator.style.display = 'block';
        cancelAnimationFrame(animationId);
    } else {
        btn.innerHTML = '<svg viewBox="0 0 24 24" id="pauseIcon"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>';
        pausedIndicator.style.display = 'none';
        loop();
    }
}

function toggleBrushShape() {
    brushShape = brushShape === 'circle' ? 'square' : 'circle';
    const btn = document.getElementById('shape-toggle');
    if (brushShape === 'square') {
        btn.innerHTML = '<span class="material-symbols-outlined" style="font-size:18px;">square</span>';
        btn.title = "形状: 方形";
    } else {
        btn.innerHTML = '<span class="material-symbols-outlined" style="font-size:18px;">circle</span>';
        btn.title = "形状: 圆形";
    }
}

function toggleGravity() {
    zeroGravity = !zeroGravity;
    const btn = document.getElementById('gravity-btn');
    if (zeroGravity) {
        btn.classList.add('active');
    } else {
        btn.classList.remove('active');
    }
}

function toggleGrid() {
    showGrid = !showGrid;
    const overlay = document.getElementById('grid-overlay');
    const btn = document.getElementById('grid-btn');
    if (showGrid) {
        overlay.classList.add('active');
        btn.classList.add('active');
    } else {
        overlay.classList.remove('active');
        btn.classList.remove('active');
    }
}

function toggleSmoothMode() {
    isSmoothMode = document.getElementById('smooth-toggle').checked;
}

function changeResolution(val) {
    canvasScale = parseInt(val);
    initGrid();
}

function clearCanvas() {
    grid.fill(0);
    sparks.length = 0;
    shockWave.fill(0);
    copperOxidation.fill(0);
    magnesiumBurn.fill(0);
    explosionPropagationGrid.fill(0);
    
    // 清空生长状态
    seedGrowth.positions = [];
    seedGrowth.heights = [];
    seedGrowth.directions = [];
    seedGrowth.maxHeights = [];
    seedGrowth.growthTime = [];
    
    lifeElements.positions = [];
    lifeElements.lastMoveTime = [];
    lifeElements.directions = [];
    lifeElements.hunger = [];
    lifeElements.age = [];
    lifeElements.health = [];
    
    cloneElements.positions = [];
    cloneElements.lastCopyTime = [];
    cloneElements.targetElements = [];
    cloneElements.copyCount = [];
    cloneElements.maxCopyCount = [];
    
    flyingStones.positions = [];
    flyingStones.velocitiesX = [];
    flyingStones.velocitiesY = [];
    flyingStones.timestamps = [];
    
    if (temperatureSystemEnabled) {
        temperatures.fill(ambientTemperature);
    }
}

// ================= 温度控制函数 =================
function toggleTemperatureSystem() {
    temperatureSystemEnabled = document.getElementById('tempToggle').checked;
    tempDisplay.textContent = temperatureSystemEnabled ?
        `温度系统: 开启 (${ambientTemperature}°C)` : '温度系统: 关闭';
    
    if (!temperatureSystemEnabled) {
        temperatures.fill(ambientTemperature);
    }
}

// 温度UI控制
document.getElementById('heatTransferSpeed').addEventListener('input', function() {
    heatTransferSpeed = parseInt(this.value);
    document.getElementById('heatTransferValue').textContent = heatTransferSpeed;
});

document.getElementById('ambientTemp').addEventListener('input', function() {
    ambientTemperature = parseInt(this.value);
    document.getElementById('ambientTempValue').textContent = `${ambientTemperature}°C`;
    tempDisplay.textContent = temperatureSystemEnabled ?
        `温度系统: 开启 (${ambientTemperature}°C)` : '温度系统: 关闭';
    
    if (!temperatureSystemEnabled) {
        temperatures.fill(ambientTemperature);
    }
});

// ================= 输入处理 =================
let isDrawing = false;

function handleInput(e) {
    e.preventDefault();

    if (!isDrawing && e.type !== 'mousemove' && e.type !== 'touchmove') return;
    if (!isDrawing && (e.type === 'mousemove' || e.type === 'touchmove')) return;

    const rect = canvas.getBoundingClientRect();
    let cx = e.touches ? e.touches[0].clientX : e.clientX;
    let cy = e.touches ? e.touches[0].clientY : e.clientY;
    
    const x = Math.floor((cx - rect.left) / (rect.width / width));
    const y = Math.floor((cy - rect.top) / (rect.height / height));
    const r = parseInt(document.getElementById('brushSize').value);

    if (brushShape === 'square') {
        for (let dy = -r; dy <= r; dy++) {
            for (let dx = -r; dx <= r; dx++) {
                const px = x + dx;
                const py = y + dy;
                drawPixel(px, py);
            }
        }
    } else {
        for (let dy = -r; dy <= r; dy++) {
            for (let dx = -r; dx <= r; dx++) {
                if (dx * dx + dy * dy <= r * r) {
                    const px = x + dx;
                    const py = y + dy;
                    drawPixel(px, py);
                }
            }
        }
    }
}

function drawPixel(px, py) {
    if (inBounds(px, py)) {
        const i = idx(px, py);
        if (currentElement.isEraser) {
            grid[i] = 0;
            if (temperatureSystemEnabled) {
                temperatures[i] = ambientTemperature;
            }
            // 移除生长记录
            removeGrowthRecords(i);
        } else if (grid[i] === 0) {  // 只能放在空位置，不能覆盖原有物质
            grid[i] = currentElement.id;
            if (temperatureSystemEnabled) {
                temperatures[i] = currentElement.defaultTemp || ambientTemperature;
            }
            // 如果是种子，检查生长
            if (currentElement.id === ELEMENTS.SEED.id) {
                checkSeedGrowth(px, py);
            }
            // 如果是生命，检查记录
            if (currentElement.id === ELEMENTS.LIFE.id) {
                checkLifeElement(px, py);
            }
            // 如果是克隆，检查记录
            if (currentElement.id === ELEMENTS.CLONE.id) {
                checkCloneElement(px, py);
            }
        }
    }
}

// 事件监听器
canvas.addEventListener('mousedown', e => {
    isDrawing = true;
    handleInput(e);
});
canvas.addEventListener('mousemove', handleInput);
window.addEventListener('mouseup', () => {
    isDrawing = false;
});

canvas.addEventListener('touchstart', e => {
    isDrawing = true;
    handleInput(e);
}, { passive: false });
canvas.addEventListener('touchmove', handleInput, { passive: false });
window.addEventListener('touchend', () => {
    isDrawing = false;
});

// ================= 面板控制函数 =================
function toggleSheet(open) {
    const sheet = document.getElementById('more-sheet');
    toggleBackdrop(open);
    if (open) sheet.classList.add('open');
    else sheet.classList.remove('open');
}

function toggleBackdrop(show) {
    const bd = document.getElementById('backdrop');
    if (show) bd.classList.add('open');
    else bd.classList.remove('open');
}

function openSettings() {
    document.getElementById('settings-overlay').classList.add('show');
    toggleBackdrop(true);
}

function closeSettings(e) {
    if (e.target.id === 'settings-overlay') {
        document.getElementById('settings-overlay').classList.remove('show');
        toggleBackdrop(false);
    }
}

function openSourceView() {
    const htmlContent = "<!DOCTYPE html>\n" + document.documentElement.outerHTML;
    document.getElementById('source-code-view').value = htmlContent;
    document.getElementById('settings-overlay').classList.remove('show');
    document.getElementById('source-overlay').classList.add('show');
    toggleBackdrop(true);
}

function copySource() {
    const textArea = document.getElementById('source-code-view');
    textArea.select();
    document.execCommand('copy');
    const btnText = document.getElementById('copy-btn-text');
    const original = btnText.innerText;
    btnText.innerText = "已复制";
    setTimeout(() => btnText.innerText = original, 2000);
}

function closeSource(e) {
    if (e.target.id === 'source-overlay') {
        document.getElementById('source-overlay').classList.remove('show');
        toggleBackdrop(false);
    }
}

function openAbout() {
    document.getElementById('about-overlay').classList.add('show');
    toggleBackdrop(true);
}

function closeAbout(e) {
    if (e.target.id === 'about-overlay') {
        document.getElementById('about-overlay').classList.remove('show');
        toggleBackdrop(false);
    }
}

function closeAllOverlays() {
    toggleSheet(false);
    document.getElementById('settings-overlay').classList.remove('show');
    document.getElementById('about-overlay').classList.remove('show');
    document.getElementById('source-overlay').classList.remove('show');
}

// ================= 初始化 =================
window.addEventListener('load', () => {
    initUI();
    loop();
    // FPS一直显示
    // document.getElementById('fps-counter').style.display = 'block';
});

// 添加CSS动画
const style = document.createElement('style');
style.textContent = `
@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
}

.advanced-btn.active {
    background: var(--md-sys-color-primary);
    color: var(--md-sys-color-on-primary);
}
`;
document.head.appendChild(style);
</script>
</body>
</html>