<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>沙盒沙箱模拟器 MD3</title>
<style>
/*  MD3 深色主题 */
:root {
  --md-sys-color-primary: #6750A4;
  --md-sys-color-on-primary: #FFFFFF;
  --md-sys-color-primary-container: #EADDFF;
  --md-sys-color-on-primary-container: #21005D;
  --md-sys-color-secondary: #625B71;
  --md-sys-color-secondary-container: #E8DEF8;
  --md-sys-color-on-secondary-container: #1D192B;
  --md-sys-color-surface: #1C1B1F;
  --md-sys-color-surface-container: #25232A;
  --md-sys-color-on-surface: #E6E1E5;
  --md-sys-color-outline: #79747E;
  --md-sys-color-surface-variant: #49454F;
}
* { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }
body { margin: 0; padding: 0; background: var(--md-sys-color-surface); color: var(--md-sys-color-on-surface); font-family: 'Roboto', sans-serif; height: 100vh; display: flex; flex-direction: column; overflow: hidden; }
header { height: 64px; display: flex; align-items: center; padding: 0 16px; background: var(--md-sys-color-surface); font: 400 22px/28px 'Roboto', sans-serif; justify-content: space-between; }
.icon-btn { width: 40px; height: 40px; border-radius: 50%; border: none; background: transparent; color: var(--md-sys-color-on-surface); display: flex; align-items: center; justify-content: center; cursor: pointer; position: relative; overflow: hidden; }
.icon-btn svg { width: 24px; height: 24px; fill: currentColor; }
#game-container { flex: 1; position: relative; background: #000; margin: 0 16px 16px 16px; border-radius: 16px; overflow: hidden; touch-action: none; }
canvas { width: 100%; height: 100%; image-rendering: pixelated; display: block; }
.controls-area { background: var(--md-sys-color-surface-container); padding: 12px 16px 24px 16px; border-radius: 24px 24px 0 0; display: flex; flex-direction: column; gap: 12px; }
.chip-scroll { display: flex; overflow-x: auto; gap: 8px; padding-bottom: 4px; scrollbar-width: none; }
.chip-scroll::-webkit-scrollbar { display: none; }
.chip { height: 32px; padding: 0 16px; border-radius: 8px; border: 1px solid var(--md-sys-color-outline); background: transparent; color: var(--md-sys-color-on-surface); font: 500 14px/20px 'Roboto', sans-serif; display: flex; align-items: center; white-space: nowrap; cursor: pointer; transition: all .2s; }
.chip.active { background: var(--md-sys-color-secondary-container); color: var(--md-sys-color-on-secondary-container); border-color: transparent; }
.chip.active::before { content: "✓"; margin-right: 6px; font-weight: bold; }
#more-sheet { position: fixed; bottom: -100%; left: 0; right: 0; background: var(--md-sys-color-surface-container); border-radius: 28px 28px 0 0; padding: 24px; transition: bottom .3s; z-index: 100; max-height: 70vh; overflow-y: auto; }
#more-sheet.open { bottom: 0; }
.sheet-handle { width: 32px; height: 4px; background: var(--md-sys-color-outline); opacity: .4; border-radius: 2px; margin: -10px auto 20px auto; }
.grid-elements { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 12px; }
.element-card { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 16px; background: var(--md-sys-color-surface); border-radius: 12px; gap: 8px; cursor: pointer; }
.element-color-dot { width: 24px; height: 24px; border-radius: 50%; border: 1px solid rgba(0,0,0,.1); }
.backdrop { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,.4); z-index: 90; opacity: 0; pointer-events: none; transition: opacity .3s; }
.backdrop.open { opacity: 1; pointer-events: auto; }
.brush-size-slider { width: 100%; height: 4px; background: var(--md-sys-color-surface-variant); border-radius: 2px; appearance: none; outline: none; }
.brush-size-slider::-webkit-slider-thumb { appearance: none; width: 20px; height: 20px; border-radius: 50%; background: var(--md-sys-color-primary); cursor: pointer; }
</style>
</head>
<body>

<header>
    <div style="display:flex; align-items:center; gap:12px;"><span>沙箱模拟器</span></div>
    <button class="icon-btn" onclick="clearCanvas()" title="清空">
        <svg viewBox="0 0 24 24"><path d="M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z"/></svg>
    </button>
</header>

<div id="game-container"><canvas id="sandbox"></canvas></div>

<div class="controls-area">
    <div style="display:flex; align-items:center; gap:12px; margin-bottom:8px;">
        <span style="font-size:12px; opacity:.7">笔刷大小</span>
        <input type="range" class="brush-size-slider" min="1" max="10" value="3" id="brushSize">
    </div>
    <div class="chip-scroll" id="quick-bar"></div>
    <button class="icon-btn" style="width:100%; border-radius:12px; height:48px; background:var(--md-sys-color-primary); color:var(--md-sys-color-on-primary); margin-top:8px;" onclick="toggleSheet(true)">更多元素</button>
</div>

<div class="backdrop" id="backdrop" onclick="toggleSheet(false)"></div>
<div id="more-sheet">
    <div class="sheet-handle"></div>
    <h3 style="margin:0 0 16px 0; font-size:20px;">所有元素</h3>
    <div class="grid-elements" id="all-elements-grid"></div>
</div>

<script>
const CANVAS_SCALE = 4;
const TYPES = { EMPTY:0, SOLID:1, POWDER:2, LIQUID:3, GAS:4, ACID:5, DUST:6 };
const ELEMENTS = {
    AIR:   { id:0, name:'空气', color:[0,0,0,0], type:TYPES.EMPTY },
    SAND:  { id:1, name:'沙子', color:[226, 197, 139, 255], type:TYPES.POWDER, variance:20 },
    WATER: { id:2, name:'水', color:[79, 151, 232, 255], type:TYPES.LIQUID, variance:10 },
    STONE: { id:3, name:'石头', color:[119, 119, 119, 255], type:TYPES.SOLID },
    WOOD:  { id:4, name:'木头', color:[139, 69, 19, 255], type:TYPES.SOLID, flammable:true },
    FIRE:  { id:5, name:'火焰', color:[255, 69, 0, 255], type:TYPES.GAS, variance:50, life:50 },
    SMOKE: { id:6, name:'烟雾', color:[200, 200, 200, 150], type:TYPES.GAS, life:200 },
    ACID:  { id:7, name:'酸液', color:[124, 252, 0, 200], type:TYPES.LIQUID, acidity:true },
    PLANT: { id:8, name:'植物', color:[34, 139, 34, 255], type:TYPES.SOLID, flammable:true },
    OIL:   { id:9, name:'石油', color:[30, 30, 30, 255], type:TYPES.LIQUID, flammable:true, variance:10 },
    SEED:  { id:10, name:'种子', color:[139, 90, 43, 255], type:TYPES.POWDER, flammable:true, growable:true },
    DUST:  { id:11, name:'火药', color:[180, 150, 120, 255], type:TYPES.POWDER, explosive:true, variance:15 },
    ERASER:{ id:99, name:'橡皮擦', color:[255,255,255,50], type:TYPES.SOLID, isEraser:true }
};
let currentElement = ELEMENTS.SAND;
let brushSize = 3;
const canvas = document.getElementById('sandbox');
const ctx = canvas.getContext('2d', { alpha:false });
let width, height, grid, imageData, animationId;

function initGame() {
    const container = document.getElementById('game-container');
    width = Math.floor(container.clientWidth / CANVAS_SCALE);
    height = Math.floor(container.clientHeight / CANVAS_SCALE);
    canvas.width = width; canvas.height = height;
    grid = new Array(width * height).fill(0);
    imageData = ctx.createImageData(width, height);
    for(let i=0; i<imageData.data.length; i+=4) { imageData.data[i]=0; imageData.data[i+1]=0; imageData.data[i+2]=0; imageData.data[i+3]=255; }
    loop();
}
const idx = (x, y) => x + y * width;
const inBounds = (x, y) => x>=0 && x<width && y>=0 && y<height;

// 爆炸抛射粒子（临时火星）
const sparks = [];
class Spark {
    constructor(x,y,vx,vy) {
        this.x=x; this.y=y; this.vx=vx; this.vy=vy;
        this.life=20; // 落地前寿命
    }
    update() {
        this.x+=this.vx; this.y+=this.vy;
        this.vy+=0.2; // 重力
        this.life--;
        if(this.y>=height-1 || this.life<=0) {
            // 落地转火焰
            const ix=Math.floor(this.x), iy=Math.floor(this.y);
            if(inBounds(ix,iy) && grid[idx(ix,iy)]===0) grid[idx(ix,iy)]=ELEMENTS.FIRE.id;
            return true;
        }
        return false;
    }
}

function update() {
    // 主循环：物理更新
    for(let y=height-1; y>=0; y--) {
        const startLeft = Math.random() > 0.5;
        const xStart = startLeft ? 0 : width-1;
        const xEnd = startLeft ? width : -1;
        const xStep = startLeft ? 1 : -1;
        for(let x=xStart; x!==xEnd; x+=xStep) {
            const i = idx(x, y);
            const id = grid[i];
            if(id===0) continue;
            const elem = Object.values(ELEMENTS).find(e=>e.id===id);
            if(!elem) continue;

            // 火药爆炸
            if(elem.explosive) {
                const aroundFire = [[0,1],[0,-1],[1,0],[-1,0]].some(([dx,dy])=>{
                    const ni = idx(x+dx,y+dy);
                    return inBounds(x+dx,y+dy) && grid[ni]===ELEMENTS.FIRE.id;
                });
                if(aroundFire) {
                    grid[i]=0; // 火药消失
                    // 炸飞四周 + 生成火焰
                    for(let dy2=-2; dy2<=2; dy2++) {
                        for(let dx2=-2; dx2<=2; dx2++) {
                            if(dx2*dx2+dy2*dy2>4) continue;
                            const tx=x+dx2, ty=y+dy2;
                            if(!inBounds(tx,ty)) continue;
                            const ti=idx(tx,ty);
                            const target=grid[ti];
                            // 石头被炸成沙子
                            if(target===ELEMENTS.STONE.id) {
                                grid[ti]=ELEMENTS.SAND.id;
                                continue;
                            }
                            if(target===0 || Object.values(ELEMENTS).find(e=>e.id===target)?.type!==TYPES.SOLID) {
                                // 炸飞
                                const vx=(dx2+Math.random()*0.4-0.2)*0.8;
                                const vy=(dy2+Math.random()*0.4-0.2)*0.8-1;
                                sparks.push(new Spark(tx,ty,vx,vy));
                                // 空位留火
                                if(grid[ti]===0) grid[ti]=ELEMENTS.FIRE.id;
                            }
                        }
                    }
                    continue;
                }
            }

            // 火焰生命 & 点燃可燃物
            if(elem.id===ELEMENTS.FIRE.id) {
                if(Math.random()<0.12) { grid[i]=ELEMENTS.SMOKE.id; continue; }
                const around = [[0,1],[0,-1],[1,0],[-1,0]];
                for(let [dx,dy] of around) {
                    const ni = idx(x+dx, y+dy);
                    if(!inBounds(x+dx,y+dy)) continue;
                    const neighbor = Object.values(ELEMENTS).find(e=>e.id===grid[ni]);
                    if(neighbor && neighbor.flammable && Math.random()<0.25) {
                        grid[ni] = ELEMENTS.FIRE.id;
                    }
                }
                updateGas(x,y,i,elem.id); continue;
            }
            // 烟雾缓慢消失 + 随机漂移（上升速度再慢一点）
            if(elem.id===ELEMENTS.SMOKE.id) {
                if(Math.random()<0.003) { grid[i]=0; continue; }
                // 50%概率才上升
                if(Math.random()<0.5) updateGas(x,y,i,elem.id);
                // 横向漂移
                if(Math.random()<0.4) { const dir=Math.random()>0.5?1:-1; const si=idx(x+dir,y); if(inBounds(x+dir,y)&&grid[si]===0) swap(i,si); }
                continue;
            }
            // 酸液
            if(elem.acidity) {
                const around = [[0,1],[0,-1],[1,0],[-1,0]];
                for(let [dx,dy] of around) {
                    const ni = idx(x+dx,y+dy);
                    if(inBounds(x+dx,y+dy) && grid[ni] && grid[ni]!==elem.id && Math.random()<0.05) { grid[ni]=0; grid[i]=0; break; }
                }
                updateLiquid(x,y,i,elem.id); continue;
            }
            // 物理运动
            if(elem.type===TYPES.POWDER) updatePowder(x,y,i);
            else if(elem.type===TYPES.LIQUID) updateLiquid(x,y,i,elem.id);
            else if(elem.type===TYPES.GAS) updateGas(x,y,i,elem.id);
        }
    }
    // 更新火星
    for(let i=sparks.length-1; i>=0; i--) {
        if(sparks[i].update()) sparks.splice(i,1);
    }
    draw(); animationId = requestAnimationFrame(update);
}

function updatePowder(x,y,i) {
    const below = idx(x,y+1);
    if(y+1<height && (grid[below]===0 || isLiquid(grid[below]))) { swap(i,below); return; }
    const side = Math.random()>0.5?1:-1;
    const diag = idx(x+side,y+1);
    if(inBounds(x+side,y+1) && (grid[diag]===0 || isLiquid(grid[diag]))) swap(i,diag);
}
function updateLiquid(x,y,i,typeId) {
    const below = idx(x,y+1);
    if(y+1<height && grid[below]===0) { swap(i,below); return; }
    const dir = Math.random()>0.5?1:-1;
    const sideA = idx(x+dir,y);
    const sideB = idx(x-dir,y);
    if(inBounds(x+dir,y) && grid[sideA]===0) swap(i,sideA);
    else if(inBounds(x-dir,y) && grid[sideB]===0) swap(i,sideB);
}
function updateGas(x,y,i,typeId) {
    const above = idx(x,y-1);
    if(y-1>=0 && (grid[above]===0 || isLiquid(grid[above]) || isWaterLike(grid[above]))) { swap(i,above); }
    else {
        const dir = Math.random()>0.5?1:-1;
        const aboveSide = idx(x+dir,y-1);
        if(inBounds(x+dir,y-1) && (grid[aboveSide]===0 || isLiquid(grid[aboveSide]) || isWaterLike(grid[aboveSide]))) swap(i,aboveSide);
    }
}
function isLiquid(id) {
    const e = Object.values(ELEMENTS).find(el=>el.id===id);
    return e && e.type===TYPES.LIQUID;
}
function isWaterLike(id) {
    return id===ELEMENTS.WATER.id || id===ELEMENTS.OIL.id || id===ELEMENTS.ACID.id || id===ELEMENTS.SEED.id;
}
function swap(i,j) { const t=grid[i]; grid[i]=grid[j]; grid[j]=t; }
function draw() {
    const data = imageData.data;
    for(let i=0; i<grid.length; i++) {
        const id = grid[i];
        const p=i*4;
        if(id===0) { data[p]=0; data[p+1]=0; data[p+2]=0; data[p+3]=255; continue; }
        const el = Object.values(ELEMENTS).find(e=>e.id===id);
        if(el) {
            const v = el.variance ? (Math.random()*el.variance-el.variance/2) : 0;
            data[p] = clamp(el.color[0]+v);
            data[p+1] = clamp(el.color[1]+v);
            data[p+2] = clamp(el.color[2]+v);
            data[p+3] = el.color[3]!==undefined ? el.color[3] : 255;
        }
    }
    // 画火星
    for(const s of sparks) {
        const sx=Math.floor(s.x), sy=Math.floor(s.y);
        if(inBounds(sx,sy)) {
            const i=idx(sx,sy);
            const p=i*4;
            data[p]=255; data[p+1]=150; data[p+2]=0; data[p+3]=255;
        }
    }
    ctx.putImageData(imageData,0,0);
}
const clamp=v=>Math.max(0,Math.min(255,v));
function loop() { update(); }

function clearCanvas() { grid.fill(0); sparks.length=0; }

let isDrawing = false;
function getGridPos(evt) {
    const rect = canvas.getBoundingClientRect();
    const [cx,cy] = evt.touches&&evt.touches.length ? [evt.touches[0].clientX,evt.touches[0].clientY] : [evt.clientX,evt.clientY];
    return { x:Math.floor((cx-rect.left)/rect.width*width), y:Math.floor((cy-rect.top)/rect.height*height) };
}
function paint(evt) {
    if(!isDrawing) return;
    const {x,y} = getGridPos(evt);
    const r = parseInt(document.getElementById('brushSize').value);
    for(let dy=-r; dy<=r; dy++) for(let dx=-r; dx<=r; dx++) if(dx*dx+dy*dy<=r*r) {
        const px=x+dx, py=y+dy;
        if(!inBounds(px,py)) continue;
        const i=idx(px,py);
        if(currentElement.isEraser) grid[i]=0;
        else if(grid[i]===0||currentElement.type===TYPES.SOLID) { if(Math.random()>0.1) grid[i]=currentElement.id; }
    }
}
canvas.addEventListener('mousedown',e=>{isDrawing=true; paint(e);});
window.addEventListener('mouseup',()=>isDrawing=false);
canvas.addEventListener('mousemove',paint);
canvas.addEventListener('touchstart',e=>{isDrawing=true; paint(e); e.preventDefault();},{passive:false});
window.addEventListener('touchend',()=>isDrawing=false);
canvas.addEventListener('touchmove',e=>{paint(e); e.preventDefault();},{passive:false});

function selectElement(key) { currentElement=ELEMENTS[key]; updateUI(); toggleSheet(false); }
function updateUI() { document.querySelectorAll('.chip').forEach(chip=>{ chip.classList.toggle('active', chip.dataset.key===getKeyByValue(currentElement)); }); }
function getKeyByValue(obj) { return Object.keys(ELEMENTS).find(k=>ELEMENTS[k]===obj); }
function toggleSheet(open) { document.getElementById('more-sheet').classList.toggle('open',open); document.getElementById('backdrop').classList.toggle('open',open); }

function initUI() {
    const quickBar=document.getElementById('quick-bar');
    const allGrid=document.getElementById('all-elements-grid');
    const quickKeys=['SAND','WATER','STONE','DUST','ERASER'];
    quickKeys.forEach(key=>{
        const el=ELEMENTS[key];
        const btn=document.createElement('button'); btn.className='chip'; btn.dataset.key=key; btn.innerText=el.name;
        btn.onclick=e=>{selectElement(key);}; if(key==='SAND') btn.classList.add('active'); quickBar.appendChild(btn);
    });
    Object.keys(ELEMENTS).forEach(key=>{
        if(key==='AIR') return; const el=ELEMENTS[key];
        const card=document.createElement('div'); card.className='element-card'; card.onclick=e=>{selectElement(key);};
        const dot=document.createElement('div'); dot.className='element-color-dot';
        if(el.isEraser) { dot.style.background='#fff'; dot.style.border='2px solid #ccc'; dot.style.backgroundImage='linear-gradient(45deg, #ccc 25%, transparent 25%, transparent 75%, #ccc 75%, #ccc), linear-gradient(45deg, #ccc 25%, transparent 25%, transparent 75%, #ccc 75%, #ccc)'; dot.style.backgroundSize='10px 10px'; dot.style.backgroundPosition='0 0, 5px 5px'; }
        else dot.style.backgroundColor=`rgba(${el.color[0]},${el.color[1]},${el.color[2]},1)`;
        const name=document.createElement('span'); name.style.fontSize='14px'; name.innerText=el.name;
        card.appendChild(dot); card.appendChild(name); allGrid.appendChild(card);
    });
}

window.addEventListener('load',()=>{ initGame(); initUI(); });
</script>
</body>
</html>
