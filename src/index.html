<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>SandSpiel - PowderGame v1.4.0</title>
<style>
:root {
    --md-sys-color-primary: #6750A4;
    --md-sys-color-on-primary: #FFFFFF;
    --md-sys-color-primary-container: #EADDFF;
    --md-sys-color-on-primary-container: #21005D;
    --md-sys-color-secondary: #625B71;
    --md-sys-color-secondary-container: #E8DEF8;
    --md-sys-color-on-secondary-container: #1D192B;
    --md-sys-color-surface: #1C1B1F;
    --md-sys-color-surface-container: #25232A;
    --md-sys-color-on-surface: #E6E1E5;
    --md-sys-color-outline: #79747E;
    --md-sys-color-surface-variant: #49454F;
}

* {
    box-sizing: border-box;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
}

body {
    margin: 0;
    padding: 0;
    background: var(--md-sys-color-surface);
    color: var(--md-sys-color-on-surface);
    font-family: 'Roboto', sans-serif;
    height: 100vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

header {
    height: 64px;
    display: flex;
    align-items: center;
    padding: 0 16px;
    background: var(--md-sys-color-surface);
    font: 400 22px/28px 'Roboto', sans-serif;
    justify-content: space-between;
}

.icon-btn {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    border: none;
    background: transparent;
    color: var(--md-sys-color-on-surface);
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    position: relative;
    overflow: hidden;
}

.icon-btn svg {
    width: 24px;
    height: 24px;
    fill: currentColor;
}

#game-container {
    flex: 1;
    position: relative;
    background: #000;
    margin: 0 16px 16px 16px;
    border-radius: 16px;
    overflow: hidden;
    touch-action: none;
}

canvas {
    width: 100%;
    height: 100%;
    image-rendering: pixelated;
    display: block;
    transform-origin: 0 0;
    transition: transform 0.1s;
}

.controls-area {
    background: var(--md-sys-color-surface-container);
    padding: 12px 16px 24px 16px;
    border-radius: 24px 24px 0 0;
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.chip-scroll {
    display: flex;
    overflow-x: auto;
    gap: 8px;
    padding-bottom: 4px;
    scrollbar-width: none;
}

.chip-scroll::-webkit-scrollbar {
    display: none;
}

.chip {
    height: 32px;
    padding: 0 16px;
    border-radius: 8px;
    border: 1px solid var(--md-sys-color-outline);
    background: transparent;
    color: var(--md-sys-color-on-surface);
    font: 500 14px/20px 'Roboto', sans-serif;
    display: flex;
    align-items: center;
    white-space: nowrap;
    cursor: pointer;
    transition: all .2s;
}

.chip.active {
    background: var(--md-sys-color-secondary-container);
    color: var(--md-sys-color-on-secondary-container);
    border-color: transparent;
}

.chip.active::before {
    content: "✓";
    margin-right: 6px;
    font-weight: bold;
}

#more-sheet {
    position: fixed;
    bottom: -100%;
    left: 0;
    right: 0;
    background: var(--md-sys-color-surface-container);
    border-radius: 28px 28px 0 0;
    padding: 24px;
    transition: bottom .3s;
    z-index: 100;
    max-height: 70vh;
    overflow-y: auto;
}

#more-sheet.open {
    bottom: 0;
}

.sheet-handle {
    width: 32px;
    height: 4px;
    background: var(--md-sys-color-outline);
    opacity: .4;
    border-radius: 2px;
    margin: -10px auto 20px auto;
}

.grid-elements {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
    gap: 12px;
}

.element-card {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 16px;
    background: var(--md-sys-color-surface);
    border-radius: 12px;
    gap: 8px;
    cursor: pointer;
}

.element-color-dot {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    border: 1px solid rgba(0,0,0,.1);
}

.backdrop {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,.4);
    z-index: 90;
    opacity: 0;
    pointer-events: none;
    transition: opacity .3s;
}

.backdrop.open {
    opacity: 1;
    pointer-events: auto;
}

.brush-size-slider {
    -webkit-appearance: none;
    appearance: none;
    width: 100%;
    height: 4px;
    background: var(--md-sys-color-surface-variant);
    border-radius: 2px;
    outline: none;
}

.brush-size-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: var(--md-sys-color-primary);
    border: 2px solid var(--md-sys-color-on-primary);
    cursor: grab;
    box-shadow: 0 0 4px rgba(0,0,0,.35);
    transition: transform .2s;
}

.brush-size-slider:active::-webkit-slider-thumb {
    cursor: grabbing;
    transform: scale(1.15);
}

.brush-size-slider::-moz-range-thumb {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: var(--md-sys-color-primary);
    border: 2px solid var(--md-sys-color-on-primary);
    cursor: grab;
    box-shadow: 0 0 4px rgba(0,0,0,.35);
    transition: transform .2s;
}

.brush-size-slider:active::-moz-range-thumb {
    cursor: grabbing;
    transform: scale(1.15);
}

#fps-display {
    position: absolute;
    top: 5px;
    right: 5px;
    color: white;
    font-family: 'Roboto', sans-serif;
    font-size: 12px;
    font-weight: 400;
    background: rgba(0,0,0,0.6);
    padding: 2px 6px;
    border-radius: 3px;
    z-index: 10;
    pointer-events: none;
}

.control-buttons {
    display: flex;
    gap: 8px;
    margin-left: auto;
}

.paused-indicator {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
    font-size: 24px;
    font-weight: bold;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
    display: none;
    z-index: 20;
}

.temp-display {
    position: absolute;
    top: 30px;
    right: 5px;
    color: white;
    font-family: 'Roboto', sans-serif;
    font-size: 12px;
    font-weight: 400;
    background: rgba(0,0,0,0.6);
    padding: 2px 6px;
    border-radius: 3px;
    z-index: 10;
    pointer-events: none;
}

.temp-settings {
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin-top: 8px;
    padding: 8px;
    background: rgba(0,0,0,0.1);
    border-radius: 8px;
}

.temp-slider-container {
    display: flex;
    align-items: center;
    gap: 8px;
}

.temp-label {
    font-size: 11px;
    opacity: 0.7;
    min-width: 80px;
}

.temp-value {
    font-size: 11px;
    min-width: 30px;
    text-align: right;
}

.temp-toggle {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 12px;
}

#grid-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-image: linear-gradient(rgba(255,255,255,0.1) 1px, transparent 1px),
                      linear-gradient(90deg, rgba(255,255,255,0.1) 1px, transparent 1px);
    background-size: 12px 12px;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.3s;
}

#grid-overlay.active {
    opacity: 1;
}

#element-counter {
    font-size: 12px;
    opacity: 0.7;
    text-align: center;
    margin-top: 8px;
}

.element-dot {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    margin-bottom: 4px;
}

#settings-overlay, #about-overlay, #source-overlay, #cheat-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s;
}

#settings-overlay.show, #about-overlay.show, #source-overlay.show, #cheat-overlay.show {
    opacity: 1;
    pointer-events: auto;
}

.settings-panel {
    background: var(--md-sys-color-surface-container);
    border-radius: 24px;
    padding: 24px;
    width: 90%;
    max-width: 400px;
    max-height: 80vh;
    overflow-y: auto;
}

.settings-title {
    margin: 0 0 20px 0;
    font-size: 20px;
    text-align: center;
}

.setting-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 0;
    border-bottom: 1px solid var(--md-sys-color-outline);
}

.setting-item:last-child {
    border-bottom: none;
}

.setting-label {
    font-size: 14px;
}

.source-code-view {
    width: 90%;
    height: 70vh;
    max-width: 600px;
    background: #1e1e1e;
    color: #d4d4d4;
    font-family: 'Courier New', monospace;
    padding: 20px;
    border-radius: 8px;
    border: none;
    resize: none;
    font-size: 12px;
    line-height: 1.4;
}

.copy-button {
    background: var(--md-sys-color-primary);
    color: var(--md-sys-color-on-primary);
    border: none;
    border-radius: 8px;
    padding: 12px 24px;
    font-size: 14px;
    cursor: pointer;
    margin-top: 16px;
    display: flex;
    align-items: center;
    gap: 8px;
}

.advanced-controls {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 8px;
}

.advanced-btn {
    flex: 1;
    min-width: 80px;
    height: 36px;
    border-radius: 8px;
    border: 1px solid var(--md-sys-color-outline);
    background: transparent;
    color: var(--md-sys-color-on-surface);
    font-size: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 4px;
    cursor: pointer;
}

#fps-counter {
    position: absolute;
    top: 5px;
    left: 5px;
    color: white;
    font-size: 12px;
    background: rgba(0,0,0,0.6);
    padding: 2px 6px;
    border-radius: 3px;
    display: none;
}

.toggle-switch {
    position: relative;
    display: inline-block;
    width: 50px;
    height: 24px;
}

.toggle-switch input {
    opacity: 0;
    width: 0;
    height: 0;
}

.toggle-slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: var(--md-sys-color-outline);
    transition: .4s;
    border-radius: 24px;
}

.toggle-slider:before {
    position: absolute;
    content: "";
    height: 16px;
    width: 16px;
    left: 4px;
    bottom: 4px;
    background-color: white;
    transition: .4s;
    border-radius: 50%;
}

input:checked + .toggle-slider {
    background-color: var(--md-sys-color-primary);
}

input:checked + .toggle-slider:before {
    transform: translateX(26px);
}

@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
}

.material-symbols-outlined {
    font-family: 'Material Symbols Outlined';
    font-weight: normal;
    font-style: normal;
    font-size: 24px;
    line-height: 1;
    letter-spacing: normal;
    text-transform: none;
    display: inline-block;
    white-space: nowrap;
    word-wrap: normal;
    direction: ltr;
    -webkit-font-feature-settings: 'liga';
    -webkit-font-smoothing: antialiased;
}

.advanced-btn.active {
    background: var(--md-sys-color-primary);
    color: var(--md-sys-color-on-primary);
}

/* 作弊面板样式 */
.cheat-panel {
    background: var(--md-sys-color-surface-container);
    border-radius: 24px;
    padding: 24px;
    width: 95%;
    max-width: 700px;
    max-height: 90vh;
    overflow-y: auto;
}

.cheat-title {
    margin: 0 0 16px 0;
    font-size: 20px;
    text-align: center;
    color: var(--md-sys-color-primary);
}

.cheat-element-selector {
    margin-bottom: 16px;
}

.cheat-element-selector select {
    width: 100%;
    padding: 12px;
    border-radius: 12px;
    border: 1px solid var(--md-sys-color-outline);
    background: var(--md-sys-color-surface);
    color: var(--md-sys-color-on-surface);
    font-size: 14px;
    margin-top: 8px;
}

.cheat-property-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
    margin-bottom: 16px;
}

.cheat-property-item {
    display: flex;
    flex-direction: column;
    gap: 4px;
}

.cheat-property-item.full-width {
    grid-column: 1 / -1;
}

.cheat-property-item label {
    font-size: 12px;
    opacity: 0.8;
    color: var(--md-sys-color-on-surface);
}

.cheat-property-item input[type="text"],
.cheat-property-item input[type="number"],
.cheat-property-item select {
    padding: 8px 12px;
    border-radius: 8px;
    border: 1px solid var(--md-sys-color-outline);
    background: var(--md-sys-color-surface);
    color: var(--md-sys-color-on-surface);
    font-size: 14px;
}

.cheat-property-item input[type="checkbox"] {
    width: 20px;
    height: 20px;
    accent-color: var(--md-sys-color-primary);
}

.cheat-color-picker {
    display: flex;
    gap: 8px;
    align-items: center;
}

.cheat-color-picker input[type="color"] {
    width: 50px;
    height: 36px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
}

.cheat-color-picker input[type="text"] {
    flex: 1;
}

.cheat-buttons {
    display: flex;
    gap: 12px;
    margin-top: 20px;
}

.cheat-btn {
    flex: 1;
    padding: 12px;
    border-radius: 12px;
    border: none;
    font-size: 14px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
}

.cheat-btn-primary {
    background: var(--md-sys-color-primary);
    color: var(--md-sys-color-on-primary);
}

.cheat-btn-secondary {
    background: var(--md-sys-color-surface-variant);
    color: var(--md-sys-color-on-surface);
}

.cheat-btn-danger {
    background: #ff4444;
    color: white;
}

.cheat-section-title {
    font-size: 14px;
    font-weight: bold;
    margin: 16px 0 8px 0;
    padding-bottom: 4px;
    border-bottom: 1px solid var(--md-sys-color-outline);
    color: var(--md-sys-color-primary);
}

.cheat-new-element {
    margin-top: 20px;
    padding-top: 16px;
    border-top: 2px dashed var(--md-sys-color-outline);
}

.cheat-management {
    margin-top: 20px;
    padding-top: 16px;
    border-top: 2px dashed var(--md-sys-color-outline);
}

.element-list {
    max-height: 200px;
    overflow-y: auto;
    border: 1px solid var(--md-sys-color-outline);
    border-radius: 8px;
    padding: 8px;
    margin-top: 8px;
}

.element-list-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px;
    border-bottom: 1px solid var(--md-sys-color-outline);
}

.element-list-item:last-child {
    border-bottom: none;
}

.element-list-item button {
    background: #ff4444;
    color: white;
    border: none;
    border-radius: 4px;
    padding: 4px 12px;
    cursor: pointer;
    font-size: 12px;
}

.save-load-section {
    margin-top: 20px;
    padding-top: 16px;
    border-top: 2px dashed var(--md-sys-color-outline);
    display: flex;
    gap: 12px;
}

.save-load-section button {
    flex: 1;
    padding: 12px;
    border-radius: 12px;
    border: 1px solid var(--md-sys-color-outline);
    background: var(--md-sys-color-surface);
    color: var(--md-sys-color-on-surface);
    cursor: pointer;
    font-size: 14px;
}

.save-load-section button:first-child {
    background: var(--md-sys-color-primary);
    color: var(--md-sys-color-on-primary);
    border: none;
}

.oxidizable {
    animation: oxidize 3s infinite alternate;
}

@keyframes oxidize {
    0% { box-shadow: 0 0 4px rgba(139, 69, 19, 0.5); }
    100% { box-shadow: 0 0 8px rgba(139, 69, 19, 0.8); }
}

.toast {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: var(--md-sys-color-primary);
    color: var(--md-sys-color-on-primary);
    padding: 12px 24px;
    border-radius: 12px;
    z-index: 10000;
    opacity: 0;
    transition: opacity 0.3s;
}

.toast.show {
    opacity: 1;
}
</style>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
</head>

<body>
<header>
    <div style="display:flex; align-items:center; gap:12px;">
        <span>SandSpiel v1.4.0</span>
    </div>
    <div class="control-buttons">
        <button class="icon-btn" onclick="togglePause()" title="暂停/继续" id="pause-btn">
            <svg viewBox="0 0 24 24" id="pauseIcon">
                <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
            </svg>
        </button>
        <button class="icon-btn" onclick="clearCanvas()" title="清空">
            <svg viewBox="0 0 24 24">
                <path d="M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z"/>
            </svg>
        </button>
        <button class="icon-btn" onclick="openSettings()" title="设置">
            <span class="material-symbols-outlined"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="48" height="48" fill="white">
  <!-- 齿轮主体：8个齿牙 -->
  <path d="M12 15.5A3.5 3.5 0 1 0 12 8.5a3.5 3.5 0 0 0 0 7z M19.43 12.98c.04-.32.07-.66.07-1s-.03-.68-.07-1l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.5.42l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.66-.07 1s.03.68.07 1l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1.01c.52.4 1.08.73 1.69.98l.38 2.65c.04.24.25.42.5.42h4c.25 0 .46-.18.5-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1.01c.22.08.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65z"/>
</svg>
</span>
        </button>
    </div>
</header>

<div id="game-container">
    <canvas id="sandbox"></canvas>
    <div id="grid-overlay"></div>
    <div id="fps-display">0 FPS</div>
    <div id="temp-display">温度系统: 开启</div>
    <div id="fps-counter">0 FPS</div>
    <div class="paused-indicator" id="pausedIndicator">暂停中</div>
</div>

<div class="controls-area">
    <div style="display:flex; align-items:center; gap:12px; margin-bottom:8px;">
        <span style="font-size:12px; opacity:.7">笔刷大小</span>
        <input type="range" class="brush-size-slider" min="1" max="20" value="5" id="brushSize">
        <button class="icon-btn" onclick="toggleBrushShape()" title="切换笔刷形状" id="shape-toggle" style="width:32px;height:32px;">
            <span class="material-symbols-outlined" style="font-size:18px;">○</span>
        </button>
    </div>

    <div class="temp-settings">
        <div class="temp-toggle">
            <input type="checkbox" id="tempToggle" checked onchange="toggleTemperatureSystem()">
            <label for="tempToggle">温度系统</label>
        </div>

        <div class="temp-slider-container">
            <span class="temp-label">热传导</span>
            <input type="range" min="1" max="10" value="5" class="brush-size-slider" id="heatTransferSpeed">
            <span class="temp-value" id="heatTransferValue">5</span>
        </div>

        <div class="temp-slider-container">
            <span class="temp-label">环境温度</span>
            <input type="range" min="-273" max="2000" value="20" class="brush-size-slider" id="ambientTemp">
            <span class="temp-value" id="ambientTempValue">20°C</span>
        </div>
    </div>

    <div class="advanced-controls">
        <button class="advanced-btn" onclick="toggleGravity()" title="零重力" id="gravity-btn">
            <span class="material-symbols-outlined" style="font-size:16px;"></span>
            <span>零重力</span>
        </button>
        <button class="advanced-btn" onclick="toggleGrid()" title="显示网格" id="grid-btn">
            <span class="material-symbols-outlined" style="font-size:16px;"></span>
            <span>网格</span>
        </button>
    </div>

    <div class="chip-scroll" id="quick-bar"></div>
    <button class="icon-btn" style="width:100%; border-radius:12px; height:48px; background:var(--md-sys-color-primary); color:var(--md-sys-color-on-primary); margin-top:8px;" onclick="toggleSheet(true)">
        <span class="material-symbols-outlined" style="margin-right:8px;">+</span>
        更多元素
    </button>
    <div id="element-counter"></div>
</div>

<div class="backdrop" id="backdrop" onclick="closeAllOverlays()"></div>

<div id="more-sheet">
    <div class="sheet-handle"></div>
    <h3 style="margin:0 0 16px 0; font-size:20px;">所有元素</h3>
    <div class="grid-elements" id="all-elements-grid"></div>
</div>

<!-- 设置面板 -->
<div id="settings-overlay" onclick="closeSettings(event)">
    <div class="settings-panel">
        <h3 class="settings-title">设置</h3>
        
        <div class="setting-item">
            <span class="setting-label">分辨率</span>
            <select id="resolution-select" onchange="changeResolution(this.value)">
                <option value="2">高 (2x)</option>
                <option value="3" selected>中 (3x)</option>
                <option value="4">低 (4x)</option>
            </select>
        </div>
        
        <div class="setting-item">
            <span class="setting-label">平滑模式</span>
            <label class="toggle-switch">
                <input type="checkbox" id="smooth-toggle" onchange="toggleSmoothMode()">
                <span class="toggle-slider"></span>
            </label>
        </div>
        
        <button class="copy-button" onclick="openSourceView()" style="width:100%;">
            <span class="material-symbols-outlined">⬔</span>
            <span>查看源代码</span>
        </button>
        
        <button class="copy-button" onclick="openAbout()" style="width:100%; margin-top:12px;">
            <span class="material-symbols-outlined">ⓘ</span>
            <span>关于</span>
        </button>
        
        <button class="copy-button" onclick="openCheatPanel()" style="width:100%; margin-top:12px; background: linear-gradient(135deg, #ff6b6b, #ee5a5a);">
            <span class="material-symbols-outlined">⚡</span>
            <span>元素属性编辑器</span>
        </button>

        <button class="copy-button" onclick="resetToFactoryDefaults()" style="width:100%; margin-top:12px; background: linear-gradient(135deg, #4CAF50, #2E7D32);">
            <span class="material-symbols-outlined">↺</span>
            <span>恢复出厂设置</span>
        </button>
    </div>
</div>

<!-- 源代码查看面板 -->
<div id="source-overlay" onclick="closeSource(event)">
    <div style="text-align:center;">
        <textarea class="source-code-view" id="source-code-view" readonly></textarea>
        <button class="copy-button" onclick="copySource()">
            <span class="material-symbols-outlined">⎘</span>
            <span id="copy-btn-text">复制代码</span>
        </button>
    </div>
</div>

<!-- 关于面板 -->
<div id="about-overlay" onclick="closeAbout(event)">
    <div class="settings-panel">
        <h3 class="settings-title">关于 SandSpiel v1.4.0</h3>
        <p style="text-align:center; font-size:14px; line-height:1.6;">
            这是一个粒子物理化学模拟沙盒游戏<br>
            包含多种不同的元素<br>
            增加了氧化系统、铁锈系统<br>
            完整的元素编辑器<br>
            完全实现的物理属性系统<br><br>
            版本：1.4.0<br>
            更新日期：2026
        </p>
    </div>
</div>

<!-- 作弊面板 - 元素属性编辑器 -->
<div id="cheat-overlay" onclick="closeCheat(event)">
    <div class="cheat-panel" onclick="event.stopPropagation()">
        <h3 class="cheat-title">元素属性编辑器</h3>
        
        <div class="cheat-element-selector">
            <label>选择要编辑的元素:</label>
            <select id="cheat-element-select" onchange="loadElementForEdit()">
                <option value="">-- 选择一个元素 --</option>
            </select>
        </div>
        
        <div id="cheat-properties" style="display:none;">
            <div class="cheat-section-title">基础属性</div>
            <div class="cheat-property-grid">
                <div class="cheat-property-item">
                    <label>元素名称</label>
                    <input type="text" id="cheat-name" placeholder="元素名称">
                </div>
                
                <div class="cheat-property-item">
                    <label>元素类型</label>
                    <select id="cheat-type">
                        <option value="0">EMPTY (空)</option>
                        <option value="1">SOLID (固体)</option>
                        <option value="2">POWDER (粉末)</option>
                        <option value="3">LIQUID (液体)</option>
                        <option value="4">GAS (气体)</option>
                        <option value="5">ACID (酸液)</option>
                        <option value="6">LAVA (岩浆)</option>
                        <option value="7">INDESTRUCTIBLE (不可破坏)</option>
                        <option value="8">CLONE (克隆)</option>
                        <option value="9">LIFE (生命)</option>
                        <option value="10">STEAM (蒸汽)</option>
                        <option value="11">METAL_SOLID (金属固体)</option>
                        <option value="12">METAL_LIQUID (金属液体)</option>
                        <option value="13">EXPLOSIVE (爆炸物)</option>
                        <option value="14">FUSE (引线)</option>
                    </select>
                </div>
                
                <div class="cheat-property-item full-width">
                    <label>颜色 (RGBA)</label>
                    <div class="cheat-color-picker">
                        <input type="color" id="cheat-color-picker" onchange="updateColorFromPicker()">
                        <input type="text" id="cheat-color" placeholder="R,G,B,A" onchange="updateColorFromText()">
                    </div>
                </div>
                
                <div class="cheat-property-item">
                    <label>密度</label>
                    <input type="number" id="cheat-density" step="0.1" placeholder="密度">
                </div>
                
                <div class="cheat-property-item">
                    <label>默认温度 (°C)</label>
                    <input type="number" id="cheat-defaultTemp" step="1" placeholder="默认温度">
                </div>
                
                <div class="cheat-property-item">
                    <label>耐热性 (0-1)</label>
                    <input type="number" id="cheat-heatResistance" step="0.1" min="0" max="1" placeholder="耐热性">
                </div>
                
                <div class="cheat-property-item">
                    <label>颜色变化度</label>
                    <input type="number" id="cheat-variance" step="1" min="0" max="100" placeholder="变化度">
                </div>
            </div>
            
            <div class="cheat-section-title">物理特性</div>
            <div class="cheat-property-grid">
                <div class="cheat-property-item">
                    <label>
                        <input type="checkbox" id="cheat-flammable"> 可燃
                    </label>
                </div>
                
                <div class="cheat-property-item">
                    <label>
                        <input type="checkbox" id="cheat-explosive"> 爆炸物
                    </label>
                </div>
                
                <div class="cheat-property-item">
                    <label>
                        <input type="checkbox" id="cheat-meltable"> 可熔化
                    </label>
                </div>
                
                <div class="cheat-property-item">
                    <label>
                        <input type="checkbox" id="cheat-indestructible"> 不可破坏
                    </label>
                </div>
                
                <div class="cheat-property-item">
                    <label>
                        <input type="checkbox" id="cheat-acidity"> 酸性
                    </label>
                </div>
                
                <div class="cheat-property-item">
                    <label>
                        <input type="checkbox" id="cheat-superAcidic"> 超强酸
                    </label>
                </div>
                
                <div class="cheat-property-item">
                    <label>
                        <input type="checkbox" id="cheat-hot"> 高温
                    </label>
                </div>
                
                <div class="cheat-property-item">
                    <label>
                        <input type="checkbox" id="cheat-transparent"> 透明
                    </label>
                </div>

                <div class="cheat-property-item">
                    <label>
                        <input type="checkbox" id="cheat-oxidizable"> 可氧化
                    </label>
                </div>
            </div>
            
            <div class="cheat-section-title">气体属性</div>
            <div class="cheat-property-grid">
                <div class="cheat-property-item">
                    <label>气体移动速度</label>
                    <select id="cheat-gasSpeed">
                        <option value="0.1">极慢</option>
                        <option value="0.3">慢</option>
                        <option value="0.5" selected>正常</option>
                        <option value="0.8">快</option>
                        <option value="1.0">极快</option>
                    </select>
                </div>
                
                <div class="cheat-property-item">
                    <label>气体移动方式</label>
                    <select id="cheat-gasMovement">
                        <option value="random">随机飘散</option>
                        <option value="up">向上飘散</option>
                        <option value="down">向下沉降</option>
                        <option value="horizontal">水平扩散</option>
                        <option value="chaotic">混乱运动</option>
                    </select>
                </div>
                
                <div class="cheat-property-item">
                    <label>气体扩散率</label>
                    <input type="number" id="cheat-gasSpread" step="0.1" min="0" max="1" placeholder="0-1">
                </div>
                
                <div class="cheat-property-item">
                    <label>气体浮力</label>
                    <input type="number" id="cheat-gasBuoyancy" step="0.1" min="-1" max="1" placeholder="-1到1">
                </div>
            </div>
            
            <div class="cheat-section-title">液体属性</div>
            <div class="cheat-property-grid">
                <div class="cheat-property-item">
                    <label>液体粘度</label>
                    <select id="cheat-viscosity">
                        <option value="0">无粘度（水）</option>
                        <option value="0.3">低粘度（油）</option>
                        <option value="0.6">中粘度（蜂蜜）</option>
                        <option value="0.9">高粘度（沥青）</option>
                    </select>
                </div>
                
                <div class="cheat-property-item">
                    <label>液体流动性</label>
                    <input type="number" id="cheat-flowRate" step="0.1" min="0" max="1" placeholder="0-1">
                </div>
                
                <div class="cheat-property-item">
                    <label>表面张力</label>
                    <input type="number" id="cheat-surfaceTension" step="0.1" min="0" max="1" placeholder="0-1">
                </div>
            </div>
            
            <div class="cheat-section-title">粉末属性</div>
            <div class="cheat-property-grid">
                <div class="cheat-property-item">
                    <label>堆积角度</label>
                    <input type="number" id="cheat-angleOfRepose" step="1" min="0" max="90" placeholder="角度">
                </div>
                
                <div class="cheat-property-item">
                    <label>滚动性</label>
                    <input type="number" id="cheat-rollness" step="0.1" min="0" max="1" placeholder="0-1">
                </div>
            </div>
            
            <div class="cheat-section-title">温度相关</div>
            <div class="cheat-property-grid">
                <div class="cheat-property-item">
                    <label>燃点 (°C)</label>
                    <input type="number" id="cheat-ignitesAt" step="1" placeholder="燃点">
                </div>
                
                <div class="cheat-property-item">
                    <label>熔点 (°C)</label>
                    <input type="number" id="cheat-meltsAt" step="1" placeholder="熔点">
                </div>
                
                <div class="cheat-property-item">
                    <label>沸点 (°C)</label>
                    <input type="number" id="cheat-boilsAt" step="1" placeholder="沸点">
                </div>
                
                <div class="cheat-property-item">
                    <label>凝固点 (°C)</label>
                    <input type="number" id="cheat-freezesAt" step="1" placeholder="凝固点">
                </div>
                
                <div class="cheat-property-item">
                    <label>凝结点 (°C)</label>
                    <input type="number" id="cheat-condensesAt" step="1" placeholder="凝结点">
                </div>
                
                <div class="cheat-property-item">
                    <label>死亡温度 (°C)</label>
                    <input type="number" id="cheat-diesAt" step="1" placeholder="死亡温度">
                </div>
            </div>
            
            <div class="cheat-section-title">转换目标</div>
            <div class="cheat-property-grid">
                <div class="cheat-property-item">
                    <label>燃烧后变成</label>
                    <select id="cheat-burnTo">
                        <option value="">无</option>
                    </select>
                </div>
                
                <div class="cheat-property-item">
                    <label>熔化后变成</label>
                    <select id="cheat-meltTo">
                        <option value="">无</option>
                    </select>
                </div>
                
                <div class="cheat-property-item">
                    <label>凝固后变成</label>
                    <select id="cheat-freezeTo">
                        <option value="">无</option>
                    </select>
                </div>
                
                <div class="cheat-property-item">
                    <label>沸腾后变成</label>
                    <select id="cheat-boilTo">
                        <option value="">无</option>
                    </select>
                </div>
                
                <div class="cheat-property-item">
                    <label>凝结后变成</label>
                    <select id="cheat-condenseTo">
                        <option value="">无</option>
                    </select>
                </div>

                <div class="cheat-property-item">
                    <label>氧化后变成</label>
                    <select id="cheat-oxidizeTo">
                        <option value="">无</option>
                    </select>
                </div>
            </div>
            
            <div class="cheat-section-title">特殊属性</div>
            <div class="cheat-property-grid">
                <div class="cheat-property-item">
                    <label>发热量</label>
                    <input type="number" id="cheat-heatEmission" step="1" placeholder="发热量">
                </div>
                
                <div class="cheat-property-item">
                    <label>生命周期</label>
                    <input type="number" id="cheat-life" step="1" placeholder="生命周期">
                </div>
                
                <div class="cheat-property-item">
                    <label>燃烧时间</label>
                    <input type="number" id="cheat-burnTime" step="1" placeholder="燃烧时间">
                </div>
                
                <div class="cheat-property-item">
                    <label>爆炸威力</label>
                    <input type="number" id="cheat-explosivePower" step="1" placeholder="爆炸威力">
                </div>
                
                <div class="cheat-property-item">
                    <label>酸抗性 (0-1)</label>
                    <input type="number" id="cheat-acidResistance" step="0.1" min="0" max="1" placeholder="酸抗性">
                </div>
                
                <div class="cheat-property-item">
                    <label>导电性 (0-1)</label>
                    <input type="number" id="cheat-conductivity" step="0.1" min="0" max="1" placeholder="导电性">
                </div>
                
                <div class="cheat-property-item">
                    <label>放射性 (0-1)</label>
                    <input type="number" id="cheat-radioactivity" step="0.1" min="0" max="1" placeholder="放射性">
                </div>
                
                <div class="cheat-property-item">
                    <label>磁性 (0-1)</label>
                    <input type="number" id="cheat-magnetism" step="0.1" min="0" max="1" placeholder="磁性">
                </div>

                <div class="cheat-property-item">
                    <label>氧化速率</label>
                    <input type="number" id="cheat-oxidationRate" step="0.01" min="0" max="1" placeholder="0-1">
                </div>
            </div>
            
            <div class="cheat-section-title">引线属性</div>
            <div class="cheat-property-grid">
                <div class="cheat-property-item">
                    <label>燃烧速度</label>
                    <input type="number" id="cheat-burnSpeed" step="1" min="1" max="10" placeholder="燃烧速度">
                </div>
                
                <div class="cheat-property-item">
                    <label>燃烧温度 (°C)</label>
                    <input type="number" id="cheat-burnTemp" step="1" placeholder="燃烧温度">
                </div>
                
                <div class="cheat-property-item">
                    <label>燃烧持续时间</label>
                    <input type="number" id="cheat-burnDuration" step="1" placeholder="燃烧持续时间">
                </div>
            </div>
            
            <div class="cheat-section-title">生命元素属性</div>
            <div class="cheat-property-grid">
                <div class="cheat-property-item">
                    <label>饥饿速率</label>
                    <input type="number" id="cheat-hungerRate" step="0.1" min="0" max="5" placeholder="饥饿速率">
                </div>
                
                <div class="cheat-property-item">
                    <label>繁殖概率</label>
                    <input type="number" id="cheat-breedChance" step="0.01" min="0" max="1" placeholder="繁殖概率">
                </div>
                
                <div class="cheat-property-item">
                    <label>移动间隔 (ms)</label>
                    <input type="number" id="cheat-moveInterval" step="10" min="10" max="1000" placeholder="移动间隔">
                </div>
            </div>
            
            <div class="cheat-section-title">克隆元素属性</div>
            <div class="cheat-property-grid">
                <div class="cheat-property-item">
                    <label>复制间隔 (ms)</label>
                    <input type="number" id="cheat-copyInterval" step="10" min="10" max="1000" placeholder="复制间隔">
                </div>
                
                <div class="cheat-property-item">
                    <label>最大复制次数</label>
                    <input type="number" id="cheat-maxCopyCount" step="1" min="1" max="1000" placeholder="最大复制次数">
                </div>
            </div>
            
            <div class="cheat-buttons">
                <button class="cheat-btn cheat-btn-primary" onclick="applyCheatChanges()">
                    应用修改
                </button>
                <button class="cheat-btn cheat-btn-secondary" onclick="resetElementToDefault()">
                    重置默认
                </button>
            </div>
        </div>
        
        <div class="cheat-new-element">
            <div class="cheat-section-title">创建新元素</div>
            <div class="cheat-property-grid">
                <div class="cheat-property-item">
                    <label>新元素ID (大写英文)</label>
                    <input type="text" id="cheat-new-id" placeholder="如: SUPER_WATER">
                </div>
                <div class="cheat-property-item">
                    <label>基于哪个元素</label>
                    <select id="cheat-base-element">
                        <option value="">-- 选择基础元素 --</option>
                    </select>
                </div>
            </div>
            <button class="cheat-btn cheat-btn-primary" onclick="createNewElement()" style="width:100%; margin-top:12px;">
                创建新元素
            </button>
        </div>
        
        <div class="cheat-management">
            <div class="cheat-section-title">元素管理</div>
            <div class="element-list" id="element-list">
                <!-- 动态生成元素列表 -->
            </div>
        </div>
        
        <div class="save-load-section">
            <button onclick="saveAllChanges()">保存所有修改</button>
            <button onclick="loadSavedChanges()">加载保存的修改</button>
            <button onclick="clearSavedChanges()">清除保存</button>
        </div>
        
        <button class="cheat-btn cheat-btn-danger" onclick="closeCheatPanel()" style="width:100%; margin-top:20px;">
            关闭编辑器
        </button>
    </div>
</div>

<div id="toast" class="toast"></div>

<script>
// ================= 配置与元素定义 =================
let canvasScale = 3;
let isPaused = false;
let brushShape = 'circle';
let zeroGravity = false;
let showGrid = false;
let isSmoothMode = false;

let scale = 1;
let pointX = 0, pointY = 0, startX = 0, startY = 0;

const TYPES = {
    EMPTY: 0,
    SOLID: 1,
    POWDER: 2,
    LIQUID: 3,
    GAS: 4,
    ACID: 5,
    LAVA: 6,
    INDESTRUCTIBLE: 7,
    CLONE: 8,
    LIFE: 9,
    STEAM: 10,
    METAL_SOLID: 11,
    METAL_LIQUID: 12,
    EXPLOSIVE: 13,
    FUSE: 14
};

// 保存默认元素配置用于重置
const DEFAULT_ELEMENTS = {};

// 完整的元素定义
const ELEMENTS = {
    AIR: { 
        id: 0,  name: '空气',   
        color: [0,0,0,0],          
        type: TYPES.EMPTY, 
        heatResistance: 0.1, 
        defaultTemp: 20, 
        density: 0.00129,
        gasSpeed: 0.5,
        gasMovement: 'random',
        gasSpread: 0.5,
        gasBuoyancy: 0.0
    },
    
    SAND: { 
        id: 1,  name: '沙子',   
        color: [226,197,139,255],  
        type: TYPES.POWDER, 
        variance: 20, 
        heatResistance: 0.3, 
        defaultTemp: 20, 
        meltsAt: 1600, 
        meltTo: 'GLASS', 
        density: 1.6,
        acidResistance: 0.2,
        angleOfRepose: 45,
        rollness: 0.8
    },
    
    WATER: { 
        id: 2,  name: '水',     
        color: [79,151,232,255],   
        type: TYPES.LIQUID, 
        variance: 10, 
        heatResistance: 0.4, 
        defaultTemp: 20, 
        boilsAt: 100, 
        boilTo: 'STEAM', 
        freezesAt: 0, 
        freezeTo: 'ICE', 
        density: 1.0,
        acidResistance: 0.1,
        viscosity: 0,
        flowRate: 1.0,
        surfaceTension: 0.1
    },
    
    STONE: { 
        id: 3,  name: '石头',   
        color: [119,119,119,255],  
        type: TYPES.SOLID, 
        heatResistance: 0.5, 
        defaultTemp: 20, 
        density: 2.5,
        acidResistance: 0.8
    },
    
    WALL: { 
        id: 4,  name: '墙',     
        color: [150,150,150,255],  
        type: TYPES.SOLID, 
        heatResistance: 0.8, 
        defaultTemp: 20, 
        density: 2.4,
        acidResistance: 0.9
    },
    
    FIRE: { 
        id: 5,  name: '火焰',   
        color: [255,69,0,255],     
        type: TYPES.GAS, 
        variance: 50, 
        life: 50, 
        heatResistance: 0.0, 
        defaultTemp: 500, 
        heatEmission: 80, 
        burnTime: 50, 
        density: 0.001,
        acidResistance: 0.0,
        gasSpeed: 0.5,
        gasMovement: 'up',
        gasSpread: 0.6,
        gasBuoyancy: 1.0
    },
    
    SMOKE: { 
        id: 6,  name: '烟雾',   
        color: [200,200,200,150],  
        type: TYPES.GAS, 
        life: 200, 
        heatResistance: 0.2, 
        defaultTemp: 80, 
        density: 0.0012,
        acidResistance: 0.0,
        gasSpeed: 0.3,
        gasMovement: 'up',
        gasSpread: 0.4,
        gasBuoyancy: 0.8
    },
    
    ACID: { 
        id: 7,  name: '酸液',   
        color: [124,252,0,200],    
        type: TYPES.ACID, 
        acidity: true,
        heatResistance: 0.3, 
        defaultTemp: 20, 
        density: 1.3,
        viscosity: 0.1,
        flowRate: 0.9,
        surfaceTension: 0.05
    },
    
    WOOD: { 
        id: 8,  name: '木头',   
        color: [139,69,19,255],    
        type: TYPES.SOLID, 
        flammable: true, 
        heatResistance: 0.2, 
        defaultTemp: 20, 
        ignitesAt: 150, 
        burnTo: 'FIRE', 
        density: 0.7,
        acidResistance: 0.4
    },
    
    PLANT: { 
        id: 9,  name: '植物',   
        color: [34,139,34,255],    
        type: TYPES.SOLID, 
        flammable: true, 
        heatResistance: 0.2, 
        defaultTemp: 20, 
        ignitesAt: 120, 
        burnTo: 'FIRE', 
        density: 0.5,
        acidResistance: 0.3
    },
    
    OIL: { 
        id: 10, name: '石油',   
        color: [30,30,30,255],     
        type: TYPES.LIQUID, 
        flammable: true, 
        variance: 10, 
        heatResistance: 0.3, 
        defaultTemp: 20, 
        ignitesAt: 200, 
        burnTo: 'FIRE', 
        density: 0.9,
        acidResistance: 0.6,
        viscosity: 0.3,
        flowRate: 0.8,
        surfaceTension: 0.2
    },
    
    SEED: { 
        id: 11, name: '种子',   
        color: [139,90,43,255],    
        type: TYPES.POWDER, 
        flammable: true, 
        heatResistance: 0.2, 
        defaultTemp: 20, 
        ignitesAt: 100, 
        burnTo: 'FIRE', 
        density: 1.2,
        acidResistance: 0.3,
        angleOfRepose: 30,
        rollness: 0.6
    },
    
    GUNPOWDER: { 
        id: 12, name: '火药',   
        color: [180,150,120,255],
        type: TYPES.EXPLOSIVE,
        explosive: true,
        variance: 15, 
        heatResistance: 0.1, 
        defaultTemp: 20, 
        ignitesAt: 150,
        burnTo: 'FIRE', 
        density: 1.7,
        acidResistance: 0.5,
        explosivePower: 5,
        angleOfRepose: 35,
        rollness: 0.9
    },
    
    GAS_FUEL: { 
        id: 13, name: '燃气',   
        color: [255,213,79,180],   
        type: TYPES.GAS, 
        variance: 25, 
        flammable: true, 
        heatResistance: 0.0, 
        defaultTemp: 20, 
        ignitesAt: 60, 
        burnTo: 'FIRE', 
        density: 0.0011,
        acidResistance: 0.0,
        explosive: true,
        gasSpeed: 0.8,
        gasMovement: 'random',
        gasSpread: 0.9,
        gasBuoyancy: 0.5
    },
    
    ICE: { 
        id: 14, name: '冰',     
        color: [173,216,230,255],  
        type: TYPES.SOLID, 
        meltable: true,
        heatResistance: 0.6, 
        defaultTemp: -10, 
        meltsAt: 0, 
        meltTo: 'WATER', 
        density: 0.92,
        acidResistance: 0.7
    },
    
    LAVA: { 
        id: 15, name: '岩浆',   
        color: [255,80,0,255],     
        type: TYPES.LAVA, 
        hot: true, 
        variance: 30, 
        heatResistance: 0.0, 
        defaultTemp: 1200, 
        heatEmission: 100, 
        density: 2.8,
        acidResistance: 0.9,
        viscosity: 0.8,
        flowRate: 0.4,
        surfaceTension: 0.3
    },
    
    FLOWER: { 
        id: 16, name: '花',     
        color: [255,105,180,255],  
        type: TYPES.SOLID, 
        flammable: true, 
        heatResistance: 0.2, 
        defaultTemp: 20, 
        ignitesAt: 100, 
        burnTo: 'FIRE', 
        density: 0.6,
        acidResistance: 0.3
    },
    
    VINE: { 
        id: 17, name: '藤蔓',   
        color: [50,205,50,180],    
        type: TYPES.SOLID, 
        flammable: true, 
        heatResistance: 0.2, 
        defaultTemp: 20, 
        ignitesAt: 110, 
        burnTo: 'FIRE', 
        density: 0.4,
        acidResistance: 0.3
    },
    
    LEAF: { 
        id: 18, name: '叶子',   
        color: [144,238,144,200],  
        type: TYPES.SOLID, 
        flammable: true, 
        heatResistance: 0.2, 
        defaultTemp: 20, 
        ignitesAt: 90, 
        burnTo: 'FIRE', 
        density: 0.3,
        acidResistance: 0.3
    },
    
    CLONE: { 
        id: 19, name: '克隆',   
        color: [138,43,226,255],   
        type: TYPES.CLONE, 
        clonePower: 5, 
        pulse: true, 
        heatResistance: 0.5, 
        defaultTemp: 20, 
        density: 1.0,
        acidResistance: 0.8,
        copyInterval: 100,
        maxCopyCount: 50
    },
    
    SUPER_ACID: { 
        id: 20, name: '超酸',  
        color: [255,255,0,255],   
        type: TYPES.ACID, 
        superAcidic: true,
        heatResistance: 0.3, 
        defaultTemp: 20, 
        density: 1.8,
        viscosity: 0.05,
        flowRate: 1.0,
        surfaceTension: 0.02
    },
    
    BEDROCK: { 
        id: 21, name: '基岩',  
        color: [60,60,60,255],    
        type: TYPES.INDESTRUCTIBLE, 
        indestructible: true,
        heatResistance: 1.0, 
        defaultTemp: 20, 
        density: 3.0,
        acidResistance: 1.0
    },
    
    GLASS: { 
        id: 22, name: '玻璃',  
        color: [200,220,240,180], 
        type: TYPES.SOLID, 
        transparent: true,
        heatResistance: 0.4, 
        defaultTemp: 20, 
        meltsAt: 1500, 
        density: 2.5,
        acidResistance: 0.9
    },
    
    LIFE: { 
        id: 23, name: '生命',  
        color: [255,100,100,255], 
        type: TYPES.LIFE, 
        lifeForm: true,
        heatResistance: 0.3, 
        defaultTemp: 37, 
        diesAt: 60, 
        freezeAt: 0, 
        density: 1.1,
        acidResistance: 0.1,
        hungerRate: 0.5,
        breedChance: 0.05,
        moveInterval: 100
    },
    
    STEAM: { 
        id: 24, name: '蒸汽',  
        color: [220,240,255,200], 
        type: TYPES.GAS, 
        variance: 15, 
        life: 300, 
        heatResistance: 0.0, 
        defaultTemp: 120, 
        condensesAt: 99, 
        condenseTo: 'WATER', 
        density: 0.0006,
        acidResistance: 0.0,
        gasSpeed: 0.4,
        gasMovement: 'up',
        gasSpread: 0.5,
        gasBuoyancy: 0.9
    },

    SODIUM: {
        id: 25, name: '钠',
        color: [200,200,220,255],
        type: TYPES.POWDER,
        reactive: true,
        heatResistance: 0.1,
        defaultTemp: 20,
        density: 0.97,
        acidResistance: 0.1,
        angleOfRepose: 40,
        rollness: 0.7
    },

    IRON: {
        id: 26, name: '铁',
        color: [200,200,200,255],
        type: TYPES.METAL_SOLID,
        heatResistance: 0.6,
        defaultTemp: 20,
        meltsAt: 1538,
        meltTo: 'IRON_LIQUID',
        density: 7.87,
        acidResistance: 0.7,
        conductivity: 1.0,
        magnetism: 1.0,
        oxidizable: true,
        oxidationRate: 0.01,
        oxidizeTo: 'RUST'
    },
    
    IRON_LIQUID: {
        id: 27, name: '熔铁',
        color: [255,150,100,255],
        type: TYPES.METAL_LIQUID,
        heatResistance: 0.0,
        defaultTemp: 1600,
        freezesAt: 1535,
        freezeTo: 'IRON',
        density: 7.0,
        acidResistance: 0.5,
        viscosity: 0.9,
        flowRate: 0.3,
        surfaceTension: 0.4,
        conductivity: 0.8
    },
    
    COPPER: {
        id: 28, name: '铜',
        color: [184,115,51,255],
        type: TYPES.METAL_SOLID,
        heatResistance: 0.5,
        defaultTemp: 20,
        meltsAt: 1085,
        meltTo: 'COPPER_LIQUID',
        density: 8.96,
        acidResistance: 0.6,
        oxidizable: true,
        oxidationRate: 0.008,
        conductivity: 0.95
    },
    
    COPPER_LIQUID: {
        id: 29, name: '熔铜',
        color: [255,140,60,255],
        type: TYPES.METAL_LIQUID,
        heatResistance: 0.0,
        defaultTemp: 1100,
        freezesAt: 1080,
        freezeTo: 'COPPER',
        density: 8.0,
        acidResistance: 0.4,
        viscosity: 0.85,
        flowRate: 0.35,
        surfaceTension: 0.35,
        conductivity: 0.7
    },
    
    ZINC: {
        id: 30, name: '锌',
        color: [200,200,180,255],
        type: TYPES.METAL_SOLID,
        heatResistance: 0.4,
        defaultTemp: 20,
        meltsAt: 420,
        meltTo: 'ZINC_LIQUID',
        density: 7.14,
        acidResistance: 0.3,
        oxidizable: true,
        oxidationRate: 0.005,
        conductivity: 0.6
    },
    
    ZINC_LIQUID: {
        id: 31, name: '熔锌',
        color: [255,220,150,255],
        type: TYPES.METAL_LIQUID,
        heatResistance: 0.0,
        defaultTemp: 450,
        freezesAt: 415,
        freezeTo: 'ZINC',
        density: 6.5,
        acidResistance: 0.2,
        viscosity: 0.7,
        flowRate: 0.5,
        surfaceTension: 0.3,
        conductivity: 0.5
    },
    
    ALUMINUM: {
        id: 32, name: '铝',
        color: [220,220,220,255],
        type: TYPES.METAL_SOLID,
        heatResistance: 0.5,
        defaultTemp: 20,
        meltsAt: 660,
        meltTo: 'ALUMINUM_LIQUID',
        density: 2.7,
        acidResistance: 0.8,
        oxidizable: true,
        oxidationRate: 0.015,
        conductivity: 0.9
    },
    
    ALUMINUM_LIQUID: {
        id: 33, name: '熔铝',
        color: [255,200,150,255],
        type: TYPES.METAL_LIQUID,
        heatResistance: 0.0,
        defaultTemp: 700,
        freezesAt: 655,
        freezeTo: 'ALUMINUM',
        density: 2.4,
        acidResistance: 0.6,
        viscosity: 0.6,
        flowRate: 0.6,
        surfaceTension: 0.25,
        conductivity: 0.7
    },
    
    MAGNESIUM: {
        id: 34, name: '镁',
        color: [255,255,200,255],
        type: TYPES.METAL_SOLID,
        heatResistance: 0.3,
        defaultTemp: 20,
        meltsAt: 650,
        meltTo: 'MAGNESIUM_LIQUID',
        ignitesAt: 473,
        burnTo: 'FIRE',
        density: 1.74,
        acidResistance: 0.4,
        flammable: true,
        oxidizable: true,
        oxidationRate: 0.02,
        conductivity: 0.5
    },
    
    MAGNESIUM_LIQUID: {
        id: 35, name: '熔镁',
        color: [255,255,100,255],
        type: TYPES.METAL_LIQUID,
        heatResistance: 0.0,
        defaultTemp: 680,
        freezesAt: 645,
        freezeTo: 'MAGNESIUM',
        ignitesAt: 473,
        density: 1.6,
        acidResistance: 0.3,
        flammable: true,
        viscosity: 0.5,
        flowRate: 0.7,
        surfaceTension: 0.2,
        conductivity: 0.4
    },
    
    SILVER: {
        id: 36, name: '银',
        color: [230,230,230,255],
        type: TYPES.METAL_SOLID,
        heatResistance: 0.7,
        defaultTemp: 20,
        meltsAt: 962,
        meltTo: 'SILVER_LIQUID',
        density: 10.49,
        acidResistance: 0.9,
        oxidizable: true,
        oxidationRate: 0.003,
        conductivity: 1.0
    },
    
    SILVER_LIQUID: {
        id: 37, name: '熔银',
        color: [255,255,240,255],
        type: TYPES.METAL_LIQUID,
        heatResistance: 0.0,
        defaultTemp: 1000,
        freezesAt: 960,
        freezeTo: 'SILVER',
        density: 9.5,
        acidResistance: 0.8,
        viscosity: 0.8,
        flowRate: 0.4,
        surfaceTension: 0.45,
        conductivity: 0.9
    },
    
    GOLD: {
        id: 38, name: '金',
        color: [255,215,0,255],
        type: TYPES.METAL_SOLID,
        heatResistance: 0.8,
        defaultTemp: 20,
        meltsAt: 1064,
        meltTo: 'GOLD_LIQUID',
        density: 19.32,
        acidResistance: 1.0,
        oxidizable: false,
        conductivity: 0.9
    },
    
    GOLD_LIQUID: {
        id: 39, name: '熔金',
        color: [255,230,80,255],
        type: TYPES.METAL_LIQUID,
        heatResistance: 0.0,
        defaultTemp: 1100,
        freezesAt: 1060,
        freezeTo: 'GOLD',
        density: 17.5,
        acidResistance: 0.9,
        viscosity: 0.85,
        flowRate: 0.35,
        surfaceTension: 0.5,
        conductivity: 0.8
    },
    
    FUSE: {
        id: 40, name: '引线',
        color: [160,82,45,255],
        type: TYPES.FUSE,
        flammable: true,
        heatResistance: 0.1,
        defaultTemp: 20,
        ignitesAt: 100,
        burnTemp: 200,
        density: 0.8,
        acidResistance: 0.3,
        burnSpeed: 3,
        burnDuration: 60
    },
    
    RUST: {
        id: 41, name: '铁锈',
        color: [139,69,19,255],
        type: TYPES.POWDER,
        heatResistance: 0.4,
        defaultTemp: 20,
        density: 5.1,
        acidResistance: 0.2,
        angleOfRepose: 50,
        rollness: 0.5
    },

    TITANIUM: {
        id: 42, name: '钛',
        color: [180,180,200,255],
        type: TYPES.METAL_SOLID,
        heatResistance: 0.9,
        defaultTemp: 20,
        meltsAt: 1668,
        meltTo: 'TITANIUM_LIQUID',
        density: 4.5,
        acidResistance: 0.95,
        oxidizable: true,
        oxidationRate: 0.002,
        conductivity: 0.4
    },

    TITANIUM_LIQUID: {
        id: 43, name: '熔钛',
        color: [220,200,220,255],
        type: TYPES.METAL_LIQUID,
        heatResistance: 0.0,
        defaultTemp: 1700,
        freezesAt: 1665,
        freezeTo: 'TITANIUM',
        density: 4.1,
        acidResistance: 0.9,
        viscosity: 0.7,
        flowRate: 0.4,
        surfaceTension: 0.35,
        conductivity: 0.3
    },
    
    ERASER: { 
        id: 99, name: '橡皮擦', 
        color: [255,255,255,50], 
        type: TYPES.SOLID, 
        isEraser: true, 
        density: 0 
    }
};

// 保存默认配置
function saveDefaultElements() {
    for (let key in ELEMENTS) {
        DEFAULT_ELEMENTS[key] = JSON.parse(JSON.stringify(ELEMENTS[key]));
    }
}
saveDefaultElements();

// 快速访问栏元素
let QUICK_KEYS = ['SAND', 'WATER', 'STONE', 'WALL', 'ICE', 'LAVA', 'FIRE', 'STEAM', 'SUPER_ACID', 'BEDROCK', 'GLASS', 'LIFE', 'CLONE', 'IRON', 'COPPER', 'FUSE', 'RUST', 'ERASER'];

// 全局变量
let currentElement = ELEMENTS.SAND;
let brushSize = 5;
const canvas = document.getElementById('sandbox');
const ctx = canvas.getContext('2d', { alpha: false });
let width, height, grid, imageData, animationId;
let fps = 0, frameCount = 0, lastTime = performance.now();
const fpsUpdateInterval = 500;
const fpsDisplay = document.getElementById('fps-display');
const tempDisplay = document.getElementById('temp-display');

// 温度系统
let temperatureSystemEnabled = true;
let temperatures;
let heatTransferSpeed = 5;
let ambientTemperature = 20;

// 粒子数组
let particles = [];

// 冲击波数组
let shockWave = [];

// 金属氧化状态存储
let metalOxidation = new Uint8Array(0);
let metalOxidationProgress = new Uint8Array(0);

// 铁水反应状态存储
let ironWaterReaction = new Uint8Array(0);

// 镁燃烧状态存储
let magnesiumBurn = new Uint8Array(0);

// 引线燃烧状态存储
let fuseBurnState = {
    burning: new Uint8Array(0),
    burnTime: new Uint16Array(0),
    lastSpread: new Uint32Array(0)
};

// 种子生长状态存储
let seedGrowth = {
    positions: [],
    heights: [],
    directions: [],
    maxHeights: [],
    growthTime: []
};

const SEED_GROW_INTERVAL = 120;
const GROWTH_LIMITS = {
    MAX_SEED_GROWTH_HEIGHT: 12
};

// 生命元素状态
let lifeElements = {
    positions: [],
    lastMoveTime: [],
    directions: [],
    hunger: [],
    age: [],
    health: []
};

const LIFE_MAX_HUNGER = 100;
const LIFE_MAX_AGE = 1000;
const LIFE_MAX_HEALTH = 100;

// 克隆元素状态
let cloneElements = {
    positions: [],
    lastCopyTime: [],
    targetElements: [],
    copyCount: []
};

// 被破坏的植物记录
let destroyedPlants = {
    positions: [],
    timestamps: []
};
const DESTROYED_PLANT_TTL = 5000;

// 石头被炸飞状态
let flyingStones = {
    positions: [],
    velocitiesX: [],
    velocitiesY: [],
    timestamps: []
};
const FLYING_STONE_TTL = 3000;

// 爆炸传播标记
let explosionPropagationGrid = new Uint8Array(0);

// 导电系统
let electricalCharge = new Float32Array(0);
let electricalPotential = new Float32Array(0);

// 放射性系统
let radiationLevel = new Float32Array(0);

// 磁性系统
let magneticField = new Float32Array(0);
let magneticPolarity = new Int8Array(0);

// ================= 初始化函数 =================
function initGrid() {
    const container = document.getElementById('game-container');
    width = Math.floor(container.clientWidth / canvasScale);
    height = Math.floor(container.clientHeight / canvasScale);
    canvas.width = width;
    canvas.height = height;
    
    grid = new Array(width * height).fill(0);
    
    temperatures = new Float32Array(width * height);
    temperatures.fill(ambientTemperature);
    
    shockWave = new Uint8Array(width * height);
    
    metalOxidation = new Uint8Array(width * height);
    metalOxidationProgress = new Uint8Array(width * height);
    
    ironWaterReaction = new Uint8Array(width * height);
    
    magnesiumBurn = new Uint8Array(width * height);
    
    fuseBurnState.burning = new Uint8Array(width * height);
    fuseBurnState.burnTime = new Uint16Array(width * height);
    fuseBurnState.lastSpread = new Uint32Array(width * height);
    
    explosionPropagationGrid = new Uint8Array(width * height);
    
    electricalCharge = new Float32Array(width * height);
    electricalPotential = new Float32Array(width * height);
    
    radiationLevel = new Float32Array(width * height);
    
    magneticField = new Float32Array(width * height);
    magneticPolarity = new Int8Array(width * height);
    
    imageData = ctx.createImageData(width, height);
    for(let i = 0; i < imageData.data.length; i += 4) {
        imageData.data[i] = 0;
        imageData.data[i+1] = 0;
        imageData.data[i+2] = 0;
        imageData.data[i+3] = 255;
    }
    
    const gridOverlay = document.getElementById('grid-overlay');
    gridOverlay.style.backgroundSize = `${canvasScale}px ${canvasScale}px`;
}

// ================= 辅助函数 =================
const idx = (x, y) => x + y * width;
const inBounds = (x, y) => x >= 0 && x < width && y >= 0 && y < height;
const getElById = (id) => Object.values(ELEMENTS).find(e => e.id === id);

const getDir = () => 1;
const getDown = (y) => y + getDir();
const isDownValid = (y) => y < height;

let sparks = [];
class Spark {
    constructor(x, y, vx, vy, restoreId = 0) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.life = 20;
        this.restoreId = restoreId;
    }
    
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.2;
        this.life--;
        
        if (this.y >= height - 1 || this.life <= 0) {
            const ix = Math.floor(this.x);
            const iy = Math.floor(this.y);
            if (inBounds(ix, iy)) {
                const i = idx(ix, iy);
                if (grid[i] === 0) {
                    const el = getElById(this.restoreId);
                    if (el && (el.type === TYPES.LIQUID || el.type === TYPES.POWDER)) {
                        grid[i] = this.restoreId;
                    } else {
                        grid[i] = ELEMENTS.FIRE.id;
                    }
                }
            }
            return true;
        }
        return false;
    }
}

class FlyingStone {
    constructor(x, y, vx, vy) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.life = FLYING_STONE_TTL;
        this.startTime = performance.now();
    }

    update() {
        const now = performance.now();
        const elapsed = now - this.startTime;
        this.life = FLYING_STONE_TTL - elapsed;

        if (this.life <= 0) {
            const ix = Math.floor(this.x);
            const iy = Math.floor(this.y);
            if (inBounds(ix, iy)) {
                const i = idx(ix, iy);
                if (grid[i] === 0) {
                    grid[i] = ELEMENTS.SAND.id;
                }
            }
            return true;
        }

        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.2;

        if (this.x < 0 || this.x >= width || this.y >= height) {
            const ix = Math.max(0, Math.min(width - 1, Math.floor(this.x)));
            const iy = Math.max(0, Math.min(height - 1, Math.floor(this.y)));
            if (inBounds(ix, iy)) {
                const i = idx(ix, iy);
                if (grid[i] === 0) {
                    grid[i] = ELEMENTS.SAND.id;
                }
            }
            return true;
        }

        const ix = Math.floor(this.x);
        const iy = Math.floor(this.y);
        if (inBounds(ix, iy)) {
            const i = idx(ix, iy);
            if (grid[i] !== 0 && grid[i] !== ELEMENTS.AIR.id) {
                grid[i] = ELEMENTS.SAND.id;
                return true;
            }
        }

        return false;
    }
}

// ================= 物理属性系统 =================

// 1. 密度浮力系统
function updateDensityBuoyancy(x, y, i) {
    const el = getElById(grid[i]);
    if (!el || el.density === undefined || zeroGravity) return false;
    
    // 检查下方的粒子
    const below = idx(x, y + 1);
    if (y + 1 < height && grid[below] !== 0) {
        const belowEl = getElById(grid[below]);
        if (belowEl && belowEl.density !== undefined) {
            // 根据粒子类型决定交换条件
            let shouldSwap = false;
            const densityDiff = el.density - belowEl.density;
            
            // 同类型物质之间的交换
            if (el.type === belowEl.type) {
                switch(el.type) {
                    case TYPES.SOLID:
                    case TYPES.METAL_SOLID:
                        // 固体之间：需要较大密度差异且低概率
                        shouldSwap = densityDiff > 1.0 && Math.random() < 0.02;
                        break;
                    case TYPES.POWDER:
                        // 粉末之间：中等密度差异
                        shouldSwap = densityDiff > 0.8;
                        break;
                    case TYPES.LIQUID:
                    case TYPES.ACID:
                    case TYPES.LAVA:
                    case TYPES.METAL_LIQUID:
                        // 液体之间：较小密度差异
                        shouldSwap = densityDiff > 0.5;
                        break;
                    case TYPES.GAS:
                        // 气体之间：很小密度差异
                        shouldSwap = densityDiff > 0.001;
                        break;
                }
            } else {
                // 不同类型物质之间的交换
                shouldSwap = densityDiff > 1.5;
                
                // 特殊情况：气体几乎总是在其他物质上面
                if (el.type === TYPES.GAS && belowEl.type !== TYPES.GAS) {
                    shouldSwap = false; // 气体不沉到下面
                }
                if (belowEl.type === TYPES.GAS && el.type !== TYPES.GAS) {
                    shouldSwap = true; // 其他物质沉到气体下面
                }
            }
            
            if (shouldSwap) {
                swap(i, below);
                return true;
            }
        }
    }
    return false;
}

// 2. 气体属性系统
function updateGasMovement(x, y, i, elem) {
    if (!elem.gasMovement) return false;
    
    const dirs = {
        'up': [[0, -1, 0.4], [0, 1, 0.05], [-1, 0, 0.275], [1, 0, 0.275]],
        'down': [[0, 1, 0.4], [0, -1, 0.05], [-1, 0, 0.275], [1, 0, 0.275]],
        'random': [[0, -1, 0.2], [0, 1, 0.2], [-1, 0, 0.3], [1, 0, 0.3]],
        'horizontal': [[-1, 0, 0.4], [1, 0, 0.4], [0, -1, 0.1], [0, 1, 0.1]],
        'chaotic': [[0, -1, 0.15], [0, 1, 0.15], [-1, 0, 0.35], [1, 0, 0.35]]
    };
    
    let movementDirs = dirs[elem.gasMovement] || dirs.up;
    const speed = elem.gasSpeed || 0.5;
    
    // 应用浮力
    if (elem.gasBuoyancy !== undefined) {
        const buoyancy = elem.gasBuoyancy;
        if (buoyancy > 0) {
            movementDirs = movementDirs.map(([dx, dy, prob]) => {
                if (dy < 0) return [dx, dy, prob * (1 + buoyancy)];
                if (dy > 0) return [dx, dy, prob * (1 - buoyancy)];
                return [dx, dy, prob];
            });
        }
    }
    
    // 归一化概率
    let totalProb = movementDirs.reduce((sum, [,,prob]) => sum + prob, 0);
    movementDirs = movementDirs.map(([dx, dy, prob]) => [dx, dy, prob / totalProb]);
    
    let rand = Math.random();
    let selectedDir = [0, 0];
    for (const [dx, dy, prob] of movementDirs) {
        if (rand < prob) {
            selectedDir = [dx, dy];
            break;
        }
        rand -= prob;
    }
    
    const newX = x + selectedDir[0];
    const newY = y + selectedDir[1];
    
    if (inBounds(newX, newY)) {
        const ni = idx(newX, newY);
        if (grid[ni] === 0) {
            // 应用气体扩散
            if (elem.gasSpread && Math.random() < elem.gasSpread) {
                const spreadX = newX + (Math.random() > 0.5 ? 1 : -1);
                const spreadY = newY + (Math.random() > 0.5 ? 1 : -1);
                if (inBounds(spreadX, spreadY)) {
                    const spreadIdx = idx(spreadX, spreadY);
                    if (grid[spreadIdx] === 0) {
                        grid[spreadIdx] = grid[i];
                        grid[i] = 0;
                        return true;
                    }
                }
            }
            
            swap(i, ni);
            return true;
        }
    }
    return false;
}

// 3. 液体属性系统
function updateLiquidWithProperties(x, y, i, elem) {
    const viscosity = elem.viscosity || 0;
    const flowRate = elem.flowRate !== undefined ? elem.flowRate : 1.0;
    const surfaceTension = elem.surfaceTension || 0;
    
    // 检查下方
    const below = idx(x, y + 1);
    if (y + 1 < height && grid[below] === 0) {
        if (Math.random() > viscosity * 0.5) {
            swap(i, below);
            return true;
        }
    }
    
    // 检查侧面流动
    const dir = Math.random() > 0.5 ? 1 : -1;
    const sideA = idx(x + dir, y);
    const sideB = idx(x - dir, y);
    
    let moved = false;
    
    if (inBounds(x + dir, y) && grid[sideA] === 0) {
        if (Math.random() < flowRate * (1 - viscosity * 0.3)) {
            swap(i, sideA);
            moved = true;
        }
    } else if (inBounds(x - dir, y) && grid[sideB] === 0) {
        if (Math.random() < flowRate * (1 - viscosity * 0.3)) {
            swap(i, sideB);
            moved = true;
        }
    }
    
    // 表面张力效应
    if (surfaceTension > 0 && !moved) {
        const neighbors = [
            [x, y - 1], [x - 1, y], [x + 1, y],
            [x - 1, y - 1], [x + 1, y - 1]
        ];
        
        for (const [nx, ny] of neighbors) {
            if (inBounds(nx, ny)) {
                const ni = idx(nx, ny);
                const neighbor = getElById(grid[ni]);
                if (neighbor && neighbor.type === elem.type && 
                    Math.random() < surfaceTension * 0.1) {
                    // 吸引到同类
                    const between = idx(x, y - 1);
                    if (grid[between] === 0) {
                        swap(i, between);
                        return true;
                    }
                }
            }
        }
    }
    
    return moved;
}

// 4. 粉末属性系统
function updatePowderWithProperties(x, y, i, elem) {
    if (zeroGravity) return false;
    
    const angleOfRepose = elem.angleOfRepose || 45;
    const rollness = elem.rollness || 0.8;
    
    const below = idx(x, y + 1);
    if (y + 1 < height && (grid[below] === 0 || isLiquid(grid[below]))) {
        swap(i, below);
        return true;
    }
    
    // 根据堆积角度决定滚动行为
    const side = Math.random() > 0.5 ? 1 : -1;
    const diag = idx(x + side, y + 1);
    
    if (inBounds(x + side, y + 1) && (grid[diag] === 0 || isLiquid(grid[diag]))) {
        // 检查堆积角度
        const leftCheck = idx(x - 1, y);
        const rightCheck = idx(x + 1, y);
        
        let canRoll = true;
        if (side === 1 && grid[rightCheck] !== 0) {
            const neighborAngle = Math.atan2(1, 1) * (180 / Math.PI);
            canRoll = neighborAngle <= angleOfRepose;
        } else if (side === -1 && grid[leftCheck] !== 0) {
            const neighborAngle = Math.atan2(1, 1) * (180 / Math.PI);
            canRoll = neighborAngle <= angleOfRepose;
        }
        
        if (canRoll && Math.random() < rollness) {
            swap(i, diag);
            return true;
        }
    }
    
    return false;
}

// 5. 导电系统
function updateElectricalConduction() {
    for (let i = 0; i < grid.length; i++) {
        if (grid[i] === 0) continue;
        
        const elem = getElById(grid[i]);
        if (!elem || !elem.conductivity || elem.conductivity <= 0) continue;
        
        const x = i % width;
        const y = Math.floor(i / width);
        
        // 传导电荷给邻居
        const neighbors = [
            idx(x, y - 1), idx(x, y + 1),
            idx(x - 1, y), idx(x + 1, y)
        ];
        
        for (const ni of neighbors) {
            if (ni >= 0 && ni < grid.length && grid[ni] !== 0) {
                const neighborElem = getElById(grid[ni]);
                if (neighborElem && neighborElem.conductivity) {
                    const transfer = (electricalCharge[i] - electricalCharge[ni]) * 
                                   elem.conductivity * 0.1;
                    electricalCharge[i] -= transfer;
                    electricalCharge[ni] += transfer;
                }
            }
        }
        
        // 放电效果
        if (electricalCharge[i] > 10) {
            if (Math.random() < 0.01) {
                // 产生火花
                const sparkX = x + (Math.random() - 0.5) * 3;
                const sparkY = y + (Math.random() - 0.5) * 3;
                sparks.push(new Spark(sparkX, sparkY, 
                    (Math.random() - 0.5) * 2, 
                    (Math.random() - 0.5) * 2 - 1,
                    ELEMENTS.FIRE.id));
                
                electricalCharge[i] *= 0.5;
            }
        }
    }
    
    // 电荷衰减
    for (let i = 0; i < electricalCharge.length; i++) {
        electricalCharge[i] *= 0.99;
        if (Math.abs(electricalCharge[i]) < 0.01) {
            electricalCharge[i] = 0;
        }
    }
}

// 6. 放射性系统
function updateRadioactivity() {
    for (let i = 0; i < grid.length; i++) {
        if (grid[i] === 0) continue;
        
        const elem = getElById(grid[i]);
        if (!elem || !elem.radioactivity || elem.radioactivity <= 0) continue;
        
        const radioactivity = elem.radioactivity;
        radiationLevel[i] += radioactivity * 0.1;
        
        // 放射性衰变
        if (Math.random() < radioactivity * 0.001) {
            const x = i % width;
            const y = Math.floor(i / width);
            
            // 产生辐射粒子
            for (let j = 0; j < 3; j++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 3 + 1;
                const rx = x + Math.cos(angle) * distance;
                const ry = y + Math.sin(angle) * distance;
                
                if (inBounds(Math.floor(rx), Math.floor(ry))) {
                    const ri = idx(Math.floor(rx), Math.floor(ry));
                    const targetElem = getElById(grid[ri]);
                    
                    // 辐射对生命元素的影响
                    if (targetElem && targetElem.type === TYPES.LIFE) {
                        if (Math.random() < 0.1) {
                            grid[ri] = 0;
                            removeGrowthRecords(ri);
                        }
                    }
                    
                    // 提高温度
                    if (temperatureSystemEnabled) {
                        temperatures[ri] = Math.min(5000, temperatures[ri] + 10);
                    }
                }
            }
            
            // 放射性衰减
            radiationLevel[i] *= 0.9;
        }
    }
    
    // 辐射扩散和衰减
    const newRadiation = new Float32Array(radiationLevel);
    for (let i = 0; i < radiationLevel.length; i++) {
        if (radiationLevel[i] > 0) {
            const x = i % width;
            const y = Math.floor(i / width);
            
            // 扩散到邻居
            const neighbors = [
                idx(x, y - 1), idx(x, y + 1),
                idx(x - 1, y), idx(x + 1, y)
            ];
            
            for (const ni of neighbors) {
                if (ni >= 0 && ni < grid.length) {
                    const spread = radiationLevel[i] * 0.1;
                    newRadiation[ni] += spread;
                    newRadiation[i] -= spread;
                }
            }
            
            // 自然衰减
            newRadiation[i] *= 0.95;
        }
    }
    
    radiationLevel.set(newRadiation);
}

// 7. 磁性系统
function updateMagnetism() {
    for (let i = 0; i < grid.length; i++) {
        if (grid[i] === 0) continue;
        
        const elem = getElById(grid[i]);
        if (!elem || !elem.magnetism || elem.magnetism <= 0) continue;
        
        const magnetism = elem.magnetism;
        const x = i % width;
        const y = Math.floor(i / width);
        
        // 寻找其他磁性元素
        let totalForceX = 0;
        let totalForceY = 0;
        
        for (let dy = -5; dy <= 5; dy++) {
            for (let dx = -5; dx <= 5; dx++) {
                if (dx === 0 && dy === 0) continue;
                
                const nx = x + dx;
                const ny = y + dy;
                if (!inBounds(nx, ny)) continue;
                
                const ni = idx(nx, ny);
                if (grid[ni] === 0) continue;
                
                const neighborElem = getElById(grid[ni]);
                if (neighborElem && neighborElem.magnetism) {
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance > 0) {
                        // 磁力公式：F = (m1 * m2) / (r^2)
                        const force = (magnetism * neighborElem.magnetism) / (distance * distance);
                        const polarity = magneticPolarity[i] * magneticPolarity[ni];
                        
                        // 同性相斥，异性相吸
                        const dirX = dx / distance;
                        const dirY = dy / distance;
                        
                        if (polarity < 0) {
                            // 异性相吸
                            totalForceX -= dirX * force;
                            totalForceY -= dirY * force;
                        } else {
                            // 同性相斥
                            totalForceX += dirX * force;
                            totalForceY += dirY * force;
                        }
                    }
                }
            }
        }
        
        // 应用磁力
        if (Math.abs(totalForceX) > 0.1 || Math.abs(totalForceY) > 0.1) {
            const moveX = Math.round(x + totalForceX * magnetism);
            const moveY = Math.round(y + totalForceY * magnetism);
            
            if (inBounds(moveX, moveY)) {
                const moveIdx = idx(moveX, moveY);
                if (grid[moveIdx] === 0) {
                    swap(i, moveIdx);
                }
            }
        }
    }
}

// ================= 铁水反应和氧化系统 =================
function updateIronWaterReaction(x, y) {
    const i = idx(x, y);
    const elemId = grid[i];
    
    if (elemId !== ELEMENTS.IRON.id && elemId !== ELEMENTS.IRON_LIQUID.id) return false;
    
    const elem = getElById(elemId);
    if (!elem.oxidizable) return false;
    
    // 检查周围是否有水
    const waterOffsets = [[0, 1], [0, -1], [1, 0], [-1, 0]];
    let hasWater = false;
    
    for (const [dx, dy] of waterOffsets) {
        const nx = x + dx;
        const ny = y + dy;
        if (inBounds(nx, ny)) {
            const ni = idx(nx, ny);
            if (grid[ni] === ELEMENTS.WATER.id) {
                hasWater = true;
                break;
            }
        }
    }
    
    if (hasWater) {
        // 铁遇水生锈
        ironWaterReaction[i] = Math.min(255, ironWaterReaction[i] + 3);
        
        if (ironWaterReaction[i] > 100) {
            // 高湿度下更快生锈
            metalOxidationProgress[i] = Math.min(255, metalOxidationProgress[i] + 5);
        } else {
            metalOxidationProgress[i] = Math.min(255, metalOxidationProgress[i] + 2);
        }
        
        // 如果氧化进度达到100，变成铁锈
        if (metalOxidationProgress[i] >= 100 && Math.random() < 0.02) {
            grid[i] = ELEMENTS.RUST.id;
            ironWaterReaction[i] = 0;
            metalOxidationProgress[i] = 0;
            metalOxidation[i] = 0;
            return true;
        }
    }
    
    return false;
}

function updateMetalOxidation(x, y) {
    const i = idx(x, y);
    const elemId = grid[i];
    
    if (elemId === ELEMENTS.IRON.id || elemId === ELEMENTS.COPPER.id || 
        elemId === ELEMENTS.ZINC.id || elemId === ELEMENTS.ALUMINUM.id ||
        elemId === ELEMENTS.MAGNESIUM.id || elemId === ELEMENTS.SILVER.id ||
        elemId === ELEMENTS.TITANIUM.id) {
        
        const elem = getElById(elemId);
        if (!elem.oxidizable) return;
        
        let oxidationChance = 0;
        
        // 基础氧化概率
        if (elem.oxidationRate) {
            oxidationChance = elem.oxidationRate;
        } else {
            // 根据不同金属设置不同的氧化概率
            switch(elemId) {
                case ELEMENTS.IRON.id:
                    oxidationChance = 0.01;
                    break;
                case ELEMENTS.COPPER.id:
                    oxidationChance = 0.008;
                    break;
                case ELEMENTS.ZINC.id:
                    oxidationChance = 0.005;
                    break;
                case ELEMENTS.ALUMINUM.id:
                    oxidationChance = 0.015;
                    break;
                case ELEMENTS.MAGNESIUM.id:
                    oxidationChance = 0.02;
                    break;
                case ELEMENTS.SILVER.id:
                    oxidationChance = 0.003;
                    break;
                case ELEMENTS.TITANIUM.id:
                    oxidationChance = 0.002;
                    break;
                default:
                    oxidationChance = 0.001;
            }
        }
        
        // 高温增加氧化概率
        if (temperatureSystemEnabled && temperatures[i] > 100) {
            const tempFactor = Math.min(5, temperatures[i] / 100);
            oxidationChance *= tempFactor;
        }
        
        // 检查周围是否有水或酸，增加氧化概率
        const neighbors = [[0, 1], [0, -1], [1, 0], [-1, 0]];
        for (const [dx, dy] of neighbors) {
            const nx = x + dx;
            const ny = y + dy;
            if (inBounds(nx, ny)) {
                const ni = idx(nx, ny);
                const neighborId = grid[ni];
                if (neighborId === ELEMENTS.WATER.id || neighborId === ELEMENTS.ACID.id || 
                    neighborId === ELEMENTS.SUPER_ACID.id) {
                    oxidationChance *= 3;
                    break;
                }
            }
        }
        
        // 应用氧化
        if (Math.random() < oxidationChance) {
            metalOxidation[i] = Math.min(255, metalOxidation[i] + 1);
            metalOxidationProgress[i] = Math.min(100, metalOxidationProgress[i] + 1);
            
            // 对于铁，如果完全氧化就变成铁锈
            if (elemId === ELEMENTS.IRON.id && metalOxidationProgress[i] >= 100 && Math.random() < 0.1) {
                grid[i] = ELEMENTS.RUST.id;
                metalOxidation[i] = 0;
                metalOxidationProgress[i] = 0;
            }
        }
    }
}

// ================= 物质移动函数 =================
function updatePowder(x, y, i, elem) {
    // 使用增强的粉末物理
    return updatePowderWithProperties(x, y, i, elem);
}

function updateLiquid(x, y, i, elem) {
    if (elem.id === ELEMENTS.LAVA.id) {
        return updateLava(x, y, i);
    }
    
    // 使用增强的液体物理
    return updateLiquidWithProperties(x, y, i, elem);
}

function updateLava(x, y, i) {
    const elem = ELEMENTS.LAVA;
    
    // 首先检查是否可以点燃周围的可燃物
    const neighbors = [
        [0, 1], [0, -1], [1, 0], [-1, 0],
        [1, 1], [-1, 1], [1, -1], [-1, -1]
    ];
    
    for (const [dx, dy] of neighbors) {
        const nx = x + dx;
        const ny = y + dy;
        if (inBounds(nx, ny)) {
            const ni = idx(nx, ny);
            const neighborId = grid[ni];
            const neighbor = getElById(neighborId);
            
            // 岩浆可以点燃可燃物
            if (neighbor && neighbor.flammable && Math.random() < 0.3) {
                grid[ni] = ELEMENTS.FIRE.id;
                if (temperatureSystemEnabled) {
                    temperatures[ni] = 500;
                }
            }
            
            // 岩浆可以引爆爆炸物
            if (neighbor && neighbor.explosive && Math.random() < 0.2) {
                doExplode(nx, ny, neighbor.explosivePower || 4, 180);
            }
        }
    }
    
    // 正常的岩浆流动
    const below = idx(x, y + 1);
    if (y + 1 < height) {
        const belowElem = getElById(grid[below]);
        if (grid[below] === ELEMENTS.WATER.id) { 
            grid[below] = ELEMENTS.STONE.id; 
            return true; 
        }
        else if (grid[below] === 0 || (belowElem && (belowElem.type === TYPES.LIQUID || belowElem.type === TYPES.GAS))) {
            const temp = grid[below];
            grid[below] = ELEMENTS.LAVA.id; 
            grid[i] = 0;
            if (temp !== 0 && temp !== ELEMENTS.LAVA.id) {
                const dir = Math.random() > 0.5 ? 1 : -1;
                const side = idx(x + dir, y);
                if (inBounds(x + dir, y) && grid[side] === 0) grid[side] = temp;
            }
            return true;
        }
    }
    
    const dir = Math.random() > 0.5 ? 1 : -1;
    const sideA = idx(x + dir, y);
    const sideB = idx(x - dir, y);
    
    if (inBounds(x + dir, y)) {
        const sideAElem = getElById(grid[sideA]);
        if (grid[sideA] === ELEMENTS.WATER.id) { 
            grid[sideA] = ELEMENTS.STONE.id; 
            return true; 
        }
        else if (grid[sideA] === 0 || (sideAElem && (sideAElem.type === TYPES.LIQUID || sideAElem.type === TYPES.GAS))) {
            const temp = grid[sideA];
            grid[sideA] = ELEMENTS.LAVA.id; 
            grid[i] = 0;
            if (temp !== 0 && temp !== ELEMENTS.LAVA.id) {
                const up = idx(x + dir, y - 1);
                if (inBounds(x + dir, y - 1) && grid[up] === 0) grid[up] = temp;
            }
            return true;
        }
    }
    
    if (inBounds(x - dir, y)) {
        const sideBElem = getElById(grid[sideB]);
        if (grid[sideB] === ELEMENTS.WATER.id) { 
            grid[sideB] = ELEMENTS.STONE.id; 
            return true; 
        }
        else if (grid[sideB] === 0 || (sideBElem && (sideBElem.type === TYPES.LIQUID || sideBElem.type === TYPES.GAS))) {
            const temp = grid[sideB];
            grid[sideB] = ELEMENTS.LAVA.id; 
            grid[i] = 0;
            if (temp !== 0 && temp !== ELEMENTS.LAVA.id) {
                const up = idx(x - dir, y - 1);
                if (inBounds(x - dir, y - 1) && grid[up] === 0) grid[up] = temp;
            }
            return true;
        }
    }
    
    const diagA = idx(x + dir, y + 1);
    const diagB = idx(x - dir, y + 1);
    
    if (y + 1 < height) {
        if (inBounds(x + dir, y + 1) && (grid[diagA] === 0 || grid[diagA] === ELEMENTS.WATER.id)) {
            if (grid[diagA] === ELEMENTS.WATER.id) grid[diagA] = ELEMENTS.STONE.id;
            else { grid[diagA] = ELEMENTS.LAVA.id; grid[i] = 0; }
            return true;
        }
        if (inBounds(x - dir, y + 1) && (grid[diagB] === 0 || grid[diagB] === ELEMENTS.WATER.id)) {
            if (grid[diagB] === ELEMENTS.WATER.id) grid[diagB] = ELEMENTS.STONE.id;
            else { grid[diagB] = ELEMENTS.LAVA.id; grid[i] = 0; }
            return true;
        }
    }
    
    return false;
}

function updateStone(x, y, i) {
    if (zeroGravity) return false;
    
    const below = idx(x, y + 1);
    if (y + 1 < height) {
        const belowElem = getElById(grid[below]);
        if (grid[below] === 0 || (belowElem && (belowElem.type === TYPES.LIQUID || belowElem.type === TYPES.GAS || belowElem.type === TYPES.LAVA))) {
            swap(i, below);
            return true;
        }
    }
    return false;
}

function updateMetalSolid(x, y, i, elem) {
    if (zeroGravity) return false;
    
    const below = idx(x, y + 1);
    if (y + 1 < height) {
        const belowElem = getElById(grid[below]);
        if (grid[below] === 0 || (belowElem && (belowElem.type === TYPES.LIQUID || belowElem.type === TYPES.GAS))) {
            swap(i, below);
            return true;
        }
    }
    return false;
}

function updateMetalLiquid(x, y, i, elem) {
    return updateLiquidWithProperties(x, y, i, elem);
}

function updateFuse(x, y, i, elem, now) {
    if (fuseBurnState.burning[i] === 1) {
        fuseBurnState.burnTime[i]++;
        
        if (temperatureSystemEnabled) {
            temperatures[i] = Math.max(temperatures[i], elem.burnTemp || 200);
        }
        
        if (fuseBurnState.burnTime[i] > 5 && Math.random() < 0.3) {
            const fireOffsets = [[0, -1], [0, 1], [1, 0], [-1, 0]];
            for (const [dx, dy] of fireOffsets) {
                const fx = x + dx;
                const fy = y + dy;
                if (inBounds(fx, fy)) {
                    const fi = idx(fx, fy);
                    if (grid[fi] === 0 && Math.random() < 0.2) {
                        grid[fi] = ELEMENTS.FIRE.id;
                        if (temperatureSystemEnabled) {
                            temperatures[fi] = 500;
                        }
                    }
                }
            }
        }
        
        const burnSpeed = elem.burnSpeed || 3;
        if (now - fuseBurnState.lastSpread[i] > burnSpeed * 16) {
            const spreadOffsets = [[0, -1], [0, 1], [1, 0], [-1, 0], [1, -1], [-1, -1], [1, 1], [-1, 1]];
            for (const [dx, dy] of spreadOffsets) {
                const nx = x + dx;
                const ny = y + dy;
                if (inBounds(nx, ny)) {
                    const ni = idx(nx, ny);
                    if (grid[ni] === ELEMENTS.FUSE.id && fuseBurnState.burning[ni] === 0) {
                        igniteFuse(nx, ny, ni, now);
                    }
                }
            }
            fuseBurnState.lastSpread[i] = now;
        }
        
        const burnDuration = elem.burnDuration || 60;
        if (fuseBurnState.burnTime[i] > burnDuration) {
            grid[i] = ELEMENTS.SMOKE.id;
            fuseBurnState.burning[i] = 0;
            fuseBurnState.burnTime[i] = 0;
            fuseBurnState.lastSpread[i] = 0;
        }
        
        return true;
    }
    
    let shouldIgnite = false;
    
    const fireOffsets = [[0, -1], [0, 1], [1, 0], [-1, 0], [1, -1], [-1, -1], [1, 1], [-1, 1]];
    for (const [dx, dy] of fireOffsets) {
        const nx = x + dx;
        const ny = y + dy;
        if (inBounds(nx, ny)) {
            const ni = idx(nx, ny);
            const neighborId = grid[ni];
            if (neighborId === ELEMENTS.FIRE.id || neighborId === ELEMENTS.LAVA.id) {
                shouldIgnite = true;
                break;
            }
        }
    }
    
    if (temperatureSystemEnabled && temperatures[i] > (elem.ignitesAt || 100)) {
        shouldIgnite = true;
    }
    
    if (shockWave[i] > 50) {
        shouldIgnite = true;
    }
    
    if (shouldIgnite) {
        igniteFuse(x, y, i, now);
        return true;
    }
    
    return false;
}

function igniteFuse(x, y, i, now) {
    fuseBurnState.burning[i] = 1;
    fuseBurnState.burnTime[i] = 0;
    fuseBurnState.lastSpread[i] = now;
    
    if (temperatureSystemEnabled) {
        const elem = getElById(grid[i]);
        temperatures[i] = elem.burnTemp || 200;
    }
}

function updateFireImproved(x, y, i) {
    const elem = getElById(grid[i]);
    
    if (Math.random() < 0.12) { 
        grid[i] = ELEMENTS.SMOKE.id; 
        return true; 
    }
    
    if (temperatureSystemEnabled) {
        temperatures[i] = Math.min(800, temperatures[i] + 5);
    }
    
    // 点燃周围的可燃物
    const around = [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [-1, 1], [1, -1], [-1, -1]];
    for (let [dx, dy] of around) {
        const ni = idx(x + dx, y + dy);
        if (!inBounds(x + dx, y + dy)) continue;
        const neighborId = grid[ni];
        if (neighborId === ELEMENTS.LAVA.id) continue;
        const neighbor = getElById(neighborId);
        if (neighbor && neighbor.flammable && Math.random() < 0.25) {
            grid[ni] = ELEMENTS.FIRE.id;
            if (temperatureSystemEnabled) {
                temperatures[ni] = 500;
            }
        }
        if (neighbor && neighbor.meltable && Math.random() < 0.15) {
            grid[ni] = neighbor.meltTo ? ELEMENTS[neighbor.meltTo].id : ELEMENTS.WATER.id;
        }
    }
    
    // 使用气体移动系统
    return updateGasMovement(x, y, i, elem);
}

function updateSmokeImproved(x, y, i) {
    const elem = getElById(grid[i]);
    
    if (Math.random() < 0.02) { 
        grid[i] = 0; 
        return true; 
    }
    
    // 使用气体移动系统
    return updateGasMovement(x, y, i, elem);
}

function updateFuelGasImproved(x, y, i) {
    const elem = getElById(grid[i]);
    
    const aroundFire = [[0, 1], [0, -1], [1, 0], [-1, 0]].some(([dx, dy]) => {
        const ni = idx(x + dx, y + dy);
        return inBounds(x + dx, y + dy) && grid[ni] === ELEMENTS.FIRE.id;
    });
    
    if (aroundFire) {
        doExplode(x, y, 3, 120);
        return true;
    }
    
    // 使用气体移动系统
    return updateGasMovement(x, y, i, elem);
}

function updateSteamImproved(x, y, i) {
    const elem = getElById(grid[i]);
    
    // 使用气体移动系统，但调整向上飘散的权重
    const adjustedElem = { ...elem };
    if (temperatureSystemEnabled && temperatures[i] > 120) {
        adjustedElem.gasBuoyancy = (elem.gasBuoyancy || 0) + 0.3;
    }
    
    return updateGasMovement(x, y, i, adjustedElem);
}

function updateGasImproved(x, y, i, elem) {
    if (elem.id === ELEMENTS.FIRE.id) {
        return updateFireImproved(x, y, i);
    }
    if (elem.id === ELEMENTS.SMOKE.id) {
        return updateSmokeImproved(x, y, i);
    }
    if (elem.id === ELEMENTS.GAS_FUEL.id) {
        return updateFuelGasImproved(x, y, i);
    }
    if (elem.id === ELEMENTS.STEAM.id) {
        return updateSteamImproved(x, y, i);
    }
    
    // 通用气体移动
    return updateGasMovement(x, y, i, elem);
}

function isLiquid(id) {
    const e = getElById(id);
    return e && (e.type === TYPES.LIQUID || e.type === TYPES.LAVA || e.type === TYPES.ACID);
}

function isLiquidOrGas(id) {
    const e = getElById(id);
    return e && (e.type === TYPES.LIQUID || e.type === TYPES.GAS || e.type === TYPES.LAVA);
}

function isWaterLike(id) {
    return id === ELEMENTS.WATER.id || id === ELEMENTS.OIL.id || id === ELEMENTS.ACID.id || id === ELEMENTS.SEED.id;
}

function swap(i, j) {
    const temp = grid[i];
    grid[i] = grid[j];
    grid[j] = temp;
    
    if (temperatureSystemEnabled) {
        const tempT = temperatures[i];
        temperatures[i] = temperatures[j];
        temperatures[j] = tempT;
    }
    
    const tempO = metalOxidation[i];
    metalOxidation[i] = metalOxidation[j];
    metalOxidation[j] = tempO;
    
    const tempOP = metalOxidationProgress[i];
    metalOxidationProgress[i] = metalOxidationProgress[j];
    metalOxidationProgress[j] = tempOP;
    
    const tempI = ironWaterReaction[i];
    ironWaterReaction[i] = ironWaterReaction[j];
    ironWaterReaction[j] = tempI;
    
    const tempM = magnesiumBurn[i];
    magnesiumBurn[i] = magnesiumBurn[j];
    magnesiumBurn[j] = tempM;
    
    const tempB = fuseBurnState.burning[i];
    fuseBurnState.burning[i] = fuseBurnState.burning[j];
    fuseBurnState.burning[j] = tempB;
    
    const tempT2 = fuseBurnState.burnTime[i];
    fuseBurnState.burnTime[i] = fuseBurnState.burnTime[j];
    fuseBurnState.burnTime[j] = tempT2;
    
    const tempL = fuseBurnState.lastSpread[i];
    fuseBurnState.lastSpread[i] = fuseBurnState.lastSpread[j];
    fuseBurnState.lastSpread[j] = tempL;
    
    const tempE = electricalCharge[i];
    electricalCharge[i] = electricalCharge[j];
    electricalCharge[j] = tempE;
    
    const tempR = radiationLevel[i];
    radiationLevel[i] = radiationLevel[j];
    radiationLevel[j] = tempR;
    
    const tempMF = magneticField[i];
    magneticField[i] = magneticField[j];
    magneticField[j] = tempMF;
    
    const tempMP = magneticPolarity[i];
    magneticPolarity[i] = magneticPolarity[j];
    magneticPolarity[j] = tempMP;
}

function checkWaterOilReaction(x, y) {
    const i = idx(x, y);
    const elemId = grid[i];
    
    if (elemId !== ELEMENTS.WATER.id) return;
    
    const neighbors = [
        [x, y + 1], [x, y - 1], [x + 1, y], [x - 1, y]
    ];
    
    for (const [nx, ny] of neighbors) {
        if (inBounds(nx, ny)) {
            const ni = idx(nx, ny);
            if (grid[ni] === ELEMENTS.OIL.id && Math.random() < 0.15) {
                grid[i] = ELEMENTS.OIL.id;
                return;
            }
        }
    }
}

function checkSodiumWaterReaction(x, y) {
    const i = idx(x, y);
    const elemId = grid[i];
    
    if (elemId !== ELEMENTS.SODIUM.id) return;
    
    const neighbors = [
        [x, y + 1], [x, y - 1], [x + 1, y], [x - 1, y]
    ];
    
    for (const [nx, ny] of neighbors) {
        if (inBounds(nx, ny)) {
            const ni = idx(nx, ny);
            if (grid[ni] === ELEMENTS.WATER.id) {
                grid[i] = ELEMENTS.FIRE.id;
                grid[ni] = ELEMENTS.FIRE.id;
                
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        const tx = x + dx, ty = y + dy;
                        if (!inBounds(tx, ty)) continue;
                        const ti = idx(tx, ty);
                        if (grid[ti] === 0) {
                            grid[ti] = ELEMENTS.FIRE.id;
                        }
                    }
                }
                return;
            }
        }
    }
}

function checkSuperAcidReaction(x, y) {
    const i = idx(x, y);
    const elemId = grid[i];
    
    if (elemId !== ELEMENTS.SUPER_ACID.id) return;
    
    const neighbors = [
        [x, y + 1], [x, y - 1], [x + 1, y], [x - 1, y]
    ];
    
    for (const [nx, ny] of neighbors) {
        if (inBounds(nx, ny)) {
            const ni = idx(nx, ny);
            const neighborId = grid[ni];
            
            if (neighborId === ELEMENTS.WATER.id && Math.random() < 0.3) {
                grid[ni] = ELEMENTS.ACID.id;
                grid[i] = 0;
                return;
            }
            
            if (neighborId === ELEMENTS.ACID.id) {
                continue;
            }
            
            if (neighborId !== 0 && neighborId !== ELEMENTS.AIR.id &&
                neighborId !== ELEMENTS.BEDROCK.id && neighborId !== ELEMENTS.SUPER_ACID.id) {
                const neighbor = getElById(neighborId);
                if (neighbor && !neighbor.indestructible) {
                    if (Math.random() < 0.8) {
                        grid[ni] = 0;
                        if (neighborId === ELEMENTS.PLANT.id ||
                            neighborId === ELEMENTS.VINE.id ||
                            neighborId === ELEMENTS.LEAF.id ||
                            neighborId === ELEMENTS.FLOWER.id ||
                            neighborId === ELEMENTS.SEED.id) {
                            removeGrowthRecords(ni);
                        }
                    }
                }
            }
        }
    }
}

function checkAcidReaction(x, y) {
    const i = idx(x, y);
    const elemId = grid[i];
    
    if (elemId !== ELEMENTS.ACID.id) return;
    
    const neighbors = [
        [x, y + 1], [x, y - 1], [x + 1, y], [x - 1, y]
    ];
    
    for (const [nx, ny] of neighbors) {
        if (inBounds(nx, ny)) {
            const ni = idx(nx, ny);
            const neighborId = grid[ni];
            
            if (neighborId === ELEMENTS.WALL.id) continue;
            
            if (neighborId !== 0 && neighborId !== ELEMENTS.AIR.id &&
                neighborId !== ELEMENTS.ACID.id && neighborId !== ELEMENTS.SUPER_ACID.id) {
                const neighbor = getElById(neighborId);
                if (neighbor && !neighbor.indestructible) {
                    // 考虑酸抗性
                    const acidResistance = neighbor.acidResistance || 0;
                    if (Math.random() < 0.05 * (1 - acidResistance)) {
                        grid[ni] = 0;
                        if (neighborId === ELEMENTS.PLANT.id ||
                            neighborId === ELEMENTS.VINE.id ||
                            neighborId === ELEMENTS.LEAF.id ||
                            neighborId === ELEMENTS.FLOWER.id ||
                            neighborId === ELEMENTS.SEED.id) {
                            removeGrowthRecords(ni);
                        }
                        if (Math.random() < 0.2) {
                            grid[i] = 0;
                        }
                    }
                }
            }
        }
    }
}

function checkSeedGrowth(x, y) {
    const i = idx(x, y);
    
    if (grid[i] !== ELEMENTS.SEED.id) return;
    
    const below = idx(x, y + 1);
    if (y + 1 < height && (grid[below] === ELEMENTS.SAND.id ||
        grid[below] === ELEMENTS.PLANT.id ||
        grid[below] === ELEMENTS.VINE.id ||
        grid[below] === ELEMENTS.STONE.id)) {
        const existingIdx = seedGrowth.positions.indexOf(i);
        if (existingIdx === -1) {
            seedGrowth.positions.push(i);
            seedGrowth.heights.push(0);
            seedGrowth.directions.push(0);
            seedGrowth.maxHeights.push(8 + Math.floor(Math.random() * (GROWTH_LIMITS.MAX_SEED_GROWTH_HEIGHT - 8 + 1)));
            seedGrowth.growthTime.push(performance.now());
        }
    }
}

function updateSeedGrowth(now) {
    for (let j = 0; j < seedGrowth.positions.length; j++) {
        const pos = seedGrowth.positions[j];
        const lastTime = seedGrowth.growthTime[j];
        const currentHeight = seedGrowth.heights[j];
        const currentDir = seedGrowth.directions[j];
        const maxHeight = seedGrowth.maxHeights[j];
        
        if (now - lastTime >= SEED_GROW_INTERVAL && currentHeight < maxHeight) {
            const x = pos % width;
            const y = Math.floor(pos / width);
            
            if (y - currentHeight < 0) {
                seedGrowth.heights[j] = maxHeight;
                continue;
            }
            
            const growY = y - currentHeight - 1;
            
            if (growY >= 0) {
                const growIdx = idx(x, growY);
                
                let newDir = currentDir;
                if (Math.random() < 0.3) {
                    newDir = Math.floor(Math.random() * 3) - 1;
                }
                
                const newX = Math.max(0, Math.min(width - 1, x + newDir));
                const finalGrowIdx = idx(newX, growY);
                
                if (grid[finalGrowIdx] === 0) {
                    if (Math.random() < 0.7) {
                        grid[finalGrowIdx] = ELEMENTS.PLANT.id;
                    } else {
                        grid[finalGrowIdx] = ELEMENTS.VINE.id;
                    }
                    
                    seedGrowth.heights[j] = currentHeight + 1;
                    seedGrowth.directions[j] = newDir;
                    seedGrowth.growthTime[j] = now;
                    
                    if (Math.random() < 0.2 && currentHeight > 3) {
                        const leafDir = Math.random() > 0.5 ? 1 : -1;
                        const leafX = Math.max(0, Math.min(width - 1, newX + leafDir));
                        const leafIdx = idx(leafX, growY);
                        if (grid[leafIdx] === 0) {
                            grid[leafIdx] = ELEMENTS.LEAF.id;
                        }
                    }
                    
                    if (seedGrowth.heights[j] === maxHeight) {
                        grid[finalGrowIdx] = ELEMENTS.FLOWER.id;
                        seedGrowth.positions.splice(j, 1);
                        seedGrowth.heights.splice(j, 1);
                        seedGrowth.directions.splice(j, 1);
                        seedGrowth.maxHeights.splice(j, 1);
                        seedGrowth.growthTime.splice(j, 1);
                        j--;
                    }
                }
            }
        }
    }
}

function checkLifeElement(x, y) {
    const i = idx(x, y);
    
    if (grid[i] !== ELEMENTS.LIFE.id) return;
    
    const existingIdx = lifeElements.positions.indexOf(i);
    if (existingIdx === -1) {
        lifeElements.positions.push(i);
        lifeElements.lastMoveTime.push(performance.now());
        lifeElements.directions.push(Math.floor(Math.random() * 3) - 1);
        lifeElements.hunger.push(LIFE_MAX_HUNGER / 2);
        lifeElements.age.push(0);
        lifeElements.health.push(LIFE_MAX_HEALTH);
    }
}

function updateLifeElements(now) {
    for (let j = 0; j < lifeElements.positions.length; j++) {
        const pos = lifeElements.positions[j];
        const lastTime = lifeElements.lastMoveTime[j];
        let dir = lifeElements.directions[j];
        let hunger = lifeElements.hunger[j];
        let age = lifeElements.age[j];
        let health = lifeElements.health[j];
        
        if (grid[pos] !== ELEMENTS.LIFE.id) {
            lifeElements.positions.splice(j, 1);
            lifeElements.lastMoveTime.splice(j, 1);
            lifeElements.directions.splice(j, 1);
            lifeElements.hunger.splice(j, 1);
            lifeElements.age.splice(j, 1);
            lifeElements.health.splice(j, 1);
            j--;
            continue;
        }
        
        const elem = ELEMENTS.LIFE;
        const hungerRate = elem.hungerRate || 0.5;
        const moveInterval = elem.moveInterval || 100;
        const breedChance = elem.breedChance || 0.05;
        
        age += 1;
        if (age > (elem.life || LIFE_MAX_AGE)) {
            grid[pos] = 0;
            lifeElements.positions.splice(j, 1);
            lifeElements.lastMoveTime.splice(j, 1);
            lifeElements.directions.splice(j, 1);
            lifeElements.hunger.splice(j, 1);
            lifeElements.age.splice(j, 1);
            lifeElements.health.splice(j, 1);
            j--;
            continue;
        }
        
        hunger -= hungerRate;
        if (hunger <= 0) {
            grid[pos] = 0;
            lifeElements.positions.splice(j, 1);
            lifeElements.lastMoveTime.splice(j, 1);
            lifeElements.directions.splice(j, 1);
            lifeElements.hunger.splice(j, 1);
            lifeElements.age.splice(j, 1);
            lifeElements.health.splice(j, 1);
            j--;
            continue;
        }
        
        if (now - lastTime >= moveInterval) {
            const x = pos % width;
            const y = Math.floor(pos / width);
            
            const neighbors = [
                [x, y + 1],
                [x, y - 1],
                [x + 1, y],
                [x - 1, y]
            ];
            
            let atePlant = false;
            for (const [nx, ny] of neighbors) {
                if (inBounds(nx, ny)) {
                    const ni = idx(nx, ny);
                    const elemId = grid[ni];
                    if (elemId === ELEMENTS.PLANT.id ||
                        elemId === ELEMENTS.FLOWER.id ||
                        elemId === ELEMENTS.VINE.id ||
                        elemId === ELEMENTS.LEAF.id ||
                        elemId === ELEMENTS.SEED.id) {
                        grid[ni] = 0;
                        const seedIdx = seedGrowth.positions.indexOf(ni);
                        if (seedIdx !== -1) {
                            seedGrowth.positions.splice(seedIdx, 1);
                            seedGrowth.heights.splice(seedIdx, 1);
                            seedGrowth.directions.splice(seedIdx, 1);
                            seedGrowth.maxHeights.splice(seedIdx, 1);
                            seedGrowth.growthTime.splice(seedIdx, 1);
                        }
                        hunger = Math.min(LIFE_MAX_HUNGER, hunger + 30);
                        atePlant = true;
                        break;
                    }
                }
            }
            
            if (!atePlant) {
                if (Math.random() < 0.3) {
                    dir = Math.floor(Math.random() * 3) - 1;
                    lifeElements.directions[j] = dir;
                }
                
                const moveX = Math.max(0, Math.min(width - 1, x + dir));
                const moveIdx = idx(moveX, y);
                
                if (grid[moveIdx] === 0) {
                    grid[pos] = 0;
                    grid[moveIdx] = ELEMENTS.LIFE.id;
                    lifeElements.positions[j] = moveIdx;
                    
                    if (Math.random() < breedChance && hunger > LIFE_MAX_HUNGER * 0.7) {
                        const breedSpots = [];
                        const breedOffsets = [
                            [0, 1], [0, -1], [1, 0], [-1, 0]
                        ];
                        
                        for (const [dx, dy] of breedOffsets) {
                            const bx = moveX + dx;
                            const by = y + dy;
                            if (inBounds(bx, by)) {
                                const bi = idx(bx, by);
                                if (grid[bi] === 0) {
                                    breedSpots.push([bx, by, bi]);
                                }
                            }
                        }
                        
                        if (breedSpots.length > 0) {
                            const randomSpot = breedSpots[Math.floor(Math.random() * breedSpots.length)];
                            const [bx, by, bi] = randomSpot;
                            grid[bi] = ELEMENTS.LIFE.id;
                            hunger -= 20;
                            
                            lifeElements.positions.push(bi);
                            lifeElements.lastMoveTime.push(now);
                            lifeElements.directions.push(Math.floor(Math.random() * 3) - 1);
                            lifeElements.hunger.push(LIFE_MAX_HUNGER * 0.5);
                            lifeElements.age.push(0);
                            lifeElements.health.push(LIFE_MAX_HEALTH);
                        }
                    }
                } else {
                    const tryUp = y - 1 >= 0 ? idx(moveX, y - 1) : -1;
                    const tryDown = y + 1 < height ? idx(moveX, y + 1) : -1;
                    
                    if (tryUp !== -1 && grid[tryUp] === 0) {
                        grid[pos] = 0;
                        grid[tryUp] = ELEMENTS.LIFE.id;
                        lifeElements.positions[j] = tryUp;
                    } else if (tryDown !== -1 && grid[tryDown] === 0) {
                        grid[pos] = 0;
                        grid[tryDown] = ELEMENTS.LIFE.id;
                        lifeElements.positions[j] = tryDown;
                    }
                }
            }
            
            lifeElements.hunger[j] = hunger;
            lifeElements.age[j] = age;
            lifeElements.health[j] = health;
            lifeElements.lastMoveTime[j] = now;
        }
    }
}

function checkCloneElement(x, y) {
    const i = idx(x, y);
    
    if (grid[i] !== ELEMENTS.CLONE.id) return;
    
    const existingIdx = cloneElements.positions.indexOf(i);
    if (existingIdx === -1) {
        cloneElements.positions.push(i);
        cloneElements.lastCopyTime.push(performance.now());
        cloneElements.targetElements.push(0);
        cloneElements.copyCount.push(0);
    }
}

function updateCloneElements(now) {
    for (let j = 0; j < cloneElements.positions.length; j++) {
        const pos = cloneElements.positions[j];
        const lastTime = cloneElements.lastCopyTime[j];
        let targetElement = cloneElements.targetElements[j];
        const copyCount = cloneElements.copyCount[j];
        
        if (grid[pos] !== ELEMENTS.CLONE.id) {
            cloneElements.positions.splice(j, 1);
            cloneElements.lastCopyTime.splice(j, 1);
            cloneElements.targetElements.splice(j, 1);
            cloneElements.copyCount.splice(j, 1);
            j--;
            continue;
        }
        
        const elem = ELEMENTS.CLONE;
        const maxCopyCount = elem.maxCopyCount || 50;
        const copyInterval = elem.copyInterval || 100;
        
        if (copyCount >= maxCopyCount) {
            cloneElements.positions.splice(j, 1);
            cloneElements.lastCopyTime.splice(j, 1);
            cloneElements.targetElements.splice(j, 1);
            cloneElements.copyCount.splice(j, 1);
            j--;
            continue;
        }
        
        if (now - lastTime >= copyInterval) {
            const x = pos % width;
            const y = Math.floor(pos / width);
            
            if (targetElement === 0) {
                const neighbors = [
                    [x, y + 1],
                    [x, y - 1],
                    [x + 1, y],
                    [x - 1, y],
                    [x + 1, y + 1],
                    [x - 1, y + 1],
                    [x + 1, y - 1],
                    [x - 1, y - 1]
                ];
                
                const nearbyElements = [];
                for (const [nx, ny] of neighbors) {
                    if (inBounds(nx, ny)) {
                        const ni = idx(nx, ny);
                        const elemId = grid[ni];
                        if (elemId !== 0 && elemId !== ELEMENTS.CLONE.id && elemId !== ELEMENTS.ERASER.id) {
                            nearbyElements.push(elemId);
                        }
                    }
                }
                
                if (nearbyElements.length > 0) {
                    targetElement = nearbyElements[Math.floor(Math.random() * nearbyElements.length)];
                    cloneElements.targetElements[j] = targetElement;
                } else {
                    cloneElements.lastCopyTime[j] = now;
                    continue;
                }
            }
            
            const emptySpots = [];
            const neighborOffsets = [
                [0, 1],
                [0, -1],
                [1, 0],
                [-1, 0],
                [1, 1],
                [-1, 1],
                [1, -1],
                [-1, -1]
            ];
            
            for (const [dx, dy] of neighborOffsets) {
                const nx = x + dx;
                const ny = y + dy;
                if (inBounds(nx, ny)) {
                    const ni = idx(nx, ny);
                    if (grid[ni] === 0 ||
                        grid[ni] === ELEMENTS.SMOKE.id ||
                        grid[ni] === ELEMENTS.GAS_FUEL.id) {
                        emptySpots.push([nx, ny, ni]);
                    }
                }
            }
            
            if (emptySpots.length > 0) {
                const numCopies = Math.min(emptySpots.length, Math.floor(Math.random() * 3) + 1);
                
                for (let k = 0; k < numCopies; k++) {
                    if (emptySpots.length === 0) break;
                    
                    const randomIndex = Math.floor(Math.random() * emptySpots.length);
                    const [copyX, copyY, copyIdx] = emptySpots[randomIndex];
                    
                    grid[copyIdx] = targetElement;
                    
                    emptySpots.splice(randomIndex, 1);
                    
                    cloneElements.copyCount[j]++;
                    
                    if (targetElement === ELEMENTS.SEED.id) {
                        checkSeedGrowth(copyX, copyY);
                    }
                    
                    if (targetElement === ELEMENTS.LIFE.id) {
                        checkLifeElement(copyX, copyY);
                    }
                }
                
                cloneElements.lastCopyTime[j] = now;
            } else {
                cloneElements.lastCopyTime[j] = now;
            }
        }
    }
}

function removeGrowthRecords(index) {
    const seedIdx = seedGrowth.positions.indexOf(index);
    if (seedIdx !== -1) {
        seedGrowth.positions.splice(seedIdx, 1);
        seedGrowth.heights.splice(seedIdx, 1);
        seedGrowth.directions.splice(seedIdx, 1);
        seedGrowth.maxHeights.splice(seedIdx, 1);
        seedGrowth.growthTime.splice(seedIdx, 1);
    }
    
    const lifeIdx = lifeElements.positions.indexOf(index);
    if (lifeIdx !== -1) {
        lifeElements.positions.splice(lifeIdx, 1);
        lifeElements.lastMoveTime.splice(lifeIdx, 1);
        lifeElements.directions.splice(lifeIdx, 1);
        lifeElements.hunger.splice(lifeIdx, 1);
        lifeElements.age.splice(lifeIdx, 1);
        lifeElements.health.splice(lifeIdx, 1);
    }
    
    const cloneIdx = cloneElements.positions.indexOf(index);
    if (cloneIdx !== -1) {
        cloneElements.positions.splice(cloneIdx, 1);
        cloneElements.lastCopyTime.splice(cloneIdx, 1);
        cloneElements.targetElements.splice(cloneIdx, 1);
        cloneElements.copyCount.splice(cloneIdx, 1);
    }
    
    fuseBurnState.burning[index] = 0;
    fuseBurnState.burnTime[index] = 0;
    fuseBurnState.lastSpread[index] = 0;
    
    metalOxidation[index] = 0;
    metalOxidationProgress[index] = 0;
    ironWaterReaction[index] = 0;
    
    electricalCharge[index] = 0;
    radiationLevel[index] = 0;
    magneticField[index] = 0;
    magneticPolarity[index] = 0;
}

function doExplode(cx, cy, r, strength) {
    explosionPropagationGrid.fill(0);
    explodeAt(cx, cy, r, strength, 0);
}

function explodeAt(cx, cy, r, strength, depth) {
    if (depth > 5) return;
    
    const i = idx(cx, cy);
    if (explosionPropagationGrid[i] > 0) return;
    explosionPropagationGrid[i] = 1;
    
    addShockWave(cx, cy, r, strength);
    
    for (let dy = -r; dy <= r; dy++) {
        for (let dx = -r; dx <= r; dx++) {
            const tx = cx + dx, ty = cy + dy;
            if (!inBounds(tx, ty)) continue;
            const d2 = dx * dx + dy * dy;
            if (d2 > r * r) continue;
            
            const ti = idx(tx, ty);
            const target = grid[ti];
            const tgtEl = getElById(target);
            
            if (!tgtEl) continue;
            
            if (target === ELEMENTS.WALL.id) { 
                grid[ti] = ELEMENTS.STONE.id; 
                continue; 
            }
            
            if (target === 0 || tgtEl.type === TYPES.LIQUID || tgtEl.type === TYPES.POWDER || tgtEl.type === TYPES.GAS) {
                if (grid[ti] === 0) {
                    if (Math.random() < 0.3) {
                        grid[ti] = ELEMENTS.FIRE.id;
                    }
                } else {
                    const vx = (dx + Math.random() * 0.4 - 0.2) * 0.8;
                    const vy = (dy + Math.random() * 0.4 - 0.2) * 0.8 - 1;
                    sparks.push(new Spark(tx, ty, vx, vy, target));
                    grid[ti] = 0;
                }
                
                removeGrowthRecords(ti);
            }
            
            if (tgtEl.explosive && explosionPropagationGrid[ti] === 0) {
                const chainStrength = strength * 0.7;
                const chainRadius = Math.max(2, r - 1);
                setTimeout(() => {
                    explodeAt(tx, ty, chainRadius, chainStrength, depth + 1);
                }, 10);
            }
        }
    }
}

function addShockWave(cx, cy, r, strength) {
    const r2 = r * r;
    for (let dy = -r; dy <= r; dy++) {
        for (let dx = -r; dx <= r; dx++) {
            const tx = cx + dx, ty = cy + dy;
            if (!inBounds(tx, ty)) continue;
            const d2 = dx * dx + dy * dy;
            if (d2 > r2) continue;
            const i = idx(tx, ty);
            const s = Math.floor(strength * (1 - Math.sqrt(d2) / r));
            shockWave[i] = Math.min(255, shockWave[i] + s);
            
            const elemId = grid[i];
            if (elemId === ELEMENTS.STONE.id) {
                grid[i] = ELEMENTS.SAND.id;

                const force = strength * (1 - Math.sqrt(d2) / r) * 0.1;
                const angle = Math.atan2(dy, dx) + (Math.random() - 0.5) * 0.5;
                const vx = Math.cos(angle) * force;
                const vy = Math.sin(angle) * force - 1.5;

                flyingStones.positions.push([tx, ty]);
                flyingStones.velocitiesX.push(vx);
                flyingStones.velocitiesY.push(vy);
                flyingStones.timestamps.push(performance.now());
            }
        }
    }
}

function decayShockWave() {
    for (let i = 0; i < shockWave.length; i++) {
        if (shockWave[i] > 0) {
            shockWave[i] = Math.max(0, shockWave[i] - 8);
        }
    }
}

function updateFlyingStones() {
    for (let i = flyingStones.positions.length - 1; i >= 0; i--) {
        const now = performance.now();
        const elapsed = now - flyingStones.timestamps[i];

        if (elapsed > FLYING_STONE_TTL) {
            const [x, y] = flyingStones.positions[i];
            const ix = Math.floor(x);
            const iy = Math.floor(y);
            if (inBounds(ix, iy)) {
                const idxPos = idx(ix, iy);
                if (grid[idxPos] === 0) {
                    grid[idxPos] = ELEMENTS.SAND.id;
                }
            }

            flyingStones.positions.splice(i, 1);
            flyingStones.velocitiesX.splice(i, 1);
            flyingStones.velocitiesY.splice(i, 1);
            flyingStones.timestamps.splice(i, 1);
            continue;
        }

        let [x, y] = flyingStones.positions[i];
        let vx = flyingStones.velocitiesX[i];
        let vy = flyingStones.velocitiesY[i];

        vy += 0.2;

        x += vx;
        y += vy;

        if (x < 0 || x >= width || y >= height) {
            const ix = Math.max(0, Math.min(width - 1, Math.floor(x)));
            const iy = Math.max(0, Math.min(height - 1, Math.floor(y)));
            if (inBounds(ix, iy)) {
                const idxPos = idx(ix, iy);
                if (grid[idxPos] === 0) {
                    grid[idxPos] = ELEMENTS.SAND.id;
                }
            }

            flyingStones.positions.splice(i, 1);
            flyingStones.velocitiesX.splice(i, 1);
            flyingStones.velocitiesY.splice(i, 1);
            flyingStones.timestamps.splice(i, 1);
            continue;
        }

        const ix = Math.floor(x);
        const iy = Math.floor(y);
        if (inBounds(ix, iy)) {
            const idxPos = idx(ix, iy);
            const elemId = grid[idxPos];

            if (elemId !== 0 && elemId !== ELEMENTS.AIR.id) {
                grid[idxPos] = ELEMENTS.SAND.id;

                flyingStones.positions.splice(i, 1);
                flyingStones.velocitiesX.splice(i, 1);
                flyingStones.velocitiesY.splice(i, 1);
                flyingStones.timestamps.splice(i, 1);
                continue;
            }
        }

        flyingStones.positions[i] = [x, y];
        flyingStones.velocitiesX[i] = vx;
        flyingStones.velocitiesY[i] = vy;
    }
}

function update() {
    if (isPaused) return;
    
    const now = performance.now();
    
    updateTemperature();
    updateMetalOxidationSystem();
    updateMagnesiumBurn(now);
    decayShockWave();
    
    // 更新特殊物理系统
    updateElectricalConduction();
    updateRadioactivity();
    updateMagnetism();
    
    for (let i = sparks.length - 1; i >= 0; i--) {
        if (sparks[i].update()) sparks.splice(i, 1);
    }
    
    updateFlyingStones();
    updateSeedGrowth(now);
    updateLifeElements(now);
    updateCloneElements(now);
    updatePhysics(now);
    postFreezeGravity();
    
    draw();
    animationId = requestAnimationFrame(update);
}

function updateMetalOxidationSystem() {
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const i = idx(x, y);
            const elemId = grid[i];
            
            if (elemId === ELEMENTS.IRON.id || elemId === ELEMENTS.IRON_LIQUID.id) {
                updateIronWaterReaction(x, y);
            }
            
            updateMetalOxidation(x, y);
        }
    }
}

function updatePhysics(now) {
    const startRow = height - 1;
    const endRow = -1;
    const stepRow = -1;

    for (let y = startRow; y !== endRow; y += stepRow) {
        const scanLeft = Math.random() > 0.5;
        const startX = scanLeft ? 0 : width - 1;
        const endX = scanLeft ? width : -1;
        const stepX = scanLeft ? 1 : -1;

        for (let x = startX; x !== endX; x += stepX) {
            const i = idx(x, y);
            const id = grid[i];
            if (id === 0) continue;

            const el = getElById(id);
            if (!el) continue;

            if (el.indestructible || el.type === TYPES.INDESTRUCTIBLE) {
                continue;
            }

            checkWaterOilReaction(x, y);
            checkSodiumWaterReaction(x, y);
            checkSuperAcidReaction(x, y);
            checkAcidReaction(x, y);
            
            // 密度浮力系统
            updateDensityBuoyancy(x, y, i);
            
            if (el.id === ELEMENTS.SEED.id) {
                checkSeedGrowth(x, y);
            }
            
            if (el.id === ELEMENTS.LIFE.id) {
                checkLifeElement(x, y);
            }
            
            if (el.id === ELEMENTS.CLONE.id) {
                checkCloneElement(x, y);
            }
            
            if (el.id === ELEMENTS.FUSE.id) {
                updateFuse(x, y, i, el, now);
                continue;
            }
            
            if (el.explosive && temperatureSystemEnabled) {
                const temp = temperatures[i];
                if (temp > (el.ignitesAt || 150)) {
                    doExplode(x, y, el.explosivePower || 4, 180);
                    continue;
                }
            }
            
            if (el.explosive) {
                const aroundLava = [[0, 1], [0, -1], [1, 0], [-1, 0]].some(([dx, dy]) => {
                    const ni = idx(x + dx, y + dy);
                    return inBounds(x + dx, y + dy) && grid[ni] === ELEMENTS.LAVA.id;
                });
                
                if (aroundLava) {
                    doExplode(x, y, el.explosivePower || 4, 180);
                    continue;
                }
            }
            
            if (el.id === ELEMENTS.FIRE.id) {
                updateFireImproved(x, y, i);
                continue;
            }
            
            if (el.id === ELEMENTS.SMOKE.id) {
                updateSmokeImproved(x, y, i);
                continue;
            }
            
            if (el.acidity) {
                updateLiquid(x, y, i, el);
                continue;
            }
            
            if (el.id === ELEMENTS.GAS_FUEL.id) {
                updateFuelGasImproved(x, y, i);
                continue;
            }
            
            if (el.meltable) {
                const aroundHot = [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [-1, 1], [1, -1], [-1, -1]].some(([dx, dy]) => {
                    const ni = idx(x + dx, y + dy);
                    if (!inBounds(x + dx, y + dy)) return false;
                    const neighbor = getElById(grid[ni]);
                    return neighbor && (neighbor.id === ELEMENTS.FIRE.id || neighbor.id === ELEMENTS.LAVA.id);
                });
                if (aroundHot && Math.random() < 0.05) {
                    grid[i] = el.meltTo ? ELEMENTS[el.meltTo].id : ELEMENTS.WATER.id;
                    continue;
                }
            }
            
            if (el.id === ELEMENTS.LAVA.id) {
                updateLava(x, y, i);
                continue;
            }
            
            if (el.id === ELEMENTS.STONE.id) {
                updateStone(x, y, i);
                continue;
            }
            
            if (el.id === ELEMENTS.STEAM.id) {
                updateSteamImproved(x, y, i);
                continue;
            }
            
            if (el.type === TYPES.METAL_SOLID) {
                updateMetalSolid(x, y, i, el);
                continue;
            }
            
            if (el.type === TYPES.METAL_LIQUID) {
                updateMetalLiquid(x, y, i, el);
                continue;
            }
            
            switch(el.type) {
                case TYPES.POWDER:
                    updatePowder(x, y, i, el);
                    break;
                case TYPES.LIQUID:
                case TYPES.ACID:
                    updateLiquid(x, y, i, el);
                    break;
                case TYPES.GAS:
                    updateGasImproved(x, y, i, el);
                    break;
                case TYPES.SOLID:
                    // 固体不移动
                    break;
            }
        }
    }
}

function updateTemperature() {
    enforceGlobalFreeze();
    
    if (!temperatureSystemEnabled) return;
    
    const transferRate = heatTransferSpeed * 0.02;
    const ambientEffect = 0.01;
    
    const newTemps = new Float32Array(temperatures);
    
    for (let i = 0; i < grid.length; i++) {
        if (grid[i] === 0) continue;
        
        const x = i % width;
        const y = Math.floor(i / width);
        const elem = getElById(grid[i]);
        if (!elem) continue;
        
        if (elem.heatResistance >= 0.95) continue;
        
        const currentTemp = temperatures[i];
        let totalTemp = 0;
        let neighborCount = 0;
        
        const neighbors = [
            idx(x, y - 1), idx(x, y + 1),
            idx(x - 1, y), idx(x + 1, y)
        ];
        
        for (const ni of neighbors) {
            if (ni !== -1 && ni >= 0 && ni < grid.length) {
                const neighborElem = getElById(grid[ni]);
                if (neighborElem && neighborElem.heatResistance < 0.95) {
                    totalTemp += temperatures[ni];
                    neighborCount++;
                }
            }
        }
        
        if (neighborCount > 0) {
            const avgTemp = totalTemp / neighborCount;
            const tempDiff = avgTemp - currentTemp;
            const heatTransfer = tempDiff * transferRate * (1 - elem.heatResistance);
            
            newTemps[i] += heatTransfer;
        }
        
        newTemps[i] += (ambientTemperature - newTemps[i]) * ambientEffect;
        
        if (elem.heatEmission) {
            newTemps[i] += elem.heatEmission * 0.1;
        }
        
        applyTemperatureEffects(i, x, y, newTemps[i]);
    }
    
    temperatures.set(newTemps);
    
    for (let i = 0; i < temperatures.length; i++) {
        if (temperatures[i] < -273) temperatures[i] = -273;
        if (temperatures[i] > 5000) temperatures[i] = 5000;
    }
}

function updateMagnesiumBurn(now) {
    for (let i = 0; i < grid.length; i++) {
        if (grid[i] === ELEMENTS.MAGNESIUM.id || grid[i] === ELEMENTS.MAGNESIUM_LIQUID.id) {
            const temp = temperatures[i];
            const elem = getElById(grid[i]);
            
            if (elem.ignitesAt && temp > elem.ignitesAt) {
                if (magnesiumBurn[i] === 0) {
                    magnesiumBurn[i] = 1;
                }
                
                if (Math.random() < 0.1) {
                    const x = i % width;
                    const y = Math.floor(i / width);
                    addShockWave(x, y, 2, 50);
                }
                
                if (Math.random() < 0.01) {
                    grid[i] = 0;
                    magnesiumBurn[i] = 0;
                }
            } else {
                magnesiumBurn[i] = 0;
            }
        }
    }
}

function enforceGlobalFreeze() {
    if (!temperatureSystemEnabled || ambientTemperature >= -50) return;
    
    for (let i = 0; i < grid.length; i++) {
        const id = grid[i];
        if (id === ELEMENTS.WATER.id || id === ELEMENTS.STEAM.id) {
            grid[i] = ELEMENTS.ICE.id;
            temperatures[i] = ambientTemperature;
        }
    }
}

function postFreezeGravity() {
    if (!temperatureSystemEnabled || ambientTemperature > -273) return;
    
    const h = height, w = width;
    for (let y = h - 2; y >= 0; y--) {
        for (let x = 0; x < w; x++) {
            const i = idx(x, y);
            const id = grid[i];
            if (id === 0) continue;
            
            const el = getElById(id);
            if (!el || (el.type !== TYPES.LIQUID && el.type !== TYPES.GAS)) continue;
            
            const below = idx(x, y + 1);
            if (y + 1 < h && grid[below] === 0) {
                grid[i] = 0;
                grid[below] = id;
                temperatures[below] = temperatures[i];
                temperatures[i] = ambientTemperature;
            }
        }
    }
}

function applyTemperatureEffects(i, x, y, temp) {
    const elemId = grid[i];
    const elem = getElById(elemId);
    if (!elem) return;
    
    // 冰->水
    if (elemId === ELEMENTS.ICE.id && elem.meltsAt && temp > elem.meltsAt) {
        if (Math.random() < 0.01) {
            grid[i] = elem.meltTo ? ELEMENTS[elem.meltTo].id : ELEMENTS.WATER.id;
            temperatures[i] = Math.max(temp, 5);
        }
        return;
    }
    
    // 水->冰
    if (elemId === ELEMENTS.WATER.id && elem.freezesAt && temp <= elem.freezesAt) {
        if (Math.random() < 0.01) {
            grid[i] = elem.freezeTo ? ELEMENTS[elem.freezeTo].id : ELEMENTS.ICE.id;
            temperatures[i] = Math.min(temp, -5);
        }
        return;
    }
    
    // 水->蒸汽（沸腾）
    if (elemId === ELEMENTS.WATER.id && elem.boilsAt && temp > elem.boilsAt) {
        if (Math.random() < 0.05) {
            grid[i] = elem.boilTo ? ELEMENTS[elem.boilTo].id : ELEMENTS.STEAM.id;
            temperatures[i] = 120;
        }
        return;
    }
    
    // 蒸汽->水（凝结）
    if (elemId === ELEMENTS.STEAM.id && elem.condensesAt && temp < elem.condensesAt) {
        if (Math.random() < 0.05) {
            grid[i] = elem.condenseTo ? ELEMENTS[elem.condenseTo].id : ELEMENTS.WATER.id;
            temperatures[i] = Math.min(temp, 95);
        }
        return;
    }
    
    // 燃烧
    if (elem.flammable && elem.ignitesAt && temp > elem.ignitesAt) {
        if (Math.random() < 0.01) {
            grid[i] = elem.burnTo ? ELEMENTS[elem.burnTo].id : ELEMENTS.FIRE.id;
            temperatures[i] = 500;
        }
        return;
    }
    
    // 沙子->玻璃
    if (elemId === ELEMENTS.SAND.id && elem.meltsAt && temp > elem.meltsAt) {
        if (Math.random() < 0.001) {
            grid[i] = elem.meltTo ? ELEMENTS[elem.meltTo].id : ELEMENTS.GLASS.id;
        }
        return;
    }
    
    // 生命元素死亡
    if (elemId === ELEMENTS.LIFE.id) {
        if ((elem.diesAt && temp > elem.diesAt) || (elem.freezeAt && temp < elem.freezeAt)) {
            if (Math.random() < 0.01) {
                grid[i] = 0;
                removeGrowthRecords(i);
            }
        }
    }
    
    // 通用熔化
    if (elem.meltsAt && temp > elem.meltsAt) {
        if (elem.meltTo && Math.random() < 0.01) {
            const meltElem = ELEMENTS[elem.meltTo];
            if (meltElem) {
                grid[i] = meltElem.id;
                temperatures[i] = elem.meltsAt + 50;
            }
        }
        return;
    }
    
    // 通用凝固
    if (elem.freezesAt && temp < elem.freezesAt) {
        if (elem.freezeTo && Math.random() < 0.01) {
            const freezeElem = ELEMENTS[elem.freezeTo];
            if (freezeElem) {
                grid[i] = freezeElem.id;
                temperatures[i] = elem.freezesAt - 50;
            }
        }
        return;
    }
    
    // 通用氧化
    if (elem.oxidizable && elem.oxidizeTo && temp > 100) {
        if (Math.random() < (elem.oxidationRate || 0.001) * (temp / 100)) {
            const oxidizeElem = ELEMENTS[elem.oxidizeTo];
            if (oxidizeElem) {
                grid[i] = oxidizeElem.id;
            }
        }
    }
}

function draw() {
    const data = imageData.data;
    
    for (let i = 0; i < data.length; i += 4) {
        data[i] = 0;
        data[i + 1] = 0;
        data[i + 2] = 0;
        data[i + 3] = 255;
    }
    
    for (let i = 0; i < grid.length; i++) {
        const id = grid[i];
        if (id === 0) continue;
        
        const el = getElById(id);
        if (!el) continue;
        
        const p = i * 4;
        let r = el.color[0] || 0;
        let g = el.color[1] || 0;
        let b = el.color[2] || 0;
        let a = el.color[3] !== undefined ? el.color[3] : 255;
        
        if (!isSmoothMode && el.variance) {
            const v = (Math.random() * el.variance - el.variance / 2);
            r = clamp(r + v);
            g = clamp(g + v);
            b = clamp(b + v);
        }
        
        // 应用金属氧化效果
        if (metalOxidation[i] > 0) {
            const oxidationIntensity = metalOxidation[i] / 255;
            const oxidationProgress = metalOxidationProgress[i] / 100;
            
            if (id === ELEMENTS.IRON.id) {
                // 铁氧化效果：变红棕色
                r = clamp(r * (1 - oxidationProgress * 0.3) + 100 * oxidationProgress);
                g = clamp(g * (1 - oxidationProgress * 0.6) + 50 * oxidationProgress);
                b = clamp(b * (1 - oxidationProgress * 0.8));
                
                // 添加铁锈斑点效果
                if (oxidationProgress > 0.5) {
                    const rustSpot = Math.sin(i * 0.1) > 0.8 ? 1 : 0;
                    if (rustSpot) {
                        r = clamp(r + 30);
                        g = clamp(g - 20);
                        b = clamp(b - 40);
                    }
                }
            } else if (id === ELEMENTS.COPPER.id) {
                // 铜氧化效果：变绿色
                r = clamp(r * (1 - oxidationProgress * 0.5));
                g = clamp(g * (1 - oxidationProgress * 0.3) + 80 * oxidationProgress);
                b = clamp(b * (1 - oxidationProgress * 0.5) + 30 * oxidationProgress);
            } else if (id === ELEMENTS.ALUMINUM.id) {
                // 铝氧化效果：变灰色
                const gray = (r + g + b) / 3;
                r = clamp(gray * (1 - oxidationProgress * 0.2) + 20 * oxidationProgress);
                g = clamp(gray * (1 - oxidationProgress * 0.2) + 20 * oxidationProgress);
                b = clamp(gray * (1 - oxidationProgress * 0.2) + 20 * oxidationProgress);
            } else if (id === ELEMENTS.SILVER.id) {
                // 银氧化效果：变黑色
                r = clamp(r * (1 - oxidationProgress * 0.8));
                g = clamp(g * (1 - oxidationProgress * 0.8));
                b = clamp(b * (1 - oxidationProgress * 0.8));
            } else if (id === ELEMENTS.MAGNESIUM.id) {
                // 镁氧化效果：变白色
                r = clamp(r + 20 * oxidationProgress);
                g = clamp(g + 20 * oxidationProgress);
                b = clamp(b + 20 * oxidationProgress);
            } else if (id === ELEMENTS.ZINC.id) {
                // 锌氧化效果：变灰色
                r = clamp(r * (1 - oxidationProgress * 0.3) + 30 * oxidationProgress);
                g = clamp(g * (1 - oxidationProgress * 0.3) + 30 * oxidationProgress);
                b = clamp(b * (1 - oxidationProgress * 0.3) + 30 * oxidationProgress);
            } else if (id === ELEMENTS.TITANIUM.id) {
                // 钛氧化效果：变金色
                r = clamp(r + 50 * oxidationProgress);
                g = clamp(g + 30 * oxidationProgress);
                b = clamp(b - 20 * oxidationProgress);
            }
        }
        
        if (ironWaterReaction[i] > 0) {
            // 铁水反应效果：变得更红
            const reactionIntensity = ironWaterReaction[i] / 255;
            r = clamp(r + 50 * reactionIntensity);
            g = clamp(g - 30 * reactionIntensity);
            b = clamp(b - 40 * reactionIntensity);
        }
        
        if ((id === ELEMENTS.MAGNESIUM.id || id === ELEMENTS.MAGNESIUM_LIQUID.id) && magnesiumBurn[i] > 0) {
            const burnIntensity = magnesiumBurn[i];
            r = clamp(r + 100 * burnIntensity);
            g = clamp(g + 50 * burnIntensity);
            b = clamp(b - 50 * burnIntensity);
        }
        
        if (id === ELEMENTS.FUSE.id && fuseBurnState.burning[i] === 1) {
            const elem = getElById(id);
            const burnProgress = fuseBurnState.burnTime[i] / (elem.burnDuration || 60);
            r = clamp(255);
            g = clamp(100 + 50 * (1 - burnProgress));
            b = clamp(50 * (1 - burnProgress));
            const flicker = Math.sin(performance.now() * 0.02 + i) * 30;
            r = clamp(r + flicker);
            g = clamp(g + flicker * 0.5);
        }
        
        if (temperatureSystemEnabled && temperatures[i] !== ambientTemperature) {
            const temp = temperatures[i];
            if (temp > 100) {
                const heatIntensity = Math.min(1, (temp - 100) / 500);
                r = clamp(r + 100 * heatIntensity);
                g = clamp(g - 50 * heatIntensity);
                b = clamp(b - 80 * heatIntensity);
            } else if (temp < 0) {
                const coldIntensity = Math.min(1, Math.abs(temp) / 50);
                r = clamp(r - 30 * coldIntensity);
                g = clamp(g + 20 * coldIntensity);
                b = clamp(b + 50 * coldIntensity);
            }
        }
        
        if (el.id === ELEMENTS.LAVA.id) {
            const pulse = Math.sin(performance.now() * 0.01) * 30;
            r = clamp(r + pulse);
            g = clamp(g + pulse * 0.5);
        }
        
        if (el.id === ELEMENTS.CLONE.id) {
            const pulse = Math.sin(performance.now() * 0.008) * 30;
            r = clamp(r + pulse);
            g = clamp(g - pulse * 0.3);
            b = clamp(b + pulse * 0.5);
        }
        
        if (shockWave[i] > 30) {
            const waveIntensity = shockWave[i] / 255;
            r = clamp(r + 255 * waveIntensity);
            g = clamp(g + 200 * waveIntensity);
            b = clamp(b + 100 * waveIntensity);
        }
        
        if (el.id === ELEMENTS.LIFE.id) {
            const pulse = Math.sin(performance.now() * 0.015 + i * 0.03) * 20;
            r = clamp(r + pulse);
            g = clamp(g - pulse * 0.5);
            b = clamp(b - pulse * 0.5);
        }
        
        if (el.explosive && temperatureSystemEnabled) {
            const temp = temperatures[i];
            if (temp > (el.ignitesAt || 150) * 0.8) {
                const danger = Math.sin(performance.now() * 0.02) * 30 + 30;
                r = clamp(r + danger);
                g = clamp(g + danger * 0.5);
            }
        }
        
        // 导电效果
        if (el.conductivity && electricalCharge[i] > 0) {
            const chargeIntensity = Math.min(1, electricalCharge[i] / 10);
            r = clamp(r + 100 * chargeIntensity);
            g = clamp(g + 150 * chargeIntensity);
            b = clamp(b + 200 * chargeIntensity);
        }
        
        // 放射性效果
        if (el.radioactivity && radiationLevel[i] > 0) {
            const radIntensity = Math.min(1, radiationLevel[i] / 5);
            r = clamp(r + 50 * radIntensity);
            g = clamp(g + 100 * radIntensity);
            b = clamp(b - 50 * radIntensity);
            const radPulse = Math.sin(performance.now() * 0.05 + i) * 20 * radIntensity;
            r = clamp(r + radPulse);
            g = clamp(g + radPulse);
        }
        
        // 磁性效果
        if (el.magnetism && magneticField[i] > 0) {
            const magIntensity = Math.min(1, magneticField[i] / 5);
            const polarity = magneticPolarity[i];
            if (polarity > 0) {
                // 北极 - 蓝色
                r = clamp(r - 30 * magIntensity);
                g = clamp(g - 30 * magIntensity);
                b = clamp(b + 50 * magIntensity);
            } else if (polarity < 0) {
                // 南极 - 红色
                r = clamp(r + 50 * magIntensity);
                g = clamp(g - 30 * magIntensity);
                b = clamp(b - 30 * magIntensity);
            }
        }
        
        data[p] = r;
        data[p + 1] = g;
        data[p + 2] = b;
        data[p + 3] = a;
    }
    
    for (let i = 0; i < flyingStones.positions.length; i++) {
        const [x, y] = flyingStones.positions[i];
        const ix = Math.floor(x);
        const iy = Math.floor(y);
        if (inBounds(ix, iy)) {
            const idxPos = idx(ix, iy);
            const p = idxPos * 4;
            data[p] = 150;
            data[p + 1] = 150;
            data[p + 2] = 150;
            data[p + 3] = 255;
        }
    }
    
    for (const s of sparks) {
        const sx = Math.floor(s.x), sy = Math.floor(s.y);
        if (inBounds(sx, sy)) {
            const i = idx(sx, sy);
            const p = i * 4;
            data[p] = 255;
            data[p + 1] = 200;
            data[p + 2] = 0;
            data[p + 3] = 255;
        }
    }
    
    for (let i = 0; i < shockWave.length; i++) {
        if (shockWave[i] > 30) {
            const px = (i % width) * 4;
            const py = Math.floor(i / width) * 4;
            const base = (py * width + px) * 4;
            const waveIntensity = shockWave[i] / 255;
            data[base] = Math.min(255, data[base] + 255 * waveIntensity);
            data[base + 1] = Math.min(255, data[base + 1] + 200 * waveIntensity);
            data[base + 2] = Math.min(255, data[base + 2] + 100 * waveIntensity);
        }
    }
    
    ctx.putImageData(imageData, 0, 0);
    
    updateFPS();
}

function updateFPS() {
    const currentTime = performance.now();
    const elapsed = currentTime - lastTime;
    
    if (elapsed >= fpsUpdateInterval) {
        fps = Math.round((frameCount * 1000) / elapsed);
        frameCount = 0;
        lastTime = currentTime;
        
        fpsDisplay.textContent = `FPS: ${fps}`;
        document.getElementById('fps-counter').textContent = `${fps} FPS`;
    }
    frameCount++;
}

const clamp = v => Math.max(0, Math.min(255, v));

function loop() {
    update();
}

// ================= UI控制函数 =================
function initUI() {
    initGrid();
    
    const quickBar = document.getElementById('quick-bar');
    const allGrid = document.getElementById('all-elements-grid');
    
    QUICK_KEYS.forEach(key => {
        const el = ELEMENTS[key];
        const btn = document.createElement('button');
        btn.className = 'chip';
        btn.dataset.key = key;
        btn.innerText = el.name;
        btn.onclick = () => selectElement(key);
        if (key === 'SAND') btn.classList.add('active');
        quickBar.appendChild(btn);
    });
    
    Object.keys(ELEMENTS).forEach(key => {
        if (key === 'AIR') return;
        const el = ELEMENTS[key];
        const card = document.createElement('div');
        card.className = 'element-card';
        card.onclick = () => selectElement(key);
        
        const dot = document.createElement('div');
        dot.className = 'element-color-dot';
        
        if (el.isEraser) {
            dot.style.background = '#fff';
            dot.style.border = '2px solid #ccc';
            dot.style.backgroundImage = 'linear-gradient(45deg, #ccc 25%, transparent 25%, transparent 75%, #ccc 75%, #ccc), linear-gradient(45deg, #ccc 25%, transparent 25%, transparent 75%, #ccc 75%, #ccc)';
            dot.style.backgroundSize = '10px 10px';
            dot.style.backgroundPosition = '0 0, 5px 5px';
        } else {
            const [r, g, b, a = 255] = el.color;
            dot.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${a / 255})`;
            
            if (el.hot) {
                dot.style.boxShadow = `0 0 8px rgba(${Math.min(r+50, 255)}, ${Math.min(g+50, 255)}, ${Math.min(b+50, 255)}, 0.8)`;
            }
            
            if (el.type === TYPES.ACID) {
                dot.style.boxShadow = `0 0 6px rgba(${r}, ${g}, ${b}, 0.6)`;
            }
            
            if (el.id === ELEMENTS.GUNPOWDER.id) {
                dot.style.boxShadow = '0 0 8px rgba(255, 200, 0, 0.8)';
                dot.style.animation = 'pulse 2s infinite';
            }
            
            if (el.id === ELEMENTS.FUSE.id) {
                dot.style.boxShadow = '0 0 8px rgba(255, 100, 0, 0.6)';
                dot.style.border = '2px solid #8B4513';
            }
            
            if (el.oxidizable) {
                dot.classList.add('oxidizable');
            }
            
            if (el.conductivity && el.conductivity > 0.5) {
                dot.style.boxShadow = `0 0 6px rgba(100, 200, 255, 0.6)`;
            }
            
            if (el.radioactivity && el.radioactivity > 0) {
                dot.style.boxShadow = `0 0 6px rgba(100, 255, 100, 0.6)`;
                dot.style.animation = 'pulse 1s infinite';
            }
            
            if (el.magnetism && el.magnetism > 0) {
                dot.style.border = `2px solid ${magneticPolarity[idx(0,0)] > 0 ? '#0000ff' : '#ff0000'}`;
            }
        }
        
        const name = document.createElement('span');
        name.style.fontSize = '14px';
        name.innerText = el.name;
        
        card.appendChild(dot);
        card.appendChild(name);
        allGrid.appendChild(card);
    });
    
    const totalElements = Object.keys(ELEMENTS).length - 1;
    document.getElementById('element-counter').textContent = `当前共有 ${totalElements} 种元素`;
    
    updateActiveState();
    
    initCheatPanel();
    loadSavedChanges();
}

function selectElement(key) {
    currentElement = ELEMENTS[key];
    updateActiveState();
    toggleSheet(false);
}

function updateActiveState() {
    const currentKey = Object.keys(ELEMENTS).find(k => ELEMENTS[k] === currentElement);
    document.querySelectorAll('.chip').forEach(chip => {
        chip.classList.toggle('active', chip.dataset.key === currentKey);
    });
}

// ================= 控制函数 =================
function togglePause() {
    isPaused = !isPaused;
    const pauseIcon = document.getElementById('pauseIcon');
    const pausedIndicator = document.getElementById('pausedIndicator');
    const btn = document.getElementById('pause-btn');
    
    if (isPaused) {
        btn.innerHTML = '<span class="material-symbols-outlined">▷</span>';
        pausedIndicator.style.display = 'block';
        cancelAnimationFrame(animationId);
    } else {
        btn.innerHTML = '<svg viewBox="0 0 24 24" id="pauseIcon"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>';
        pausedIndicator.style.display = 'none';
        loop();
    }
}

function toggleBrushShape() {
    brushShape = brushShape === '○' ? '▢' : '○';
    const btn = document.getElementById('shape-toggle');
    if (brushShape === '▢') {
        btn.innerHTML = '<span class="material-symbols-outlined" style="font-size:18px;">▢</span>';
        btn.title = "形状: 方形";
    } else {
        btn.innerHTML = '<span class="material-symbols-outlined" style="font-size:18px;">○</span>';
        btn.title = "形状: 圆形";
    }
}

function toggleGravity() {
    zeroGravity = !zeroGravity;
    const btn = document.getElementById('gravity-btn');
    if (zeroGravity) {
        btn.classList.add('active');
    } else {
        btn.classList.remove('active');
    }
}

function toggleGrid() {
    showGrid = !showGrid;
    const overlay = document.getElementById('grid-overlay');
    const btn = document.getElementById('grid-btn');
    if (showGrid) {
        overlay.classList.add('active');
        btn.classList.add('active');
    } else {
        overlay.classList.remove('active');
        btn.classList.remove('active');
    }
}

function toggleSmoothMode() {
    isSmoothMode = document.getElementById('smooth-toggle').checked;
}

function changeResolution(val) {
    canvasScale = parseInt(val);
    initGrid();
}

function clearCanvas() {
    grid.fill(0);
    sparks.length = 0;
    shockWave.fill(0);
    metalOxidation.fill(0);
    metalOxidationProgress.fill(0);
    ironWaterReaction.fill(0);
    magnesiumBurn.fill(0);
    explosionPropagationGrid.fill(0);
    
    fuseBurnState.burning.fill(0);
    fuseBurnState.burnTime.fill(0);
    fuseBurnState.lastSpread.fill(0);
    
    electricalCharge.fill(0);
    radiationLevel.fill(0);
    magneticField.fill(0);
    magneticPolarity.fill(0);
    
    seedGrowth.positions = [];
    seedGrowth.heights = [];
    seedGrowth.directions = [];
    seedGrowth.maxHeights = [];
    seedGrowth.growthTime = [];
    
    lifeElements.positions = [];
    lifeElements.lastMoveTime = [];
    lifeElements.directions = [];
    lifeElements.hunger = [];
    lifeElements.age = [];
    lifeElements.health = [];
    
    cloneElements.positions = [];
    cloneElements.lastCopyTime = [];
    cloneElements.targetElements = [];
    cloneElements.copyCount = [];
    
    flyingStones.positions = [];
    flyingStones.velocitiesX = [];
    flyingStones.velocitiesY = [];
    flyingStones.timestamps = [];
    
    if (temperatureSystemEnabled) {
        temperatures.fill(ambientTemperature);
    }
}

// ================= 温度控制函数 =================
function toggleTemperatureSystem() {
    temperatureSystemEnabled = document.getElementById('tempToggle').checked;
    tempDisplay.textContent = temperatureSystemEnabled ?
        `温度系统: 开启 (${ambientTemperature}°C)` : '温度系统: 关闭';
    
    if (!temperatureSystemEnabled) {
        temperatures.fill(ambientTemperature);
    }
}

document.getElementById('heatTransferSpeed').addEventListener('input', function() {
    heatTransferSpeed = parseInt(this.value);
    document.getElementById('heatTransferValue').textContent = heatTransferSpeed;
});

document.getElementById('ambientTemp').addEventListener('input', function() {
    ambientTemperature = parseInt(this.value);
    document.getElementById('ambientTempValue').textContent = `${ambientTemperature}°C`;
    tempDisplay.textContent = temperatureSystemEnabled ?
        `温度系统: 开启 (${ambientTemperature}°C)` : '温度系统: 关闭';
    
    if (!temperatureSystemEnabled) {
        temperatures.fill(ambientTemperature);
    }
});

// ================= 输入处理 =================
let isDrawing = false;

function handleInput(e) {
    e.preventDefault();

    if (!isDrawing && e.type !== 'mousemove' && e.type !== 'touchmove') return;
    if (!isDrawing && (e.type === 'mousemove' || e.type === 'touchmove')) return;

    const rect = canvas.getBoundingClientRect();
    let cx = e.touches ? e.touches[0].clientX : e.clientX;
    let cy = e.touches ? e.touches[0].clientY : e.clientY;
    
    const x = Math.floor((cx - rect.left) / (rect.width / width));
    const y = Math.floor((cy - rect.top) / (rect.height / height));
    const r = parseInt(document.getElementById('brushSize').value);

    if (brushShape === 'square') {
        for (let dy = -r; dy <= r; dy++) {
            for (let dx = -r; dx <= r; dx++) {
                const px = x + dx;
                const py = y + dy;
                drawPixel(px, py);
            }
        }
    } else {
        for (let dy = -r; dy <= r; dy++) {
            for (let dx = -r; dx <= r; dx++) {
                if (dx * dx + dy * dy <= r * r) {
                    const px = x + dx;
                    const py = y + dy;
                    drawPixel(px, py);
                }
            }
        }
    }
}

function drawPixel(px, py) {
    if (inBounds(px, py)) {
        const i = idx(px, py);
        if (currentElement.isEraser) {
            grid[i] = 0;
            if (temperatureSystemEnabled) {
                temperatures[i] = ambientTemperature;
            }
            removeGrowthRecords(i);
        } else if (grid[i] === 0) {
            grid[i] = currentElement.id;
            if (temperatureSystemEnabled) {
                temperatures[i] = currentElement.defaultTemp || ambientTemperature;
            }
            
            // 初始化各种状态
            if (currentElement.id === ELEMENTS.SEED.id) {
                checkSeedGrowth(px, py);
            }
            if (currentElement.id === ELEMENTS.LIFE.id) {
                checkLifeElement(px, py);
            }
            if (currentElement.id === ELEMENTS.CLONE.id) {
                checkCloneElement(px, py);
            }
            if (currentElement.id === ELEMENTS.FUSE.id) {
                fuseBurnState.burning[i] = 0;
                fuseBurnState.burnTime[i] = 0;
                fuseBurnState.lastSpread[i] = 0;
            }
            
            // 重置氧化状态
            metalOxidation[i] = 0;
            metalOxidationProgress[i] = 0;
            ironWaterReaction[i] = 0;
            
            // 初始化物理系统状态
            electricalCharge[i] = 0;
            radiationLevel[i] = 0;
            magneticField[i] = currentElement.magnetism || 0;
            magneticPolarity[i] = Math.random() > 0.5 ? 1 : -1;
        }
    }
}

canvas.addEventListener('mousedown', e => {
    isDrawing = true;
    handleInput(e);
});
canvas.addEventListener('mousemove', handleInput);
window.addEventListener('mouseup', () => {
    isDrawing = false;
});

canvas.addEventListener('touchstart', e => {
    isDrawing = true;
    handleInput(e);
}, { passive: false });
canvas.addEventListener('touchmove', handleInput, { passive: false });
window.addEventListener('touchend', () => {
    isDrawing = false;
});

// ================= 面板控制函数 =================
function toggleSheet(open) {
    const sheet = document.getElementById('more-sheet');
    toggleBackdrop(open);
    if (open) sheet.classList.add('open');
    else sheet.classList.remove('open');
}

function toggleBackdrop(show) {
    const bd = document.getElementById('backdrop');
    if (show) bd.classList.add('open');
    else bd.classList.remove('open');
}

function openSettings() {
    document.getElementById('settings-overlay').classList.add('show');
    toggleBackdrop(true);
}

function closeSettings(e) {
    if (e.target.id === 'settings-overlay') {
        document.getElementById('settings-overlay').classList.remove('show');
        toggleBackdrop(false);
    }
}

function openSourceView() {
    const htmlContent = "<!DOCTYPE html>\n" + document.documentElement.outerHTML;
    document.getElementById('source-code-view').value = htmlContent;
    document.getElementById('settings-overlay').classList.remove('show');
    document.getElementById('source-overlay').classList.add('show');
    toggleBackdrop(true);
}

function copySource() {
    const textArea = document.getElementById('source-code-view');
    textArea.select();
    document.execCommand('copy');
    const btnText = document.getElementById('copy-btn-text');
    const original = btnText.innerText;
    btnText.innerText = "已复制";
    setTimeout(() => btnText.innerText = original, 2000);
}

function closeSource(e) {
    if (e.target.id === 'source-overlay') {
        document.getElementById('source-overlay').classList.remove('show');
        toggleBackdrop(false);
    }
}

function openAbout() {
    document.getElementById('about-overlay').classList.add('show');
    toggleBackdrop(true);
}

function closeAbout(e) {
    if (e.target.id === 'about-overlay') {
        document.getElementById('about-overlay').classList.remove('show');
        toggleBackdrop(false);
    }
}

function closeAllOverlays() {
    toggleSheet(false);
    document.getElementById('settings-overlay').classList.remove('show');
    document.getElementById('about-overlay').classList.remove('show');
    document.getElementById('source-overlay').classList.remove('show');
    document.getElementById('cheat-overlay').classList.remove('show');
}

// ================= 作弊面板功能 =================
let currentEditingElement = null;

function initCheatPanel() {
    const select = document.getElementById('cheat-element-select');
    const baseSelect = document.getElementById('cheat-base-element');
    
    const targetSelects = ['cheat-burnTo', 'cheat-meltTo', 'cheat-freezeTo', 'cheat-boilTo', 'cheat-condenseTo', 'cheat-oxidizeTo'];
    
    Object.keys(ELEMENTS).forEach(key => {
        if (key === 'AIR') return;
        
        const option = document.createElement('option');
        option.value = key;
        option.textContent = `${ELEMENTS[key].name} (${key})`;
        select.appendChild(option);
        
        const baseOption = document.createElement('option');
        baseOption.value = key;
        baseOption.textContent = `${ELEMENTS[key].name} (${key})`;
        baseSelect.appendChild(baseOption);
        
        targetSelects.forEach(selectId => {
            const targetSelect = document.getElementById(selectId);
            const targetOption = document.createElement('option');
            targetOption.value = key;
            targetOption.textContent = `${ELEMENTS[key].name} (${key})`;
            targetSelect.appendChild(targetOption);
        });
    });
    
    updateElementList();
}

function openCheatPanel() {
    document.getElementById('settings-overlay').classList.remove('show');
    document.getElementById('cheat-overlay').classList.add('show');
    toggleBackdrop(true);
}

function closeCheat(e) {
    if (e && e.target.id === 'cheat-overlay') {
        closeCheatPanel();
    }
}

function closeCheatPanel() {
    document.getElementById('cheat-overlay').classList.remove('show');
    toggleBackdrop(false);
}

function loadElementForEdit() {
    const key = document.getElementById('cheat-element-select').value;
    if (!key) {
        document.getElementById('cheat-properties').style.display = 'none';
        return;
    }
    
    currentEditingElement = key;
    const el = ELEMENTS[key];
    
    document.getElementById('cheat-properties').style.display = 'block';
    
    document.getElementById('cheat-name').value = el.name || '';
    document.getElementById('cheat-type').value = el.type !== undefined ? el.type : 1;
    document.getElementById('cheat-density').value = el.density !== undefined ? el.density : 1;
    document.getElementById('cheat-defaultTemp').value = el.defaultTemp !== undefined ? el.defaultTemp : 20;
    document.getElementById('cheat-heatResistance').value = el.heatResistance !== undefined ? el.heatResistance : 0.5;
    document.getElementById('cheat-variance').value = el.variance !== undefined ? el.variance : 0;
    
    const [r, g, b, a = 255] = el.color || [128, 128, 128, 255];
    const hex = rgbToHex(r, g, b);
    document.getElementById('cheat-color-picker').value = hex;
    document.getElementById('cheat-color').value = `${r},${g},${b},${a}`;
    
    document.getElementById('cheat-flammable').checked = !!el.flammable;
    document.getElementById('cheat-explosive').checked = !!el.explosive;
    document.getElementById('cheat-meltable').checked = !!el.meltable;
    document.getElementById('cheat-indestructible').checked = !!el.indestructible;
    document.getElementById('cheat-acidity').checked = !!el.acidity;
    document.getElementById('cheat-superAcidic').checked = !!el.superAcidic;
    document.getElementById('cheat-hot').checked = !!el.hot;
    document.getElementById('cheat-transparent').checked = !!el.transparent;
    document.getElementById('cheat-oxidizable').checked = !!el.oxidizable;
    
    document.getElementById('cheat-gasSpeed').value = el.gasSpeed !== undefined ? el.gasSpeed : '0.5';
    document.getElementById('cheat-gasMovement').value = el.gasMovement || 'up';
    document.getElementById('cheat-gasSpread').value = el.gasSpread !== undefined ? el.gasSpread : '';
    document.getElementById('cheat-gasBuoyancy').value = el.gasBuoyancy !== undefined ? el.gasBuoyancy : '';
    
    document.getElementById('cheat-viscosity').value = el.viscosity !== undefined ? el.viscosity : '0';
    document.getElementById('cheat-flowRate').value = el.flowRate !== undefined ? el.flowRate : '';
    document.getElementById('cheat-surfaceTension').value = el.surfaceTension !== undefined ? el.surfaceTension : '';
    
    document.getElementById('cheat-angleOfRepose').value = el.angleOfRepose !== undefined ? el.angleOfRepose : '';
    document.getElementById('cheat-rollness').value = el.rollness !== undefined ? el.rollness : '';
    
    document.getElementById('cheat-ignitesAt').value = el.ignitesAt !== undefined ? el.ignitesAt : '';
    document.getElementById('cheat-meltsAt').value = el.meltsAt !== undefined ? el.meltsAt : '';
    document.getElementById('cheat-boilsAt').value = el.boilsAt !== undefined ? el.boilsAt : '';
    document.getElementById('cheat-freezesAt').value = el.freezesAt !== undefined ? el.freezesAt : '';
    document.getElementById('cheat-condensesAt').value = el.condensesAt !== undefined ? el.condensesAt : '';
    document.getElementById('cheat-diesAt').value = el.diesAt !== undefined ? el.diesAt : '';
    
    document.getElementById('cheat-burnTo').value = el.burnTo || '';
    document.getElementById('cheat-meltTo').value = el.meltTo || '';
    document.getElementById('cheat-freezeTo').value = el.freezeTo || '';
    document.getElementById('cheat-boilTo').value = el.boilTo || '';
    document.getElementById('cheat-condenseTo').value = el.condenseTo || '';
    document.getElementById('cheat-oxidizeTo').value = el.oxidizeTo || '';
    
    document.getElementById('cheat-heatEmission').value = el.heatEmission !== undefined ? el.heatEmission : '';
    document.getElementById('cheat-life').value = el.life !== undefined ? el.life : '';
    document.getElementById('cheat-burnTime').value = el.burnTime !== undefined ? el.burnTime : '';
    document.getElementById('cheat-explosivePower').value = el.explosivePower !== undefined ? el.explosivePower : '';
    document.getElementById('cheat-acidResistance').value = el.acidResistance !== undefined ? el.acidResistance : '';
    document.getElementById('cheat-conductivity').value = el.conductivity !== undefined ? el.conductivity : '';
    document.getElementById('cheat-radioactivity').value = el.radioactivity !== undefined ? el.radioactivity : '';
    document.getElementById('cheat-magnetism').value = el.magnetism !== undefined ? el.magnetism : '';
    document.getElementById('cheat-oxidationRate').value = el.oxidationRate !== undefined ? el.oxidationRate : '';
    
    document.getElementById('cheat-burnSpeed').value = el.burnSpeed !== undefined ? el.burnSpeed : '';
    document.getElementById('cheat-burnTemp').value = el.burnTemp !== undefined ? el.burnTemp : '';
    document.getElementById('cheat-burnDuration').value = el.burnDuration !== undefined ? el.burnDuration : '';
    
    document.getElementById('cheat-hungerRate').value = el.hungerRate !== undefined ? el.hungerRate : '';
    document.getElementById('cheat-breedChance').value = el.breedChance !== undefined ? el.breedChance : '';
    document.getElementById('cheat-moveInterval').value = el.moveInterval !== undefined ? el.moveInterval : '';
    
    document.getElementById('cheat-copyInterval').value = el.copyInterval !== undefined ? el.copyInterval : '';
    document.getElementById('cheat-maxCopyCount').value = el.maxCopyCount !== undefined ? el.maxCopyCount : '';
}

function updateColorFromPicker() {
    const hex = document.getElementById('cheat-color-picker').value;
    const [r, g, b] = hexToRgb(hex);
    const currentVal = document.getElementById('cheat-color').value;
    const a = currentVal.split(',')[3] || 255;
    document.getElementById('cheat-color').value = `${r},${g},${b},${a}`;
}

function updateColorFromText() {
    const val = document.getElementById('cheat-color').value;
    const parts = val.split(',').map(v => parseInt(v.trim()) || 0);
    if (parts.length >= 3) {
        const hex = rgbToHex(parts[0], parts[1], parts[2]);
        document.getElementById('cheat-color-picker').value = hex;
    }
}

function rgbToHex(r, g, b) {
    return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
}

function hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? [
        parseInt(result[1], 16),
        parseInt(result[2], 16),
        parseInt(result[3], 16)
    ] : [128, 128, 128];
}

function applyCheatChanges() {
    if (!currentEditingElement) return;
    
    const key = currentEditingElement;
    const el = ELEMENTS[key];
    
    el.name = document.getElementById('cheat-name').value || el.name;
    el.type = parseInt(document.getElementById('cheat-type').value);
    el.density = parseFloat(document.getElementById('cheat-density').value) || 1;
    el.defaultTemp = parseInt(document.getElementById('cheat-defaultTemp').value) || 20;
    el.heatResistance = parseFloat(document.getElementById('cheat-heatResistance').value) || 0.5;
    el.variance = parseInt(document.getElementById('cheat-variance').value) || 0;
    
    const colorVal = document.getElementById('cheat-color').value;
    el.color = colorVal.split(',').map(v => parseInt(v.trim()) || 0);
    
    el.flammable = document.getElementById('cheat-flammable').checked;
    el.explosive = document.getElementById('cheat-explosive').checked;
    el.meltable = document.getElementById('cheat-meltable').checked;
    el.indestructible = document.getElementById('cheat-indestructible').checked;
    el.acidity = document.getElementById('cheat-acidity').checked;
    el.superAcidic = document.getElementById('cheat-superAcidic').checked;
    el.hot = document.getElementById('cheat-hot').checked;
    el.transparent = document.getElementById('cheat-transparent').checked;
    el.oxidizable = document.getElementById('cheat-oxidizable').checked;
    
    el.gasSpeed = parseFloat(document.getElementById('cheat-gasSpeed').value);
    el.gasMovement = document.getElementById('cheat-gasMovement').value;
    const gasSpread = document.getElementById('cheat-gasSpread').value;
    if (gasSpread) el.gasSpread = parseFloat(gasSpread);
    else delete el.gasSpread;
    const gasBuoyancy = document.getElementById('cheat-gasBuoyancy').value;
    if (gasBuoyancy) el.gasBuoyancy = parseFloat(gasBuoyancy);
    else delete el.gasBuoyancy;
    
    el.viscosity = parseFloat(document.getElementById('cheat-viscosity').value);
    const flowRate = document.getElementById('cheat-flowRate').value;
    if (flowRate) el.flowRate = parseFloat(flowRate);
    else delete el.flowRate;
    const surfaceTension = document.getElementById('cheat-surfaceTension').value;
    if (surfaceTension) el.surfaceTension = parseFloat(surfaceTension);
    else delete el.surfaceTension;
    
    const angleOfRepose = document.getElementById('cheat-angleOfRepose').value;
    if (angleOfRepose) el.angleOfRepose = parseInt(angleOfRepose);
    else delete el.angleOfRepose;
    const rollness = document.getElementById('cheat-rollness').value;
    if (rollness) el.rollness = parseFloat(rollness);
    else delete el.rollness;
    
    const ignitesAt = document.getElementById('cheat-ignitesAt').value;
    if (ignitesAt) el.ignitesAt = parseInt(ignitesAt);
    else delete el.ignitesAt;
    
    const meltsAt = document.getElementById('cheat-meltsAt').value;
    if (meltsAt) el.meltsAt = parseInt(meltsAt);
    else delete el.meltsAt;
    
    const boilsAt = document.getElementById('cheat-boilsAt').value;
    if (boilsAt) el.boilsAt = parseInt(boilsAt);
    else delete el.boilsAt;
    
    const freezesAt = document.getElementById('cheat-freezesAt').value;
    if (freezesAt) el.freezesAt = parseInt(freezesAt);
    else delete el.freezesAt;
    
    const condensesAt = document.getElementById('cheat-condensesAt').value;
    if (condensesAt) el.condensesAt = parseInt(condensesAt);
    else delete el.condensesAt;
    
    const diesAt = document.getElementById('cheat-diesAt').value;
    if (diesAt) el.diesAt = parseInt(diesAt);
    else delete el.diesAt;
    
    el.burnTo = document.getElementById('cheat-burnTo').value || undefined;
    el.meltTo = document.getElementById('cheat-meltTo').value || undefined;
    el.freezeTo = document.getElementById('cheat-freezeTo').value || undefined;
    el.boilTo = document.getElementById('cheat-boilTo').value || undefined;
    el.condenseTo = document.getElementById('cheat-condenseTo').value || undefined;
    el.oxidizeTo = document.getElementById('cheat-oxidizeTo').value || undefined;
    
    const heatEmission = document.getElementById('cheat-heatEmission').value;
    if (heatEmission) el.heatEmission = parseInt(heatEmission);
    else delete el.heatEmission;
    
    const life = document.getElementById('cheat-life').value;
    if (life) el.life = parseInt(life);
    else delete el.life;
    
    const burnTime = document.getElementById('cheat-burnTime').value;
    if (burnTime) el.burnTime = parseInt(burnTime);
    else delete el.burnTime;
    
    const explosivePower = document.getElementById('cheat-explosivePower').value;
    if (explosivePower) el.explosivePower = parseInt(explosivePower);
    else delete el.explosivePower;
    
    const acidResistance = document.getElementById('cheat-acidResistance').value;
    if (acidResistance) el.acidResistance = parseFloat(acidResistance);
    else delete el.acidResistance;
    
    const conductivity = document.getElementById('cheat-conductivity').value;
    if (conductivity) el.conductivity = parseFloat(conductivity);
    else delete el.conductivity;
    
    const radioactivity = document.getElementById('cheat-radioactivity').value;
    if (radioactivity) el.radioactivity = parseFloat(radioactivity);
    else delete el.radioactivity;
    
    const magnetism = document.getElementById('cheat-magnetism').value;
    if (magnetism) el.magnetism = parseFloat(magnetism);
    else delete el.magnetism;
    
    const oxidationRate = document.getElementById('cheat-oxidationRate').value;
    if (oxidationRate) el.oxidationRate = parseFloat(oxidationRate);
    else delete el.oxidationRate;
    
    const burnSpeed = document.getElementById('cheat-burnSpeed').value;
    if (burnSpeed) el.burnSpeed = parseInt(burnSpeed);
    else delete el.burnSpeed;
    
    const burnTemp = document.getElementById('cheat-burnTemp').value;
    if (burnTemp) el.burnTemp = parseInt(burnTemp);
    else delete el.burnTemp;
    
    const burnDuration = document.getElementById('cheat-burnDuration').value;
    if (burnDuration) el.burnDuration = parseInt(burnDuration);
    else delete el.burnDuration;
    
    const hungerRate = document.getElementById('cheat-hungerRate').value;
    if (hungerRate) el.hungerRate = parseFloat(hungerRate);
    else delete el.hungerRate;
    
    const breedChance = document.getElementById('cheat-breedChance').value;
    if (breedChance) el.breedChance = parseFloat(breedChance);
    else delete el.breedChance;
    
    const moveInterval = document.getElementById('cheat-moveInterval').value;
    if (moveInterval) el.moveInterval = parseInt(moveInterval);
    else delete el.moveInterval;
    
    const copyInterval = document.getElementById('cheat-copyInterval').value;
    if (copyInterval) el.copyInterval = parseInt(copyInterval);
    else delete el.copyInterval;
    
    const maxCopyCount = document.getElementById('cheat-maxCopyCount').value;
    if (maxCopyCount) el.maxCopyCount = parseInt(maxCopyCount);
    else delete el.maxCopyCount;
    
    refreshUI();
    
    showToast(`${el.name} 的属性已修改`);
}

function resetElementToDefault() {
    if (!currentEditingElement) return;
    
    if (!confirm('确定要重置这个元素到默认状态吗？')) return;
    
    const key = currentEditingElement;
    if (DEFAULT_ELEMENTS[key]) {
        const defaultConfig = JSON.parse(JSON.stringify(DEFAULT_ELEMENTS[key]));
        defaultConfig.id = ELEMENTS[key].id;
        ELEMENTS[key] = defaultConfig;
        
        loadElementForEdit();
        refreshUI();
        
        showToast(`${defaultConfig.name} 已重置为默认状态`);
    }
}

function createNewElement() {
    const newId = document.getElementById('cheat-new-id').value.trim().toUpperCase();
    const baseKey = document.getElementById('cheat-base-element').value;
    
    if (!newId) {
        alert('请输入新元素的ID');
        return;
    }
    
    if (ELEMENTS[newId]) {
        alert('该ID已存在，请使用其他名称');
        return;
    }
    
    if (!baseKey) {
        alert('请选择一个基础元素');
        return;
    }
    
    let maxId = 0;
    Object.values(ELEMENTS).forEach(el => {
        if (el.id > maxId && el.id < 99) maxId = el.id;
    });
    
    const newElement = JSON.parse(JSON.stringify(ELEMENTS[baseKey]));
    newElement.id = maxId + 1;
    newElement.name = `新${newElement.name}`;
    
    ELEMENTS[newId] = newElement;
    DEFAULT_ELEMENTS[newId] = JSON.parse(JSON.stringify(newElement));
    
    const select = document.getElementById('cheat-element-select');
    const option = document.createElement('option');
    option.value = newId;
    option.textContent = `${newElement.name} (${newId})`;
    select.appendChild(option);
    
    const targetSelects = ['cheat-burnTo', 'cheat-meltTo', 'cheat-freezeTo', 'cheat-boilTo', 'cheat-condenseTo', 'cheat-oxidizeTo'];
    targetSelects.forEach(selectId => {
        const targetSelect = document.getElementById(selectId);
        const targetOption = document.createElement('option');
        targetOption.value = newId;
        targetOption.textContent = `${newElement.name} (${newId})`;
        targetSelect.appendChild(targetOption);
    });
    
    select.value = newId;
    loadElementForEdit();
    
    refreshUI();
    updateElementList();
    
    showToast(`新元素 ${newId} 已创建`);
}

function deleteElement(key) {
    if (!confirm(`确定要删除元素 ${key} 吗？此操作不可恢复。`)) return;
    
    if (DEFAULT_ELEMENTS[key]) {
        delete DEFAULT_ELEMENTS[key];
    }
    delete ELEMENTS[key];
    
    const index = QUICK_KEYS.indexOf(key);
    if (index > -1) {
        QUICK_KEYS.splice(index, 1);
    }
    
    const select = document.getElementById('cheat-element-select');
    const options = select.querySelectorAll('option');
    options.forEach(opt => {
        if (opt.value === key) opt.remove();
    });
    
    const targetSelects = ['cheat-burnTo', 'cheat-meltTo', 'cheat-freezeTo', 'cheat-boilTo', 'cheat-condenseTo', 'cheat-oxidizeTo'];
    targetSelects.forEach(selectId => {
        const targetSelect = document.getElementById(selectId);
        const targetOptions = targetSelect.querySelectorAll('option');
        targetOptions.forEach(opt => {
            if (opt.value === key) opt.remove();
        });
    });
    
    refreshUI();
    updateElementList();
    
    document.getElementById('cheat-properties').style.display = 'none';
    currentEditingElement = null;
    
    showToast(`元素 ${key} 已删除`);
}

function updateElementList() {
    const list = document.getElementById('element-list');
    list.innerHTML = '';
    
    Object.keys(ELEMENTS).forEach(key => {
        if (key === 'AIR' || key === 'ERASER') return;
        
        const item = document.createElement('div');
        item.className = 'element-list-item';
        
        const name = document.createElement('span');
        name.textContent = `${ELEMENTS[key].name} (${key})`;
        
        const btn = document.createElement('button');
        btn.textContent = '删除';
        btn.onclick = () => deleteElement(key);
        
        item.appendChild(name);
        item.appendChild(btn);
        list.appendChild(item);
    });
}

function refreshUI() {
    const quickBar = document.getElementById('quick-bar');
    const allGrid = document.getElementById('all-elements-grid');
    
    quickBar.innerHTML = '';
    allGrid.innerHTML = '';
    
    QUICK_KEYS.forEach(key => {
        if (!ELEMENTS[key]) return;
        const el = ELEMENTS[key];
        const btn = document.createElement('button');
        btn.className = 'chip';
        btn.dataset.key = key;
        btn.innerText = el.name;
        btn.onclick = () => selectElement(key);
        if (ELEMENTS[key] === currentElement) btn.classList.add('active');
        quickBar.appendChild(btn);
    });
    
    Object.keys(ELEMENTS).forEach(key => {
        if (key === 'AIR') return;
        const el = ELEMENTS[key];
        const card = document.createElement('div');
        card.className = 'element-card';
        card.onclick = () => selectElement(key);
        
        const dot = document.createElement('div');
        dot.className = 'element-color-dot';
        
        if (el.isEraser) {
            dot.style.background = '#fff';
            dot.style.border = '2px solid #ccc';
            dot.style.backgroundImage = 'linear-gradient(45deg, #ccc 25%, transparent 25%, transparent 75%, #ccc 75%, #ccc), linear-gradient(45deg, #ccc 25%, transparent 25%, transparent 75%, #ccc 75%, #ccc)';
            dot.style.backgroundSize = '10px 10px';
            dot.style.backgroundPosition = '0 0, 5px 5px';
        } else {
            const [r, g, b, a = 255] = el.color;
            dot.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${a / 255})`;
            
            if (el.hot) {
                dot.style.boxShadow = `0 0 8px rgba(${Math.min(r+50, 255)}, ${Math.min(g+50, 255)}, ${Math.min(b+50, 255)}, 0.8)`;
            }
            
            if (el.type === TYPES.ACID) {
                dot.style.boxShadow = `0 0 6px rgba(${r}, ${g}, ${b}, 0.6)`;
            }
            
            if (el.id === ELEMENTS.GUNPOWDER.id) {
                dot.style.boxShadow = '0 0 8px rgba(255, 200, 0, 0.8)';
                dot.style.animation = 'pulse 2s infinite';
            }
            
            if (el.id === ELEMENTS.FUSE.id) {
                dot.style.boxShadow = '0 0 8px rgba(255, 100, 0, 0.6)';
                dot.style.border = '2px solid #8B4513';
            }
            
            if (el.oxidizable) {
                dot.classList.add('oxidizable');
            }
            
            if (el.conductivity && el.conductivity > 0.5) {
                dot.style.boxShadow = `0 0 6px rgba(100, 200, 255, 0.6)`;
            }
            
            if (el.radioactivity && el.radioactivity > 0) {
                dot.style.boxShadow = `0 0 6px rgba(100, 255, 100, 0.6)`;
                dot.style.animation = 'pulse 1s infinite';
            }
            
            if (el.magnetism && el.magnetism > 0) {
                dot.style.border = `2px solid ${Math.random() > 0.5 ? '#0000ff' : '#ff0000'}`;
            }
        }
        
        const name = document.createElement('span');
        name.style.fontSize = '14px';
        name.innerText = el.name;
        
        card.appendChild(dot);
        card.appendChild(name);
        allGrid.appendChild(card);
    });
    
    const totalElements = Object.keys(ELEMENTS).length - 1;
    document.getElementById('element-counter').textContent = `当前共有 ${totalElements} 种元素`;
}

// ================= 保存功能 =================
function saveAllChanges() {
    const dataToSave = {
        elements: {},
        quickKeys: QUICK_KEYS,
        timestamp: new Date().toISOString()
    };
    
    for (let key in ELEMENTS) {
        if (key !== 'AIR') {
            dataToSave.elements[key] = JSON.parse(JSON.stringify(ELEMENTS[key]));
        }
    }
    
    localStorage.setItem('sandspiel_custom_elements', JSON.stringify(dataToSave));
    showToast('所有修改已保存到本地存储');
}

function loadSavedChanges() {
    const savedData = localStorage.getItem('sandspiel_custom_elements');
    if (!savedData) {
        return;
    }
    
    try {
        const data = JSON.parse(savedData);
        
        if (data.elements) {
            for (let key in data.elements) {
                if (ELEMENTS[key]) {
                    ELEMENTS[key] = data.elements[key];
                } else {
                    ELEMENTS[key] = data.elements[key];
                    DEFAULT_ELEMENTS[key] = JSON.parse(JSON.stringify(data.elements[key]));
                    
                    const select = document.getElementById('cheat-element-select');
                    const exists = Array.from(select.options).some(opt => opt.value === key);
                    if (!exists) {
                        const option = document.createElement('option');
                        option.value = key;
                        option.textContent = `${data.elements[key].name} (${key})`;
                        select.appendChild(option);
                        
                        const targetSelects = ['cheat-burnTo', 'cheat-meltTo', 'cheat-freezeTo', 'cheat-boilTo', 'cheat-condenseTo', 'cheat-oxidizeTo'];
                        targetSelects.forEach(selectId => {
                            const targetSelect = document.getElementById(selectId);
                            const targetOption = document.createElement('option');
                            targetOption.value = key;
                            targetOption.textContent = `${data.elements[key].name} (${key})`;
                            targetSelect.appendChild(targetOption);
                        });
                    }
                }
            }
        }
        
        if (data.quickKeys) {
            QUICK_KEYS = data.quickKeys.filter(key => ELEMENTS[key]);
        }
        
        refreshUI();
        updateElementList();
        
        showToast('保存的修改已加载');
        
    } catch (e) {
        console.error('加载保存的数据失败:', e);
        showToast('加载保存的数据失败');
    }
}

function clearSavedChanges() {
    if (!confirm('确定要清除所有保存的修改吗？')) return;
    
    localStorage.removeItem('sandspiel_custom_elements');
    showToast('保存的数据已清除');
}

function resetToFactoryDefaults() {
    if (!confirm('确定要恢复出厂设置吗？所有自定义修改将被清除。')) return;
    
    // 清除本地存储
    localStorage.removeItem('sandspiel_custom_elements');
    
    // 恢复默认元素
    for (let key in DEFAULT_ELEMENTS) {
        ELEMENTS[key] = JSON.parse(JSON.stringify(DEFAULT_ELEMENTS[key]));
    }
    
    // 删除自定义元素（不在默认元素中的）
    for (let key in ELEMENTS) {
        if (!DEFAULT_ELEMENTS[key] && key !== 'AIR' && key !== 'ERASER') {
            delete ELEMENTS[key];
        }
    }
    
    // 恢复默认快速访问栏
    QUICK_KEYS = ['SAND', 'WATER', 'STONE', 'WALL', 'ICE', 'LAVA', 'FIRE', 'STEAM', 'SUPER_ACID', 'BEDROCK', 'GLASS', 'LIFE', 'CLONE', 'IRON', 'COPPER', 'FUSE', 'RUST', 'ERASER'];
    
    // 重置当前选择的元素
    currentElement = ELEMENTS.SAND;
    
    // 刷新UI
    refreshUI();
    
    // 重新初始化作弊面板
    initCheatPanel();
    
    showToast('已恢复出厂设置');
}

function showToast(message) {
    const toast = document.getElementById('toast');
    toast.textContent = message;
    toast.classList.add('show');
    
    setTimeout(() => {
        toast.classList.remove('show');
    }, 3000);
}

// ================= 初始化 =================
window.addEventListener('load', () => {
    initUI();
    loop();
});

const style = document.createElement('style');
style.textContent = `
@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
}

.advanced-btn.active {
    background: var(--md-sys-color-primary);
    color: var(--md-sys-color-on-primary);
}

@keyframes oxidize {
    0% { box-shadow: 0 0 4px rgba(139, 69, 19, 0.5); }
    100% { box-shadow: 0 0 8px rgba(139, 69, 19, 0.8); }
}

.toast {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: var(--md-sys-color-primary);
    color: var(--md-sys-color-on-primary);
    padding: 12px 24px;
    border-radius: 12px;
    z-index: 10000;
    opacity: 0;
    transition: opacity 0.3s;
}

.toast.show {
    opacity: 1;
}
`;
document.head.appendChild(style);
</script>
</body>
</html>