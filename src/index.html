<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>SandSpiel - PowderGame</title>
<style>
:root{--md-sys-color-primary:#6750A4;--md-sys-color-on-primary:#FFFFFF;--md-sys-color-primary-container:#EADDFF;--md-sys-color-on-primary-container:#21005D;--md-sys-color-secondary:#625B71;--md-sys-color-secondary-container:#E8DEF8;--md-sys-color-on-secondary-container:#1D192B;--md-sys-color-surface:#1C1B1F;--md-sys-color-surface-container:#25232A;--md-sys-color-on-surface:#E6E1E5;--md-sys-color-outline:#79747E;--md-sys-color-surface-variant:#49454F;}
* {box-sizing:border-box;user-select:none;-webkit-tap-highlight-color:transparent}
body{margin:0;padding:0;background:var(--md-sys-color-surface);color:var(--md-sys-color-on-surface);font-family:'Roboto',sans-serif;height:100vh;display:flex;flex-direction:column;overflow:hidden}
header{height:64px;display:flex;align-items:center;padding:0 16px;background:var(--md-sys-color-surface);font:400 22px/28px 'Roboto',sans-serif;justify-content:space-between}
.icon-btn{width:40px;height:40px;border-radius:50%;border:none;background:transparent;color:var(--md-sys-color-on-surface);display:flex;align-items:center;justify-content:center;cursor:pointer;position:relative;overflow:hidden}
.icon-btn svg{width:24px;height:24px;fill:currentColor}
#game-container{flex:1;position:relative;background:#000;margin:0 16px 16px 16px;border-radius:16px;overflow:hidden;touch-action:none}
canvas{width:100%;height:100%;image-rendering:pixelated;display:block}
.controls-area{background:var(--md-sys-color-surface-container);padding:12px 16px 24px 16px;border-radius:24px 24px 0 0;display:flex;flex-direction:column;gap:12px}
.chip-scroll{display:flex;overflow-x:auto;gap:8px;padding-bottom:4px;scrollbar-width:none}
.chip-scroll::-webkit-scrollbar{display:none}
.chip{height:32px;padding:0 16px;border-radius:8px;border:1px solid var(--md-sys-color-outline);background:transparent;color:var(--md-sys-color-on-surface);font:500 14px/20px 'Roboto',sans-serif;display:flex;align-items:center;white-space:nowrap;cursor:pointer;transition:all .2s}
.chip.active{background:var(--md-sys-color-secondary-container);color:var(--md-sys-color-on-secondary-container);border-color:transparent}
.chip.active::before{content:"âœ“";margin-right:6px;font-weight:bold}
#more-sheet{position:fixed;bottom:-100%;left:0;right:0;background:var(--md-sys-color-surface-container);border-radius:28px 28px 0 0;padding:24px;transition:bottom .3s;z-index:100;max-height:70vh;overflow-y:auto}
#more-sheet.open{bottom:0}
.sheet-handle{width:32px;height:4px;background:var(--md-sys-color-outline);opacity:.4;border-radius:2px;margin:-10px auto 20px auto}
.grid-elements{display:grid;grid-template-columns:repeat(auto-fill,minmax(80px,1fr));gap:12px}
.element-card{display:flex;flex-direction:column;align-items:center;justify-content:center;padding:16px;background:var(--md-sys-color-surface);border-radius:12px;gap:8px;cursor:pointer}
.element-color-dot{width:24px;height:24px;border-radius:50%;border:1px solid rgba(0,0,0,.1)}
.backdrop{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,.4);z-index:90;opacity:0;pointer-events:none;transition:opacity .3s}
.backdrop.open{opacity:1;pointer-events:auto}
.brush-size-slider{-webkit-appearance:none;appearance:none;width:100%;height:4px;background:var(--md-sys-color-surface-variant);border-radius:2px;outline:none}
.brush-size-slider::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;width:20px;height:20px;border-radius:50%;background:var(--md-sys-color-primary);border:2px solid var(--md-sys-color-on-primary);cursor:grab;box-shadow:0 0 4px rgba(0,0,0,.35);transition:transform .2s}
.brush-size-slider:active::-webkit-slider-thumb{cursor:grabbing;transform:scale(1.15)}
.brush-size-slider::-moz-range-thumb{width:20px;height:20px;border-radius:50%;background:var(--md-sys-color-primary);border:2px solid var(--md-sys-color-on-primary);cursor:grab;box-shadow:0 0 4px rgba(0,0,0,.35);transition:transform .2s}
.brush-size-slider:active::-moz-range-thumb{cursor:grabbing;transform:scale(1.15)}
#fps-display{position:absolute;top:5px;right:5px;color:white;font-family:'Roboto',sans-serif;font-size:12px;font-weight:400;background:rgba(0,0,0,0.6);padding:2px 6px;border-radius:3px;z-index:10;pointer-events:none}
.control-buttons{display:flex;gap:8px;margin-left:auto}
.paused-indicator{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:white;font-size:24px;font-weight:bold;text-shadow:2px 2px 4px rgba(0,0,0,0.8);display:none;z-index:20}
.temp-display{position:absolute;top:30px;right:5px;color:white;font-family:'Roboto',sans-serif;font-size:12px;font-weight:400;background:rgba(0,0,0,0.6);padding:2px 6px;border-radius:3px;z-index:10;pointer-events:none}
.temp-settings{display:flex;flex-direction:column;gap:8px;margin-top:8px;padding:8px;background:rgba(0,0,0,0.1);border-radius:8px}
.temp-slider-container{display:flex;align-items:center;gap:8px}
.temp-label{font-size:11px;opacity:0.7;min-width:80px}
.temp-value{font-size:11px;min-width:30px;text-align:right}
.temp-toggle{display:flex;align-items:center;gap:8px;font-size:12px}
</style>
</head>

<body>
<header>
<div style="display:flex; align-items:center; gap:12px;"><span>ğ—¦ğ—®ğ—»ğ—± Â· ğ—¦ğ—½ğ—¶ğ—²ğ—¹</span></div>
<div class="control-buttons">
<button class="icon-btn" onclick="togglePause()" title="æš‚åœ/ç»§ç»­">
<svg viewBox="0 0 24 24" id="pauseIcon"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
<svg viewBox="0 0 24 24" id="playIcon" style="display:none;"><path d="M8 5v14l11-7z"/></svg>
</button>
<button class="icon-btn" onclick="clearCanvas()" title="æ¸…ç©º">
<svg viewBox="0 0 24 24"><path d="M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z"/></svg>
</button>
</div>
</header>

<div id="game-container">
<canvas id="sandbox"></canvas>
<div id="fps-display">0 FPS</div>
<div id="temp-display">æ¸©åº¦ç³»ç»Ÿ: å¼€å¯</div>
<div class="paused-indicator" id="pausedIndicator">æš‚åœä¸­</div>
</div>

<div class="controls-area">
<div style="display:flex; align-items:center; gap:12px; margin-bottom:8px;">
<span style="font-size:12px; opacity:.7">ç¬”åˆ·</span>
<input type="range" class="brush-size-slider" min="1" max="15" value="3" id="brushSize">
</div>

<div class="temp-settings">
<div class="temp-toggle">
<input type="checkbox" id="tempToggle" checked onchange="toggleTemperatureSystem()">
<label for="tempToggle">æ¸©åº¦ç³»ç»Ÿ</label>
</div>

<div class="temp-slider-container">
<span class="temp-label">çƒ­ä¼ å¯¼</span>
<input type="range" min="1" max="10" value="5" class="brush-size-slider" id="heatTransferSpeed">
<span class="temp-value" id="heatTransferValue">5</span>
</div>

<div class="temp-slider-container">
<span class="temp-label">ç¯å¢ƒæ¸©åº¦</span>
<input type="range" min="-273" max="2000" value="20" class="brush-size-slider" id="ambientTemp">
<span class="temp-value" id="ambientTempValue">20Â°C</span>
</div>
</div>

<div class="chip-scroll" id="quick-bar"></div>
<button class="icon-btn" style="width:100%; border-radius:12px; height:48px; background:var(--md-sys-color-primary); color:var(--md-sys-color-on-primary); margin-top:8px;" onclick="toggleSheet(true)">æ›´å¤šå…ƒç´ </button>
</div>

<div class="backdrop" id="backdrop" onclick="toggleSheet(false)"></div>
<div id="more-sheet">
<div class="sheet-handle"></div>
<h3 style="margin:0 0 16px 0; font-size:20px;">æ‰€æœ‰å…ƒç´ </h3>
<div class="grid-elements" id="all-elements-grid"></div>
</div>

<script>
const CANVAS_SCALE = 2;
const TYPES = {
EMPTY:0,
SOLID:1,
POWDER:2,
LIQUID:3,
GAS:4,
ACID:5,
DUST:6,
FUEL_GAS:7,
HEAVY_SOLID:8,
LAVA:9,
STONE_SOLID:10,
CLONE:11,
SUPER_ACID:12,
BEDROCK:13,
GLASS:14,
LIFE:15,
STEAM:16
};

// æ‰©å±•å…ƒç´ å®šä¹‰ï¼Œæ·»åŠ æ¸©åº¦ç›¸å…³å±æ€§
const ELEMENTS = {
AIR:      { id:0,  name:'ç©ºæ°”',   color:[0,0,0,0],          type:TYPES.EMPTY, heatResistance:0.1, defaultTemp:20 },
SAND:     { id:1,  name:'æ²™å­',   color:[226,197,139,255],  type:TYPES.POWDER, variance:20, heatResistance:0.3, defaultTemp:20, meltsAt:1600, meltTo:'GLASS' },
WATER:    { id:2,  name:'æ°´',     color:[79,151,232,255],   type:TYPES.LIQUID, variance:10, reactsWithOil:true, heatResistance:0.4, defaultTemp:20, boilsAt:100, boilTo:'STEAM', freezesAt:0, freezeTo:'ICE' },
STONE:    { id:3,  name:'çŸ³å¤´',   color:[119,119,119,255],  type:TYPES.STONE_SOLID, heatResistance:0.5, defaultTemp:20 },
WALL:     { id:4,  name:'å¢™',     color:[150,150,150,255],  type:TYPES.SOLID, heatResistance:0.8, defaultTemp:20 },
FIRE:     { id:5,  name:'ç«ç„°',   color:[255,69,0,255],     type:TYPES.GAS, variance:50, life:50, heatResistance:0.0, defaultTemp:500, heatEmission:80, burnTime:50 },
SMOKE:    { id:6,  name:'çƒŸé›¾',   color:[200,200,200,150],  type:TYPES.GAS, life:200, heatResistance:0.2, defaultTemp:80 },
ACID:     { id:7,  name:'é…¸æ¶²',   color:[124,252,0,200],    type:TYPES.LIQUID, acidity:true, heatResistance:0.3, defaultTemp:20 },
WOOD:     { id:8,  name:'æœ¨å¤´',   color:[139,69,19,255],    type:TYPES.SOLID, flammable:true, heatResistance:0.2, defaultTemp:20, ignitesAt:150, burnTo:'FIRE' },
PLANT:    { id:9,  name:'æ¤ç‰©',   color:[34,139,34,255],    type:TYPES.SOLID, flammable:true, heatResistance:0.2, defaultTemp:20, ignitesAt:120, burnTo:'FIRE' },
OIL:      { id:10, name:'çŸ³æ²¹',   color:[30,30,30,255],     type:TYPES.LIQUID, flammable:true, variance:10, reactsWithWater:true, heatResistance:0.3, defaultTemp:20, ignitesAt:200, burnTo:'FIRE' },
SEED:     { id:11, name:'ç§å­',   color:[139,90,43,255],    type:TYPES.POWDER, flammable:true, heatResistance:0.2, defaultTemp:20, ignitesAt:100, burnTo:'FIRE' },
DUST:     { id:12, name:'ç«è¯',   color:[180,150,120,255],  type:TYPES.POWDER, explosive:true, variance:15, heatResistance:0.1, defaultTemp:20, ignitesAt:80, burnTo:'FIRE' },
GAS_FUEL: { id:13, name:'ç‡ƒæ°”',   color:[255,213,79,180],   type:TYPES.GAS, variance:25, flammable:true, heatResistance:0.0, defaultTemp:20, ignitesAt:60, burnTo:'FIRE' },
ICE:      { id:14, name:'å†°',     color:[173,216,230,255],  type:TYPES.SOLID, meltable:true, heatResistance:0.6, defaultTemp:-10, meltsAt:0, meltTo:'WATER' },
LAVA:     { id:15, name:'å²©æµ†',   color:[255,80,0,255],     type:TYPES.LAVA, hot:true, variance:30, heatResistance:0.0, defaultTemp:1200, heatEmission:100 },
FLOWER:   { id:16, name:'èŠ±',     color:[255,105,180,255],  type:TYPES.SOLID, flammable:true, heatResistance:0.2, defaultTemp:20, ignitesAt:100, burnTo:'FIRE' },
VINE:     { id:17, name:'è—¤è”“',   color:[50,205,50,180],    type:TYPES.SOLID, flammable:true, heatResistance:0.2, defaultTemp:20, ignitesAt:110, burnTo:'FIRE' },
LEAF:     { id:18, name:'å¶å­',   color:[144,238,144,200],  type:TYPES.SOLID, flammable:true, heatResistance:0.2, defaultTemp:20, ignitesAt:90, burnTo:'FIRE' },
CLONE:    { id:19, name:'å…‹éš†',   color:[138,43,226,255],   type:TYPES.CLONE, clonePower:5, pulse:true, heatResistance:0.5, defaultTemp:20 },
SUPER_ACID: { id:20, name:'è¶…é…¸',  color:[255,255,0,255],   type:TYPES.SUPER_ACID, superAcidic:true, heatResistance:0.3, defaultTemp:20 },
BEDROCK:    { id:21, name:'åŸºå²©',  color:[60,60,60,255],    type:TYPES.BEDROCK, indestructible:true, heatResistance:1.0, defaultTemp:20 },
GLASS:      { id:22, name:'ç»ç’ƒ',  color:[200,220,240,180], type:TYPES.SOLID, transparent:true, heatResistance:0.4, defaultTemp:20 },
LIFE:       { id:23, name:'ç”Ÿå‘½',  color:[255,100,100,255], type:TYPES.LIFE, lifeForm:true, heatResistance:0.3, defaultTemp:37, diesAt:60, freezeAt:0 },
STEAM:      { id:24, name:'è’¸æ±½',  color:[220,240,255,200], type:TYPES.GAS, variance:15, life:300, heatResistance:0.0, defaultTemp:120, condensesAt:99, condenseTo:'WATER' },
ERASER:     { id:99, name:'æ©¡çš®æ“¦',color:[255,255,255,50],  type:TYPES.SOLID, isEraser:true }
};

let currentElement = ELEMENTS.SAND;
let brushSize = 3;
const canvas = document.getElementById('sandbox');
const ctx = canvas.getContext('2d', { alpha:false });
let width, height, grid, imageData, animationId;
let fps = 0, frameCount = 0, lastTime = performance.now();
const fpsUpdateInterval = 500;
const fpsDisplay = document.getElementById('fps-display');
const tempDisplay = document.getElementById('temp-display');

let isPaused = false;
let temperatureSystemEnabled = true;
let temperatures;
let heatTransferSpeed = 5;
let ambientTemperature = 20;

// ç§å­ç”Ÿé•¿è®¡æ—¶
const SEED_GROW_INTERVAL = 120;
// æ¤ç‰©å¸æ”¶æ°´è®¡æ—¶
const PLANT_ABSORB_INTERVAL = 150;
// è—¤è”“ç”Ÿé•¿è®¡æ—¶
const VINE_GROW_INTERVAL = 100;
// å…‹éš†å…ƒç´ å¤åˆ¶è®¡æ—¶
const CLONE_COPY_INTERVAL = 100;
// ç”Ÿå‘½ç§»åŠ¨è®¡æ—¶
const LIFE_MOVE_INTERVAL = 100;

// ç”Ÿé•¿çŠ¶æ€å­˜å‚¨
let seedGrowth = {
positions: [],
heights: [],
directions: [],
maxHeights: [],
growthTime: []
};

// æ¤ç‰©å¸æ°´ç”Ÿé•¿çŠ¶æ€
let plantWaterGrowth = {
positions: [],
waterCount: [],
lastAbsorbTime: [],
growDirections: [],
maxAbsorbCount: []
};

// è—¤è”“ç”Ÿé•¿çŠ¶æ€
let vineGrowth = {
positions: [],
lastGrowTime: [],
directions: [],
spreadCount: []
};

// è¢«ç ´åçš„æ¤ç‰©è®°å½•
let destroyedPlants = {
positions: [],
timestamps: []
};
const DESTROYED_PLANT_TTL = 5000;

// å…‹éš†å…ƒç´ çŠ¶æ€
let cloneElements = {
positions: [],
lastCopyTime: [],
targetElements: [],
copyCount: [],
maxCopyCount: []
};
const MAX_CLONE_COUNT = 100;

// ç”Ÿå‘½å…ƒç´ çŠ¶æ€
let lifeElements = {
positions: [],
lastMoveTime: [],
directions: [],
hunger: [],  // é¥¥é¥¿å€¼
age: [],     // å¹´é¾„
health: []   // å¥åº·å€¼
};
const LIFE_MAX_HUNGER = 100;
const LIFE_MAX_AGE = 1000;
const LIFE_MAX_HEALTH = 100;
const LIFE_BREED_CHANCE = 0.1; // ç¹æ®–æ¦‚ç‡

// çŸ³å¤´è¢«ç‚¸é£çŠ¶æ€
let flyingStones = {
positions: [],
velocitiesX: [],
velocitiesY: [],
timestamps: []
};
const FLYING_STONE_TTL = 3000; // é£è¡Œæ—¶é—´3ç§’

// æ¤ç‰©ç”Ÿé•¿æé™é…ç½®
const GROWTH_LIMITS = {
SEED_MAX_HEIGHT: 30,
MAX_SEED_GROWTH_HEIGHT: 12,
MAX_ABSORB_COUNT: 10,
MAX_VINE_SPREAD: 8,
MAX_PLANT_HEIGHT: 25
};

function togglePause() {
isPaused = !isPaused;
const pauseIcon = document.getElementById('pauseIcon');
const playIcon = document.getElementById('playIcon');
const pausedIndicator = document.getElementById('pausedIndicator');
if (isPaused) {
pauseIcon.style.display = 'none';
playIcon.style.display = 'block';
pausedIndicator.style.display = 'block';
cancelAnimationFrame(animationId);
} else {
pauseIcon.style.display = 'block';
playIcon.style.display = 'none';
pausedIndicator.style.display = 'none';
loop();
}
}

function initGame() {
const container = document.getElementById('game-container');
width = Math.floor(container.clientWidth / CANVAS_SCALE);
height = Math.floor(container.clientHeight / CANVAS_SCALE);
canvas.width = width; canvas.height = height;
grid = new Array(width * height).fill(0);
temperatures = new Float32Array(width * height);
temperatures.fill(ambientTemperature);
imageData = ctx.createImageData(width, height);
for(let i=0; i<imageData.data.length; i+=4) {
imageData.data[i]=0; imageData.data[i+1]=0; imageData.data[i+2]=0; imageData.data[i+3]=255;
}
window.shockWave = new Uint8Array(width * height);
loop();
}

function saveToLocalStorage() {
const saveData = {
grid: Array.from(grid),
timestamp: Date.now()
};
localStorage.setItem('sandboxSaveData', JSON.stringify(saveData));
}

function loadSavedState() {
const savedData = localStorage.getItem('sandboxSaveData');
if (savedData) {
try {
const parsed = JSON.parse(savedData);
if (parsed.grid && parsed.grid.length === grid.length) {
grid = parsed.grid;
temperatures.fill(ambientTemperature);
}
} catch (e) {
console.log('åŠ è½½ä¿å­˜æ•°æ®å¤±è´¥');
}
}
}

const idx = (x, y) => x + y * width;
const inBounds = (x, y) => x>=0 && x<width && y>=0 && y<height;

const sparks = [];
class Spark {
constructor(x,y,vx,vy,restoreId=0){
this.x=x; this.y=y; this.vx=vx; this.vy=vy;
this.life=20;
this.restoreId=restoreId;
}
update(){
this.x+=this.vx; this.y+=this.vy;
this.vy+=0.2;
this.life--;
if(this.y>=height-1 || this.life<=0){
const ix=Math.floor(this.x), iy=Math.floor(this.y);
if(inBounds(ix,iy)){
const i=idx(ix,iy);
if(grid[i]===0){
const el=Object.values(ELEMENTS).find(e=>e.id===this.restoreId);
if(el && (el.type===TYPES.LIQUID||el.type===TYPES.POWDER||el.type===TYPES.HEAVY_SOLID)) grid[i]=this.restoreId;
else grid[i]=ELEMENTS.FIRE.id;
}
}
return true;
}
return false;
}
}

// æ–°å¢ï¼šçŸ³å¤´è¢«ç‚¸é£çš„æ•ˆæœ
class FlyingStone {
constructor(x, y, vx, vy) {
this.x = x;
this.y = y;
this.vx = vx;
this.vy = vy;
this.life = FLYING_STONE_TTL;
this.startTime = performance.now();
}

update() {
const now = performance.now();
const elapsed = now - this.startTime;
this.life = FLYING_STONE_TTL - elapsed;

if (this.life <= 0) {
// è½åœ°å˜æˆæ²™å­
const ix = Math.floor(this.x);
const iy = Math.floor(this.y);
if (inBounds(ix, iy)) {
const i = idx(ix, iy);
if (grid[i] === 0) {
grid[i] = ELEMENTS.SAND.id;
}
}
return true;
}

// æ›´æ–°ä½ç½®ï¼ˆæŠ›ç‰©çº¿è¿åŠ¨ï¼‰
this.x += this.vx;
this.y += this.vy;
this.vy += 0.2; // é‡åŠ›

// è¾¹ç•Œæ£€æŸ¥
if (this.x < 0 || this.x >= width || this.y >= height) {
// å‡ºç•Œå˜æˆæ²™å­
const ix = Math.max(0, Math.min(width - 1, Math.floor(this.x)));
const iy = Math.max(0, Math.min(height - 1, Math.floor(this.y)));
if (inBounds(ix, iy)) {
const i = idx(ix, iy);
if (grid[i] === 0) {
grid[i] = ELEMENTS.SAND.id;
}
}
return true;
}

// ç¢°æ’æ£€æŸ¥
const ix = Math.floor(this.x);
const iy = Math.floor(this.y);
if (inBounds(ix, iy)) {
const i = idx(ix, iy);
if (grid[i] !== 0 && grid[i] !== ELEMENTS.AIR.id) {
// ç¢°åˆ°å…¶ä»–å…ƒç´ ï¼Œå˜æˆæ²™å­
grid[i] = ELEMENTS.SAND.id;
return true;
}
}

return false;
}
}

function addShockWave(cx,cy,r,strength){
const r2=r*r;
for(let dy=-r;dy<=r;dy++){
for(let dx=-r;dx<=r;dx++){
const tx=cx+dx,ty=cy+dy;
if(!inBounds(tx,ty)) continue;
const d2=dx*dx+dy*dy;
if(d2>r2) continue;
const i=idx(tx,ty);
const s = Math.floor(strength * (1 - Math.sqrt(d2)/r));
window.shockWave[i] = Math.min(255, window.shockWave[i] + s);

// æ–°å¢ï¼šçŸ³å¤´è¢«å†²å‡»æ³¢ç‚¸é£
const elemId = grid[i];
if (elemId === ELEMENTS.STONE.id) {
// çŸ³å¤´è¢«ç‚¸é£ï¼Œå˜æˆæ²™å­
grid[i] = ELEMENTS.SAND.id;

// æ·»åŠ é£è¡Œçš„çŸ³å¤´æ•ˆæœ
const force = strength * (1 - Math.sqrt(d2)/r) * 0.1;
const angle = Math.atan2(dy, dx) + (Math.random() - 0.5) * 0.5;
const vx = Math.cos(angle) * force;
const vy = Math.sin(angle) * force - 1.5;

flyingStones.positions.push([tx, ty]);
flyingStones.velocitiesX.push(vx);
flyingStones.velocitiesY.push(vy);
flyingStones.timestamps.push(performance.now());
}
}
}
}

function decayShockWave(){
for(let i=0;i<window.shockWave.length;i++){
if(window.shockWave[i]>0) window.shockWave[i] = Math.max(0, window.shockWave[i] - 8);
}
}

// æ›´æ–°é£è¡Œçš„çŸ³å¤´
function updateFlyingStones() {
for (let i = flyingStones.positions.length - 1; i >= 0; i--) {
const now = performance.now();
const elapsed = now - flyingStones.timestamps[i];

if (elapsed > FLYING_STONE_TTL) {
// é£è¡Œæ—¶é—´ç»“æŸï¼Œå˜æˆæ²™å­
const [x, y] = flyingStones.positions[i];
const ix = Math.floor(x);
const iy = Math.floor(y);
if (inBounds(ix, iy)) {
const idxPos = idx(ix, iy);
if (grid[idxPos] === 0) {
grid[idxPos] = ELEMENTS.SAND.id;
}
}

flyingStones.positions.splice(i, 1);
flyingStones.velocitiesX.splice(i, 1);
flyingStones.velocitiesY.splice(i, 1);
flyingStones.timestamps.splice(i, 1);
continue;
}

// æ›´æ–°ä½ç½®
let [x, y] = flyingStones.positions[i];
let vx = flyingStones.velocitiesX[i];
let vy = flyingStones.velocitiesY[i];

// åº”ç”¨é‡åŠ›
vy += 0.2;

// æ›´æ–°ä½ç½®
x += vx;
y += vy;

// è¾¹ç•Œæ£€æŸ¥
if (x < 0 || x >= width || y >= height) {
// å‡ºç•Œå˜æˆæ²™å­
const ix = Math.max(0, Math.min(width - 1, Math.floor(x)));
const iy = Math.max(0, Math.min(height - 1, Math.floor(y)));
if (inBounds(ix, iy)) {
const idxPos = idx(ix, iy);
if (grid[idxPos] === 0) {
grid[idxPos] = ELEMENTS.SAND.id;
}
}

flyingStones.positions.splice(i, 1);
flyingStones.velocitiesX.splice(i, 1);
flyingStones.velocitiesY.splice(i, 1);
flyingStones.timestamps.splice(i, 1);
continue;
}

// ç¢°æ’æ£€æŸ¥
const ix = Math.floor(x);
const iy = Math.floor(y);
if (inBounds(ix, iy)) {
const idxPos = idx(ix, iy);
const elemId = grid[idxPos];

if (elemId !== 0 && elemId !== ELEMENTS.AIR.id) {
// ç¢°åˆ°å…¶ä»–å…ƒç´ ï¼Œå˜æˆæ²™å­
grid[idxPos] = ELEMENTS.SAND.id;

flyingStones.positions.splice(i, 1);
flyingStones.velocitiesX.splice(i, 1);
flyingStones.velocitiesY.splice(i, 1);
flyingStones.timestamps.splice(i, 1);
continue;
}
}

// ä¿å­˜æ›´æ–°åçš„ä½ç½®å’Œé€Ÿåº¦
flyingStones.positions[i] = [x, y];
flyingStones.velocitiesX[i] = vx;
flyingStones.velocitiesY[i] = vy;
}
}

// ================ æ¸©åº¦ç³»ç»Ÿå‡½æ•° ================
function updateTemperature() {
if (!temperatureSystemEnabled) return;
    
const transferRate = heatTransferSpeed * 0.02;
const ambientEffect = 0.01;
    
const newTemps = new Float32Array(temperatures);
    
for (let i = 0; i < grid.length; i++) {
if (grid[i] === 0) continue;
        
const x = i % width;
const y = Math.floor(i / width);
const elem = Object.values(ELEMENTS).find(e => e.id === grid[i]);
if (!elem) continue;
        
if (elem.heatResistance >= 0.95) continue;
        
const currentTemp = temperatures[i];
let totalTemp = 0;
let neighborCount = 0;
        
const neighbors = [
idx(x, y-1), idx(x, y+1), 
idx(x-1, y), idx(x+1, y)
];
        
for (const ni of neighbors) {
if (ni !== -1) {
const neighborElem = Object.values(ELEMENTS).find(e => e.id === grid[ni]);
if (neighborElem && neighborElem.heatResistance < 0.95) {
totalTemp += temperatures[ni];
neighborCount++;
}
}
}
        
if (neighborCount > 0) {
const avgTemp = totalTemp / neighborCount;
const tempDiff = avgTemp - currentTemp;
const heatTransfer = tempDiff * transferRate * (1 - elem.heatResistance);
            
newTemps[i] += heatTransfer;
newTemps[i] += (ambientTemperature - newTemps[i]) * ambientEffect;
}
        
if (elem.heatEmission) {
newTemps[i] += elem.heatEmission * 0.1;
}
        
applyTemperatureEffects(i, x, y, newTemps[i]);
}
    
temperatures.set(newTemps);
    
for (let i = 0; i < temperatures.length; i++) {
if (temperatures[i] < -100) temperatures[i] = -100;
if (temperatures[i] > 2000) temperatures[i] = 2000;
}
}

function applyTemperatureEffects(i, x, y, temp) {
const elemId = grid[i];
const elem = Object.values(ELEMENTS).find(e => e.id === elemId);
if (!elem) return;
    
// å†°èåŒ–ï¼ˆå½“æ¸©åº¦å¤§äº0Â°Cæ—¶ï¼‰
if (elemId === ELEMENTS.ICE.id && temp > 0) {
grid[i] = ELEMENTS.WATER.id;
temperatures[i] = Math.max(temp, 5);
return;
}
    
// æ°´ç»“å†°ï¼ˆå½“æ¸©åº¦å°äºç­‰äº0Â°Cæ—¶ï¼‰
if (elemId === ELEMENTS.WATER.id && temp <= 0) {
grid[i] = ELEMENTS.ICE.id;
temperatures[i] = Math.min(temp, -5);
return;
}
    
// æ°´æ²¸è…¾å˜æˆè’¸æ±½
if (elemId === ELEMENTS.WATER.id && elem.boilsAt && temp > elem.boilsAt) {
if (Math.random() < 0.05) {
grid[i] = ELEMENTS.STEAM.id;
temperatures[i] = 120;
}
return;
}
    
// è’¸æ±½å‡ç»“
if (elemId === ELEMENTS.STEAM.id && elem.condensesAt && temp < elem.condensesAt) {
grid[i] = ELEMENTS.WATER.id;
temperatures[i] = Math.min(temp, 95);
return;
}
    
// ç‰©è´¨ç‡ƒçƒ§
if (elem.flammable && elem.ignitesAt && temp > elem.ignitesAt) {
if (Math.random() < 0.01) {
grid[i] = ELEMENTS.FIRE.id;
temperatures[i] = 500;
markAsDestroyed(i);
removeGrowthRecords(i);
}
return;
}
    
// æ²™å­ç†”åŒ–å½¢æˆç»ç’ƒ
if (elemId === ELEMENTS.SAND.id && elem.meltsAt && temp > elem.meltsAt) {
if (Math.random() < 0.001) {
grid[i] = ELEMENTS.GLASS.id;
}
return;
}
    
// ç”Ÿå‘½æ­»äº¡
if (elemId === ELEMENTS.LIFE.id) {
if ((elem.diesAt && temp > elem.diesAt) || (elem.freezeAt && temp < elem.freezeAt)) {
if (Math.random() < 0.01) {
grid[i] = 0;
removeGrowthRecords(i);
}
}
}
}

function toggleTemperatureSystem() {
temperatureSystemEnabled = document.getElementById('tempToggle').checked;
tempDisplay.textContent = temperatureSystemEnabled ? 
`æ¸©åº¦ç³»ç»Ÿ: å¼€å¯ (${ambientTemperature}Â°C)` : 'æ¸©åº¦ç³»ç»Ÿ: å…³é—­';
    
if (!temperatureSystemEnabled) {
temperatures.fill(ambientTemperature);
}
}

// æ¸©åº¦UIæ§åˆ¶
document.getElementById('heatTransferSpeed').addEventListener('input', function() {
heatTransferSpeed = parseInt(this.value);
document.getElementById('heatTransferValue').textContent = heatTransferSpeed;
});

document.getElementById('ambientTemp').addEventListener('input', function() {
ambientTemperature = parseInt(this.value);
document.getElementById('ambientTempValue').textContent = `${ambientTemperature}Â°C`;
tempDisplay.textContent = temperatureSystemEnabled ? 
`æ¸©åº¦ç³»ç»Ÿ: å¼€å¯ (${ambientTemperature}Â°C)` : 'æ¸©åº¦ç³»ç»Ÿ: å…³é—­';
    
if (!temperatureSystemEnabled) {
temperatures.fill(ambientTemperature);
}
});

// ================ æ°”ä½“æ”¹è¿›å‡½æ•° ================
// æ”¹è¿›çš„æ°”ä½“ç§»åŠ¨å‡½æ•° - éšæœºä¸Šä¸‹å·¦å³ç§»åŠ¨ï¼Œä½†å€¾å‘äºå‘ä¸Š
function updateGasImproved(x, y, i, elem) {
// ç«ç„°å’ŒçƒŸé›¾çš„ç‰¹æ®Šå¤„ç†
if (elem.id === ELEMENTS.FIRE.id) {
updateFireImproved(x, y, i);
return;
}
if (elem.id === ELEMENTS.SMOKE.id) {
updateSmokeImproved(x, y, i);
return;
}
if (elem.id === ELEMENTS.FUEL_GAS.id) {
updateFuelGasImproved(x, y, i);
return;
}
if (elem.id === ELEMENTS.GAS.id) {
updateSteamImproved(x, y, i);
return;
}
    
// æ™®é€šæ°”ä½“ï¼ˆç©ºæ°”ç­‰ï¼‰çš„éšæœºç§»åŠ¨
const directions = [
[0, -1, 0.4],  // ä¸Šï¼Œ40%æ¦‚ç‡
[0, 1, 0.1],   // ä¸‹ï¼Œ10%æ¦‚ç‡
[-1, 0, 0.25], // å·¦ï¼Œ25%æ¦‚ç‡
[1, 0, 0.25]   // å³ï¼Œ25%æ¦‚ç‡
];
    
// æŒ‰æ¦‚ç‡é€‰æ‹©æ–¹å‘
let rand = Math.random();
let selectedDir = [0, 0];
for (const [dx, dy, prob] of directions) {
if (rand < prob) {
selectedDir = [dx, dy];
break;
}
rand -= prob;
}
    
const newX = x + selectedDir[0];
const newY = y + selectedDir[1];
    
if (inBounds(newX, newY)) {
const ni = idx(newX, newY);
if (grid[ni] === 0) {
swap(i, ni);
}
}
}

function updateFireImproved(x, y, i) {
// ç«ç„°ç”Ÿå‘½å‘¨æœŸ
if (Math.random() < 0.12) { 
grid[i] = ELEMENTS.SMOKE.id; 
return; 
}
    
// ç«ç„°äº§ç”Ÿçƒ­é‡
if (temperatureSystemEnabled) {
temperatures[i] = Math.min(800, temperatures[i] + 5);
}
    
// ç«ç„°ä¼ æ’­
const around = [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [-1, 1], [1, -1], [-1, -1]];
for (let [dx, dy] of around) {
const ni = idx(x + dx, y + dy);
if (!inBounds(x + dx, y + dy)) continue;
const neighborId = grid[ni];
if (neighborId === ELEMENTS.LAVA.id) continue;
const neighbor = Object.values(ELEMENTS).find(e => e.id === neighborId);
if (neighbor && neighbor.flammable && Math.random() < 0.25) {
grid[ni] = ELEMENTS.FIRE.id;
markAsDestroyed(ni);
removeGrowthRecords(ni);
}
if (neighbor && neighbor.meltable && Math.random() < 0.15) grid[ni] = ELEMENTS.WATER.id;
}
    
// ç«ç„°å‘ä¸Šé£˜ï¼Œä½†æœ‰ä¸€å®šéšæœºæ€§
const dirs = [
[0, -1, 0.6],  // å‘ä¸Šæ¦‚ç‡60%
[-1, -1, 0.15], // å·¦ä¸Šæ¦‚ç‡15%
[1, -1, 0.15],  // å³ä¸Šæ¦‚ç‡15%
[-1, 0, 0.05],  // å·¦æ¦‚ç‡5%
[1, 0, 0.05]    // å³æ¦‚ç‡5%
];
    
let rand = Math.random();
let selectedDir = [0, 0];
for (const [dx, dy, prob] of dirs) {
if (rand < prob) {
selectedDir = [dx, dy];
break;
}
rand -= prob;
}
    
const newX = x + selectedDir[0];
const newY = y + selectedDir[1];
    
if (inBounds(newX, newY)) {
const ni = idx(newX, newY);
if (grid[ni] === 0 || isLiquid(grid[ni]) || isWaterLike(grid[ni])) {
swap(i, ni);
}
}
}

function updateSmokeImproved(x, y, i) {
if (Math.random() < 0.012) { 
grid[i] = 0; 
return; 
}
    
// çƒŸé›¾å‘ä¸Šé£˜ï¼Œæ›´éšæœº
const dirs = [
[0, -1, 0.5],  // å‘ä¸Š50%
[-1, -1, 0.2], // å·¦ä¸Š20%
[1, -1, 0.2],  // å³ä¸Š20%
[-1, 0, 0.05], // å·¦5%
[1, 0, 0.05]   // å³5%
];
    
let rand = Math.random();
let selectedDir = [0, 0];
for (const [dx, dy, prob] of dirs) {
if (rand < prob) {
selectedDir = [dx, dy];
break;
}
rand -= prob;
}
    
const newX = x + selectedDir[0];
const newY = y + selectedDir[1];
    
if (inBounds(newX, newY)) {
const ni = idx(newX, newY);
if (grid[ni] === 0) {
swap(i, ni);
}
}
}

function updateFuelGasImproved(x, y, i) {
// æ£€æŸ¥æ˜¯å¦æ¥è§¦ç«ç„°
const aroundFire = [[0, 1], [0, -1], [1, 0], [-1, 0]].some(([dx, dy]) => {
const ni = idx(x + dx, y + dy);
return inBounds(x + dx, y + dy) && grid[ni] === ELEMENTS.FIRE.id;
});
    
if (aroundFire) {
grid[i] = 0;
for (let dy2 = -1; dy2 <= 1; dy2++) {
for (let dx2 = -1; dx2 <= 1; dx2++) {
const tx = x + dx2, ty = y + dy2;
if (!inBounds(tx, ty)) continue;
const ti = idx(tx, ty);
const target = grid[ti];
const targetElem = Object.values(ELEMENTS).find(e => e.id === target);
if (target === ELEMENTS.WALL.id) { grid[ti] = ELEMENTS.STONE.id; continue; }
if (target === 0 || !targetElem || targetElem.type !== TYPES.SOLID) {
const vx = (dx2 + Math.random() * 0.4 - 0.2) * 0.7;
const vy = (dy2 + Math.random() * 0.4 - 0.2) * 0.7 - 0.8;
sparks.push(new Spark(tx, ty, vx, vy, target));
if (grid[ti] === 0) grid[ti] = ELEMENTS.FIRE.id;
}
}
}
return;
}
    
// ç‡ƒæ°”å‘ä¸Šé£˜ï¼Œéšæœºæ€§æ›´å¼º
const dirs = [
[0, -1, 0.0],  // å‘ä¸Š40%
[-1, 0, 0.2],  // å·¦20%
[1, 0, 0.2],   // å³20%
[-1, -1, 0.1], // å·¦ä¸Š10%
[1, -1, 0.1]   // å³ä¸Š10%
];
    
let rand = Math.random();
let selectedDir = [0, 0];
for (const [dx, dy, prob] of dirs) {
if (rand < prob) {
selectedDir = [dx, dy];
break;
}
rand -= prob;
}
    
const newX = x + selectedDir[0];
const newY = y + selectedDir[1];
    
if (inBounds(newX, newY)) {
const ni = idx(newX, newY);
const tgt = grid[ni];
const tgtEl = Object.values(ELEMENTS).find(e => e.id === tgt);
if (tgt === 0 || tgtEl?.type === TYPES.LIQUID || tgtEl?.type === TYPES.POWDER) { 
swap(i, ni); 
return; 
}
}
}

function updateSteamImproved(x, y, i) {
    // è’¸æ±½åƒäº‘é›¾ä¸€æ ·æ‰©æ•£ï¼Œéšæœºæ€§æ›´å¼º
    const dirs = [
        [0, -1, 0.35],   // å‘ä¸Š35% (æ¸©åº¦é«˜æ—¶ä¸Šå‡)
        [-1, -1, 0.08],  // å·¦ä¸Š8%
        [1, -1, 0.08],   // å³ä¸Š8%
        [-1, 0, 0.16],   // å·¦16%
        [1, 0, 0.16],    // å³16%
        [0, 1, 0.1],     // å‘ä¸‹10% (æ¸©åº¦ä¸‹é™æ—¶)
        [-1, 1, 0.05],   // å·¦ä¸‹5%
        [1, 1, 0.05]     // å³ä¸‹5%
    ];
    
    // å¦‚æœæ¸©åº¦è¾ƒé«˜ï¼Œæ›´å€¾å‘äºå‘ä¸Š
    if (temperatureSystemEnabled && temperatures[i] > 120) {
        dirs[0][2] = 0.45;  // å‘ä¸Šæ¦‚ç‡å¢åŠ åˆ°45%
        dirs[5][2] = 0.05;  // å‘ä¸‹æ¦‚ç‡å‡å°‘åˆ°5%
    }
    
    let rand = Math.random();
    let selectedDir = [0, 0];
    for (const [dx, dy, prob] of dirs) {
        if (rand < prob) {
            selectedDir = [dx, dy];
            break;
        }
        rand -= prob;
    }
    
    const newX = x + selectedDir[0];
    const newY = y + selectedDir[1];
    
    if (inBounds(newX, newY)) {
        const ni = idx(newX, newY);
        const targetId = grid[ni];
        
        // è’¸æ±½å¯ä»¥ç©¿è¿‡å¤§éƒ¨åˆ†æ°”ä½“å’Œç©ºä½
        if (targetId === 0 || 
            targetId === ELEMENTS.AIR.id ||
            targetId === ELEMENTS.SMOKE.id ||
            targetId === ELEMENTS.GAS_FUEL.id) {
            swap(i, ni);
        }
    }
}

// ================ åŸæœ‰å‡½æ•°ï¼ˆä¿æŒå®Œæ•´ï¼‰ ================
// æ£€æŸ¥ç§å­æ˜¯å¦éœ€è¦å¼€å§‹ç”Ÿé•¿
function checkSeedGrowth(x, y) {
const i = idx(x, y);

if (isRecentlyDestroyed(i)) {
return;
}

const below = idx(x, y + 1);
if (y + 1 < height && (grid[below] === ELEMENTS.SAND.id ||
grid[below] === ELEMENTS.PLANT.id ||
grid[below] === ELEMENTS.VINE.id ||
grid[below] === ELEMENTS.STONE.id)) {
const existingIdx = seedGrowth.positions.indexOf(i);
if (existingIdx === -1) {
seedGrowth.positions.push(i);
seedGrowth.heights.push(0);
seedGrowth.directions.push(0);
seedGrowth.maxHeights.push(8 + Math.floor(Math.random() * (GROWTH_LIMITS.MAX_SEED_GROWTH_HEIGHT - 8 + 1)));
seedGrowth.growthTime.push(performance.now());
}
}
}

// æ›´æ–°ç§å­ç”Ÿé•¿
function updateSeedGrowth(now) {
for (let j = 0; j < seedGrowth.positions.length; j++) {
const pos = seedGrowth.positions[j];
const lastTime = seedGrowth.growthTime[j];
const currentHeight = seedGrowth.heights[j];
const currentDir = seedGrowth.directions[j];
const maxHeight = seedGrowth.maxHeights[j];

if (now - lastTime >= SEED_GROW_INTERVAL && currentHeight < maxHeight) {
const x = pos % width;
const y = Math.floor(pos / width);

if (y - currentHeight < 0) {
seedGrowth.heights[j] = maxHeight;
continue;
}

const growY = y - currentHeight - 1;

if (growY >= 0) {
const growIdx = idx(x, growY);
if (isRecentlyDestroyed(growIdx)) {
continue;
}

let newDir = currentDir;
if (Math.random() < 0.3) {
newDir = Math.floor(Math.random() * 3) - 1;
}

const newX = Math.max(0, Math.min(width - 1, x + newDir));
const finalGrowIdx = idx(newX, growY);

if (isRecentlyDestroyed(finalGrowIdx)) {
continue;
}

if (grid[finalGrowIdx] === 0) {
if (Math.random() < 0.7) {
grid[finalGrowIdx] = ELEMENTS.PLANT.id;
} else {
grid[finalGrowIdx] = ELEMENTS.VINE.id;
vineGrowth.positions.push(finalGrowIdx);
vineGrowth.lastGrowTime.push(now);
vineGrowth.directions.push(newDir);
vineGrowth.spreadCount.push(0);
}

seedGrowth.heights[j] = currentHeight + 1;
seedGrowth.directions[j] = newDir;
seedGrowth.growthTime[j] = now;

if (Math.random() < 0.2 && currentHeight > 3) {
const leafDir = Math.random() > 0.5 ? 1 : -1;
const leafX = Math.max(0, Math.min(width - 1, newX + leafDir));
const leafIdx = idx(leafX, growY);
if (grid[leafIdx] === 0 && !isRecentlyDestroyed(leafIdx)) {
grid[leafIdx] = ELEMENTS.LEAF.id;
}
}

if (seedGrowth.heights[j] === maxHeight) {
grid[finalGrowIdx] = ELEMENTS.FLOWER.id;
seedGrowth.positions.splice(j, 1);
seedGrowth.heights.splice(j, 1);
seedGrowth.directions.splice(j, 1);
seedGrowth.maxHeights.splice(j, 1);
seedGrowth.growthTime.splice(j, 1);
j--;
}
}
}
}
}
}

// æ£€æŸ¥æ¤ç‰©æ˜¯å¦æ¥è§¦æ°´å¹¶å¼€å§‹å¸æ”¶
function checkPlantWaterAbsorption(x, y) {
const i = idx(x, y);
const elemId = grid[i];

if (elemId !== ELEMENTS.PLANT.id &&
elemId !== ELEMENTS.FLOWER.id ||
elemId !== ELEMENTS.VINE.id ||
elemId !== ELEMENTS.LEAF.id) {
return;
}

const neighbors = [
[x, y + 1],
[x, y - 1],
[x + 1, y],
[x - 1, y]
];

for (const [nx, ny] of neighbors) {
if (inBounds(nx, ny)) {
const ni = idx(nx, ny);
if (grid[ni] === ELEMENTS.WATER.id) {
const existingIdx = plantWaterGrowth.positions.indexOf(i);
if (existingIdx === -1) {
plantWaterGrowth.positions.push(i);
plantWaterGrowth.waterCount.push(1);
plantWaterGrowth.lastAbsorbTime.push(performance.now());
plantWaterGrowth.growDirections.push(Math.floor(Math.random() * 3) - 1);
plantWaterGrowth.maxAbsorbCount.push(GROWTH_LIMITS.MAX_ABSORB_COUNT);
} else {
plantWaterGrowth.lastAbsorbTime[existingIdx] = performance.now();
}
break;
}
}
}
}

// æ›´æ–°æ¤ç‰©å¸æ°´ç”Ÿé•¿
function updatePlantWaterGrowth(now) {
for (let j = 0; j < plantWaterGrowth.positions.length; j++) {
const pos = plantWaterGrowth.positions[j];
const lastTime = plantWaterGrowth.lastAbsorbTime[j];
const waterCount = plantWaterGrowth.waterCount[j];
const growDir = plantWaterGrowth.growDirections[j];
const maxAbsorbCount = plantWaterGrowth.maxAbsorbCount[j];

if (waterCount >= maxAbsorbCount) {
plantWaterGrowth.positions.splice(j, 1);
plantWaterGrowth.waterCount.splice(j, 1);
plantWaterGrowth.lastAbsorbTime.splice(j, 1);
plantWaterGrowth.growDirections.splice(j, 1);
plantWaterGrowth.maxAbsorbCount.splice(j, 1);
j--;
continue;
}

if (now - lastTime >= PLANT_ABSORB_INTERVAL) {
const x = pos % width;
const y = Math.floor(pos / width);

let waterFound = false;
const neighbors = [
[x, y + 1],
[x, y - 1],
[x + 1, y],
[x - 1, y]
];

for (const [nx, ny] of neighbors) {
if (inBounds(nx, ny)) {
const ni = idx(nx, ny);
if (grid[ni] === ELEMENTS.WATER.id) {
waterFound = true;

if (Math.random() < 0.6) {
if (isRecentlyDestroyed(ni)) {
grid[ni] = 0;
} else {
const rand = Math.random();
if (rand < 0.4) {
grid[ni] = ELEMENTS.PLANT.id;
} else if (rand < 0.7) {
grid[ni] = ELEMENTS.VINE.id;
} else {
if (Math.random() < 0.1) {
grid[ni] = ELEMENTS.FLOWER.id;
} else {
grid[ni] = ELEMENTS.LEAF.id;
}
}
}

plantWaterGrowth.waterCount[j]++;

if (Math.random() < 0.3 && waterCount < maxAbsorbCount - 2) {
const upX = Math.max(0, Math.min(width - 1, x + growDir));
const upY = y - 1;
if (upY >= 0) {
const upIdx = idx(upX, upY);
if (grid[upIdx] === 0 && !isRecentlyDestroyed(upIdx)) {
if (Math.random() < 0.5) {
grid[upIdx] = ELEMENTS.PLANT.id;
} else {
grid[upIdx] = ELEMENTS.VINE.id;
}
plantWaterGrowth.waterCount[j]++;
}
}
}
} else {
grid[ni] = 0;
plantWaterGrowth.waterCount[j]++;
}

plantWaterGrowth.lastAbsorbTime[j] = now;
break;
}
}
}

if (!waterFound) {
plantWaterGrowth.positions.splice(j, 1);
plantWaterGrowth.waterCount.splice(j, 1);
plantWaterGrowth.lastAbsorbTime.splice(j, 1);
plantWaterGrowth.growDirections.splice(j, 1);
plantWaterGrowth.maxAbsorbCount.splice(j, 1);
j--;
}
}
}
}

// æ›´æ–°è—¤è”“ç”Ÿé•¿
function updateVineGrowth(now) {
for (let j = 0; j < vineGrowth.positions.length; j++) {
const pos = vineGrowth.positions[j];
const lastTime = vineGrowth.lastGrowTime[j];
const dir = vineGrowth.directions[j];
const spreadCount = vineGrowth.spreadCount[j];

if (spreadCount >= GROWTH_LIMITS.MAX_VINE_SPREAD) {
vineGrowth.positions.splice(j, 1);
vineGrowth.lastGrowTime.splice(j, 1);
vineGrowth.directions.splice(j, 1);
vineGrowth.spreadCount.splice(j, 1);
j--;
continue;
}

if (now - lastTime >= VINE_GROW_INTERVAL) {
const x = pos % width;
const y = Math.floor(pos / width);

const possibleDirections = [
[x, y - 1, 0],
[x - 1, y, -1],
[x + 1, y, 1]
];

const randomIndex = Math.floor(Math.random() * possibleDirections.length);
const [newX, newY, newDir] = possibleDirections[randomIndex];

if (inBounds(newX, newY)) {
const newIdx = idx(newX, newY);
if (grid[newIdx] === 0) {
if (isRecentlyDestroyed(newIdx)) {
vineGrowth.lastGrowTime[j] = now;
continue;
}

if (Math.random() < 0.5) {
grid[newIdx] = ELEMENTS.VINE.id;

vineGrowth.positions[j] = newIdx;
vineGrowth.directions[j] = newDir;
vineGrowth.spreadCount[j] = spreadCount + 1;
vineGrowth.lastGrowTime[j] = now;

if (Math.random() < 0.2) {
const leafDir = Math.random() > 0.5 ? 1 : -1;
const leafX = Math.max(0, Math.min(width - 1, newX + leafDir));
const leafIdx = idx(leafX, newY);
if (inBounds(leafX, newY) && grid[leafIdx] === 0 && !isRecentlyDestroyed(leafIdx)) {
grid[leafIdx] = ELEMENTS.LEAF.id;
}
}
}
}
}

vineGrowth.lastGrowTime[j] = now;
}
}
}

// æ£€æŸ¥å…‹éš†å…ƒç´ å¹¶å¼€å§‹å¤åˆ¶å‘¨å›´å…ƒç´ 
function checkCloneElement(x, y) {
const i = idx(x, y);

const existingIdx = cloneElements.positions.indexOf(i);
if (existingIdx === -1) {
cloneElements.positions.push(i);
cloneElements.lastCopyTime.push(performance.now());
cloneElements.targetElements.push(0);
cloneElements.copyCount.push(0);
cloneElements.maxCopyCount.push(MAX_CLONE_COUNT);
}
}

// æ›´æ–°å…‹éš†å…ƒç´ 
function updateCloneElements(now) {
for (let j = 0; j < cloneElements.positions.length; j++) {
const pos = cloneElements.positions[j];
const lastTime = cloneElements.lastCopyTime[j];
let targetElement = cloneElements.targetElements[j];
const copyCount = cloneElements.copyCount[j];
const maxCopyCount = cloneElements.maxCopyCount[j];

if (copyCount >= maxCopyCount) {
cloneElements.positions.splice(j, 1);
cloneElements.lastCopyTime.splice(j, 1);
cloneElements.targetElements.splice(j, 1);
cloneElements.copyCount.splice(j, 1);
cloneElements.maxCopyCount.splice(j, 1);
j--;
continue;
}

if (now - lastTime >= CLONE_COPY_INTERVAL) {
const x = pos % width;
const y = Math.floor(pos / width);

if (targetElement === 0) {
const neighbors = [
[x, y + 1],
[x, y - 1],
[x + 1, y],
[x - 1, y],
[x + 1, y + 1],
[x - 1, y + 1],
[x + 1, y - 1],
[x - 1, y - 1]
];

const nearbyElements = [];
for (const [nx, ny] of neighbors) {
if (inBounds(nx, ny)) {
const ni = idx(nx, ny);
const elemId = grid[ni];
if (elemId !== 0 && elemId !== ELEMENTS.CLONE.id && elemId !== ELEMENTS.ERASER.id) {
nearbyElements.push(elemId);
}
}
}

if (nearbyElements.length > 0) {
targetElement = nearbyElements[Math.floor(Math.random() * nearbyElements.length)];
cloneElements.targetElements[j] = targetElement;
} else {
cloneElements.lastCopyTime[j] = now;
continue;
}
}

const emptySpots = [];
const neighborOffsets = [
[0, 1],
[0, -1],
[1, 0],
[-1, 0],
[1, 1],
[-1, 1],
[1, -1],
[-1, -1]
];

for (const [dx, dy] of neighborOffsets) {
const nx = x + dx;
const ny = y + dy;
if (inBounds(nx, ny)) {
const ni = idx(nx, ny);
if (grid[ni] === 0 ||
grid[ni] === ELEMENTS.SMOKE.id ||
grid[ni] === ELEMENTS.GAS_FUEL.id) {
emptySpots.push([nx, ny, ni]);
}
}
}

if (emptySpots.length > 0) {
const numCopies = Math.min(emptySpots.length, Math.floor(Math.random() * 3) + 1);

for (let k = 0; k < numCopies; k++) {
if (emptySpots.length === 0) break;

const randomIndex = Math.floor(Math.random() * emptySpots.length);
const [copyX, copyY, copyIdx] = emptySpots[randomIndex];

grid[copyIdx] = targetElement;

emptySpots.splice(randomIndex, 1);

cloneElements.copyCount[j]++;

if (targetElement === ELEMENTS.SEED.id) {
checkSeedGrowth(copyX, copyY);
}

if (targetElement === ELEMENTS.PLANT.id ||
targetElement === ELEMENTS.FLOWER.id ||
targetElement === ELEMENTS.VINE.id ||
targetElement === ELEMENTS.LEAF.id) {
checkPlantWaterAbsorption(copyX, copyY);
}
}

cloneElements.lastCopyTime[j] = now;
} else {
cloneElements.lastCopyTime[j] = now;
}
}
}
}

// æ£€æŸ¥ç”Ÿå‘½å…ƒç´ 
function checkLifeElement(x, y) {
const i = idx(x, y);

const existingIdx = lifeElements.positions.indexOf(i);
if (existingIdx === -1) {
lifeElements.positions.push(i);
lifeElements.lastMoveTime.push(performance.now());
lifeElements.directions.push(Math.floor(Math.random() * 3) - 1); // -1, 0, 1
lifeElements.hunger.push(LIFE_MAX_HUNGER / 2); // åˆå§‹åŠé¥±
lifeElements.age.push(0);
lifeElements.health.push(LIFE_MAX_HEALTH);
}
}

// æ›´æ–°ç”Ÿå‘½å…ƒç´ 
function updateLifeElements(now) {
for (let j = 0; j < lifeElements.positions.length; j++) {
const pos = lifeElements.positions[j];
const lastTime = lifeElements.lastMoveTime[j];
let dir = lifeElements.directions[j];
let hunger = lifeElements.hunger[j];
let age = lifeElements.age[j];
let health = lifeElements.health[j];

// å¢åŠ å¹´é¾„
age += 1;
if (age > LIFE_MAX_AGE) {
// æ­»äº¡ï¼Œå˜æˆç©ºæ°”
grid[pos] = 0;
lifeElements.positions.splice(j, 1);
lifeElements.lastMoveTime.splice(j, 1);
lifeElements.directions.splice(j, 1);
lifeElements.hunger.splice(j, 1);
lifeElements.age.splice(j, 1);
lifeElements.health.splice(j, 1);
j--;
continue;
}

// å‡å°‘é¥¥é¥¿å€¼
hunger -= 0.5;
if (hunger <= 0) {
// é¥¿æ­»ï¼Œå˜æˆç©ºæ°”
grid[pos] = 0;
lifeElements.positions.splice(j, 1);
lifeElements.lastMoveTime.splice(j, 1);
lifeElements.directions.splice(j, 1);
lifeElements.hunger.splice(j, 1);
lifeElements.age.splice(j, 1);
lifeElements.health.splice(j, 1);
j--;
continue;
}

// æ£€æŸ¥æ˜¯å¦åº”è¯¥ç§»åŠ¨
if (now - lastTime >= LIFE_MOVE_INTERVAL) {
const x = pos % width;
const y = Math.floor(pos / width);

// æ£€æŸ¥å‘¨å›´æ˜¯å¦æœ‰æ¤ç‰©å¯ä»¥åƒ
const neighbors = [
[x, y + 1],
[x, y - 1],
[x + 1, y],
[x - 1, y]
];

let atePlant = false;
for (const [nx, ny] of neighbors) {
if (inBounds(nx, ny)) {
const ni = idx(nx, ny);
const elemId = grid[ni];
// å¯ä»¥åƒçš„æ¤ç‰©
if (elemId === ELEMENTS.PLANT.id ||
elemId === ELEMENTS.FLOWER.id ||
elemId === ELEMENTS.VINE.id ||
elemId === ELEMENTS.LEAF.id ||
elemId === ELEMENTS.SEED.id) {
// åƒæ‰æ¤ç‰©
grid[ni] = 0;
destroyPlantAt(nx, ny);
hunger = Math.min(LIFE_MAX_HUNGER, hunger + 30); // å¢åŠ é¥¥é¥¿å€¼
atePlant = true;
break;
}
}
}

if (!atePlant) {
// éšæœºç§»åŠ¨
if (Math.random() < 0.3) { // 30%æ¦‚ç‡æ”¹å˜æ–¹å‘
dir = Math.floor(Math.random() * 3) - 1;
lifeElements.directions[j] = dir;
}

// å°è¯•ç§»åŠ¨
const moveX = Math.max(0, Math.min(width - 1, x + dir));
const moveIdx = idx(moveX, y);

// æ£€æŸ¥æ˜¯å¦å¯ä»¥ç§»åŠ¨
if (grid[moveIdx] === 0) {
// ç§»åŠ¨åˆ°æ–°ä½ç½®
grid[pos] = 0;
grid[moveIdx] = ELEMENTS.LIFE.id;
lifeElements.positions[j] = moveIdx;

// æ£€æŸ¥ç¹æ®–
if (Math.random() < LIFE_BREED_CHANCE) {
// æ£€æŸ¥å‘¨å›´æ˜¯å¦æœ‰ç©ºä½ç¹æ®–
const breedSpots = [];
const breedOffsets = [
[0, 1], [0, -1], [1, 0], [-1, 0]
];

for (const [dx, dy] of breedOffsets) {
const bx = moveX + dx;
const by = y + dy;
if (inBounds(bx, by)) {
const bi = idx(bx, by);
if (grid[bi] === 0) {
breedSpots.push([bx, by, bi]);
}
}
}

if (breedSpots.length > 0 && hunger > LIFE_MAX_HUNGER * 0.7) {
// ç¹æ®–ä¸€ä¸ªæ–°ç”Ÿå‘½
const randomSpot = breedSpots[Math.floor(Math.random() * breedSpots.length)];
const [bx, by, bi] = randomSpot;
grid[bi] = ELEMENTS.LIFE.id;
hunger -= 20; // ç¹æ®–æ¶ˆè€—èƒ½é‡

// è®°å½•æ–°ç”Ÿå‘½
lifeElements.positions.push(bi);
lifeElements.lastMoveTime.push(now);
lifeElements.directions.push(Math.floor(Math.random() * 3) - 1);
lifeElements.hunger.push(LIFE_MAX_HUNGER * 0.5);
lifeElements.age.push(0);
lifeElements.health.push(LIFE_MAX_HEALTH);
}
}
} else {
// ä¸èƒ½ç§»åŠ¨ï¼Œå°è¯•å‘ä¸Šæˆ–å‘ä¸‹
const tryUp = y - 1 >= 0 ? idx(moveX, y - 1) : -1;
const tryDown = y + 1 < height ? idx(moveX, y + 1) : -1;

if (tryUp !== -1 && grid[tryUp] === 0) {
// å‘ä¸Šè·³
grid[pos] = 0;
grid[tryUp] = ELEMENTS.LIFE.id;
lifeElements.positions[j] = tryUp;
} else if (tryDown !== -1 && grid[tryDown] === 0) {
// å‘ä¸‹è·³
grid[pos] = 0;
grid[tryDown] = ELEMENTS.LIFE.id;
lifeElements.positions[j] = tryDown;
}
}
}

// æ›´æ–°çŠ¶æ€
lifeElements.hunger[j] = hunger;
lifeElements.age[j] = age;
lifeElements.health[j] = health;
lifeElements.lastMoveTime[j] = now;
}
}
}

// æ£€æŸ¥æ¤ç‰©é«˜åº¦é™åˆ¶
function checkPlantHeightLimit(x, y) {
let height = 0;
let currentY = y;

while (currentY >= 0) {
const currentIdx = idx(x, currentY);
const elemId = grid[currentIdx];

if (elemId === ELEMENTS.PLANT.id ||
elemId === ELEMENTS.VINE.id ||
elemId === ELEMENTS.LEAF.id ||
elemId === ELEMENTS.FLOWER.id) {
height++;
currentY--;

if (height > GROWTH_LIMITS.MAX_PLANT_HEIGHT) {
grid[currentIdx] = 0;
removeGrowthRecords(currentIdx);
markAsDestroyed(currentIdx);
}
} else {
break;
}
}
}

// æ°´ä¸çŸ³æ²¹çš„åŒ–å­¦ååº”
function checkWaterOilReaction(x, y) {
const i = idx(x, y);
const elemId = grid[i];

if (elemId !== ELEMENTS.WATER.id) {
return;
}

const neighbors = [
[x, y + 1],
[x, y - 1],
[x + 1, y],
[x - 1, y]
];

for (const [nx, ny] of neighbors) {
if (inBounds(nx, ny)) {
const ni = idx(nx, ny);
if (grid[ni] === ELEMENTS.OIL.id) {
if (Math.random() < 0.15) {
grid[i] = ELEMENTS.OIL.id;
return;
}
}
}
}
}

// çŸ³æ²¹ä¸æ°´çš„åŒ–å­¦ååº”
function checkOilWaterReaction(x, y) {
const i = idx(x, y);
const elemId = grid[i];

if (elemId !== ELEMENTS.OIL.id) {
return;
}

const neighbors = [
[x, y + 1],
[x, y - 1],
[x + 1, y],
[x - 1, y]
];

for (const [nx, ny] of neighbors) {
if (inBounds(nx, ny)) {
const ni = idx(nx, ny);
if (grid[ni] === ELEMENTS.WATER.id) {
if (Math.random() < 0.2) {
grid[ni] = ELEMENTS.OIL.id;
return;
}
}
}
}
}

// è¶…é…¸çš„åŒ–å­¦ååº”
function checkSuperAcidReaction(x, y) {
const i = idx(x, y);
const elemId = grid[i];

if (elemId !== ELEMENTS.SUPER_ACID.id) {
return;
}

const neighbors = [
[x, y + 1],
[x, y - 1],
[x + 1, y],
[x - 1, y]
];

for (const [nx, ny] of neighbors) {
if (inBounds(nx, ny)) {
const ni = idx(nx, ny);
const neighborId = grid[ni];

// è¶…é…¸ä¸æ°´ååº”ï¼šæ°´å˜æˆé…¸æ¶²ï¼Œè¶…é…¸æ¶ˆå¤±
if (neighborId === ELEMENTS.WATER.id) {
if (Math.random() < 0.3) {
grid[ni] = ELEMENTS.ACID.id;
grid[i] = 0;
return;
}
}

// è¶…é…¸ä¸å²©æµ†ååº”ï¼šä¸¤è€…éƒ½å˜æˆç»ç’ƒ
if (neighborId === ELEMENTS.LAVA.id) {
if (Math.random() < 0.5) {
grid[ni] = ELEMENTS.GLASS.id;
grid[i] = ELEMENTS.GLASS.id;
return;
}
}

// è¶…é…¸ä¸é…¸æ¶²ä¸ååº”
if (neighborId === ELEMENTS.ACID.id) {
continue;
}

// è¶…é…¸è…èš€å…¶ä»–æ‰€æœ‰ç²’å­ï¼ˆé™¤äº†åŸºå²©ï¼‰
if (neighborId !== 0 && neighborId !== ELEMENTS.AIR.id &&
neighborId !== ELEMENTS.BEDROCK.id && neighborId !== ELEMENTS.SUPER_ACID.id) {
// åŸºå²©ä¸ä¼šè¢«è…èš€
const neighbor = Object.values(ELEMENTS).find(e => e.id === neighborId);
if (neighbor && !neighbor.indestructible) {
if (Math.random() < 0.8) { // 80%è…èš€æ¦‚ç‡
grid[ni] = 0;
// å¦‚æœè…èš€çš„æ˜¯æ¤ç‰©ï¼Œç§»é™¤ç”Ÿé•¿è®°å½•
if (neighborId === ELEMENTS.PLANT.id ||
neighborId === ELEMENTS.VINE.id ||
neighborId === ELEMENTS.LEAF.id ||
neighborId === ELEMENTS.FLOWER.id ||
neighborId === ELEMENTS.SEED.id) {
destroyPlantAt(nx, ny);
}
// è¶…é…¸æœ¬èº«ä¸å—å½±å“
}
}
}
}
}
}

// æ£€æŸ¥ä½ç½®æ˜¯å¦æœ€è¿‘è¢«ç ´åè¿‡
function isRecentlyDestroyed(index) {
const now = performance.now();
for (let i = 0; i < destroyedPlants.positions.length; i++) {
if (destroyedPlants.positions[i] === index) {
if (now - destroyedPlants.timestamps[i] < DESTROYED_PLANT_TTL) {
return true;
} else {
destroyedPlants.positions.splice(i, 1);
destroyedPlants.timestamps.splice(i, 1);
i--;
return false;
}
}
}
return false;
}

// æ ‡è®°ä½ç½®ä¸ºè¢«ç ´å
function markAsDestroyed(index) {
const now = performance.now();

const existingIdx = destroyedPlants.positions.indexOf(index);
if (existingIdx === -1) {
destroyedPlants.positions.push(index);
destroyedPlants.timestamps.push(now);
} else {
destroyedPlants.timestamps[existingIdx] = now;
}

cleanupDestroyedRecords(now);
}

// æ¸…ç†è¿‡æœŸçš„ç ´åè®°å½•
function cleanupDestroyedRecords(now) {
for (let i = destroyedPlants.positions.length - 1; i >= 0; i--) {
if (now - destroyedPlants.timestamps[i] > DESTROYED_PLANT_TTL) {
destroyedPlants.positions.splice(i, 1);
destroyedPlants.timestamps.splice(i, 1);
}
}
}

// å½“æ¤ç‰©è¢«ç ´åæ—¶ï¼Œå®Œå…¨ç§»é™¤å…¶ç”Ÿé•¿çŠ¶æ€
function destroyPlantAt(x, y) {
const i = idx(x, y);

markAsDestroyed(i);
removeGrowthRecords(i);
grid[i] = 0;
}

function update() {
if (isPaused) return;
    
// æ›´æ–°æ¸©åº¦ç³»ç»Ÿ
updateTemperature();
    
decayShockWave();
const now = performance.now();

// æ¸…ç†è¿‡æœŸçš„ç ´åè®°å½•
cleanupDestroyedRecords(now);

// æ›´æ–°é£è¡Œçš„çŸ³å¤´
updateFlyingStones();

// æ›´æ–°ç§å­ç”Ÿé•¿
updateSeedGrowth(now);

// æ›´æ–°æ¤ç‰©å¸æ°´ç”Ÿé•¿
updatePlantWaterGrowth(now);

// æ›´æ–°è—¤è”“ç”Ÿé•¿
updateVineGrowth(now);

// æ›´æ–°å…‹éš†å…ƒç´ 
updateCloneElements(now);

// æ›´æ–°ç”Ÿå‘½å…ƒç´ 
updateLifeElements(now);

for (let y = height - 1; y >= 0; y--) {
const startLeft = Math.random() > 0.5;
const xStart = startLeft ? 0 : width - 1;
const xEnd = startLeft ? width : -1;
const xStep = startLeft ? 1 : -1;
for (let x = xStart; x !== xEnd; x += xStep) {
const i = idx(x, y);
const id = grid[i];
if (id === 0) continue;
const elem = Object.values(ELEMENTS).find(e => e.id === id);
if (!elem) continue;

// æ£€æŸ¥ç§å­æ˜¯å¦éœ€è¦å¼€å§‹ç”Ÿé•¿
if (elem.id === ELEMENTS.SEED.id) {
checkSeedGrowth(x, y);
}

// æ£€æŸ¥æ¤ç‰©æ˜¯å¦æ¥è§¦æ°´
if (elem.id === ELEMENTS.PLANT.id ||
elem.id === ELEMENTS.FLOWER.id ||
elem.id === ELEMENTS.VINE.id ||
elem.id === ELEMENTS.LEAF.id) {
checkPlantWaterAbsorption(x, y);

// æ£€æŸ¥æ¤ç‰©é«˜åº¦é™åˆ¶
checkPlantHeightLimit(x, y);
}

// æ£€æŸ¥å…‹éš†å…ƒç´ æ˜¯å¦éœ€è¦å¼€å§‹å¤åˆ¶
if (elem.id === ELEMENTS.CLONE.id) {
checkCloneElement(x, y);
}

// æ£€æŸ¥ç”Ÿå‘½å…ƒç´ 
if (elem.id === ELEMENTS.LIFE.id) {
checkLifeElement(x, y);
}

// æ£€æŸ¥æ°´ä¸çŸ³æ²¹çš„åŒ–å­¦ååº”
if (elem.id === ELEMENTS.WATER.id) {
checkWaterOilReaction(x, y);
}

// æ£€æŸ¥çŸ³æ²¹ä¸æ°´çš„åŒ–å­¦ååº”
if (elem.id === ELEMENTS.OIL.id) {
checkOilWaterReaction(x, y);
}

// æ£€æŸ¥è¶…é…¸çš„åŒ–å­¦ååº”
if (elem.id === ELEMENTS.SUPER_ACID.id) {
checkSuperAcidReaction(x, y);
}

// åŸºå²©ä¸ä¼šè¢«ä»»ä½•å½¢å¼ç ´å
if (elem.id === ELEMENTS.BEDROCK.id) {
continue;
}

// å¤„ç†ç«ç„°å’Œå¯ç‡ƒç‰©äº¤äº’
if (window.shockWave[i] > 60) {
if (elem.explosive) {
destroyPlantAt(x, y);
doExplode(x, y, 4, 180);
continue;
}
if (elem.flammable && Math.random() < 0.6 && elem.id !== ELEMENTS.LAVA.id) {
grid[i] = ELEMENTS.FIRE.id;
markAsDestroyed(i);
removeGrowthRecords(i);
continue;
}
if (elem.meltable && Math.random() < 0.8) {
grid[i] = ELEMENTS.WATER.id;
continue;
}
}
if (elem.explosive) {
const aroundFire = [[0, 1], [0, -1], [1, 0], [-1, 0]].some(([dx, dy]) => {
const ni = idx(x + dx, y + dy);
return inBounds(x + dx, y + dy) && grid[ni] === ELEMENTS.FIRE.id;
});
if (aroundFire) {
destroyPlantAt(x, y);
doExplode(x, y, 4, 180);
continue;
}
}
if (elem.id === ELEMENTS.FIRE.id) {
// ä½¿ç”¨æ”¹è¿›çš„ç«ç„°æ›´æ–°
updateFireImproved(x, y, i);
continue;
}
if (elem.id === ELEMENTS.SMOKE.id) {
// ä½¿ç”¨æ”¹è¿›çš„çƒŸé›¾æ›´æ–°
updateSmokeImproved(x, y, i);
continue;
}
if (elem.acidity) {
const around = [[0, 1], [0, -1], [1, 0], [-1, 0]];
for (let [dx, dy] of around) {
const ni = idx(x + dx, y + dy);
if (inBounds(x + dx, y + dy) && grid[ni] && grid[ni] !== elem.id) {
const targetElem = Object.values(ELEMENTS).find(e => e.id === grid[ni]);
if (targetElem) {
if ((targetElem.id === ELEMENTS.PLANT.id ||
targetElem.id === ELEMENTS.VINE.id ||
targetElem.id === ELEMENTS.LEAF.id ||
targetElem.id === ELEMENTS.FLOWER.id ||
targetElem.id === ELEMENTS.SEED.id) &&
Math.random() < 0.8) {
destroyPlantAt(x + dx, y + dy);
grid[ni] = 0;
if (Math.random() < 0.3) grid[i] = 0;
break;
}
if (targetElem.type === TYPES.LIQUID && targetElem.id !== ELEMENTS.LAVA.id && Math.random() < 0.1) {
grid[ni] = 0; if (Math.random() < 0.3) grid[i] = 0; break;
}
if (targetElem.id !== ELEMENTS.WALL.id && targetElem.id !== ELEMENTS.LAVA.id && Math.random() < 0.05) {
grid[ni] = 0; if (Math.random() < 0.2) grid[i] = 0; break;
}
}
}
}
updateLiquid(x, y, i, elem.id); continue;
}
if (elem.id === ELEMENTS.GAS_FUEL.id) {
// ä½¿ç”¨æ”¹è¿›çš„ç‡ƒæ°”æ›´æ–°
updateFuelGasImproved(x, y, i);
continue;
}
if (elem.meltable) {
const aroundHot = [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [-1, 1], [1, -1], [-1, -1]].some(([dx, dy]) => {
const ni = idx(x + dx, y + dy);
if (!inBounds(x + dx, y + dy)) return false;
const neighbor = Object.values(ELEMENTS).find(e => e.id === grid[ni]);
return neighbor && (neighbor.id === ELEMENTS.FIRE.id || neighbor.id === ELEMENTS.LAVA.id);
});
if (aroundHot && Math.random() < 0.05) { grid[i] = ELEMENTS.WATER.id; continue; }
}
if (elem.id === ELEMENTS.LAVA.id) {
if (Math.random() < 0.02) { const up = idx(x, y - 1); if (inBounds(x, y - 1) && grid[up] === 0) grid[up] = ELEMENTS.FIRE.id; }
const around = [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [-1, 1], [1, -1], [-1, -1]];
for (let [dx, dy] of around) {
const ni = idx(x + dx, y + dy);
if (!inBounds(x + dx, y + dy)) continue;
const neighbor = Object.values(ELEMENTS).find(e => e.id === grid[ni]);
if (neighbor) {
if (neighbor.explosive && neighbor.id !== ELEMENTS.LAVA.id) {
destroyPlantAt(x + dx, y + dy);
doExplode(x + dx, y + dy, 3, 120);
}
else if (neighbor.flammable && neighbor.id !== ELEMENTS.LAVA.id && Math.random() < 0.8) {
grid[ni] = ELEMENTS.FIRE.id;
markAsDestroyed(ni);
removeGrowthRecords(ni);
}
if (neighbor.id === ELEMENTS.WATER.id && Math.random() < 0.5) {
grid[ni] = ELEMENTS.STONE.id;
const smokePos = idx(x, y - 1);
if (inBounds(x, y - 1) && grid[smokePos] === 0) grid[smokePos] = ELEMENTS.SMOKE.id;
}
if (neighbor.id === ELEMENTS.ICE.id && Math.random() < 0.4) grid[ni] = ELEMENTS.WATER.id;
}
}
updateLava(x, y, i); continue;
}
if (elem.id === ELEMENTS.STONE.id) {
const below = idx(x, y + 1);
if (y + 1 < height) {
const belowElem = Object.values(ELEMENTS).find(e => e.id === grid[below]);
if (grid[below] === 0 || (belowElem && (belowElem.type === TYPES.LIQUID || belowElem.type === TYPES.GAS || belowElem.type === TYPES.FUEL_GAS))) { swap(i, below); continue; }
}
continue;
}
if (elem.id === ELEMENTS.SUPER_ACID.id) {
// è¶…é…¸æœ‰é‡åŠ›ï¼Œåƒæ¶²ä½“ä¸€æ ·æµåŠ¨
updateLiquid(x, y, i, elem.id);
continue;
}
if (elem.id === ELEMENTS.STEAM.id) {
// ä½¿ç”¨æ”¹è¿›çš„è’¸æ±½æ›´æ–°
updateSteamImproved(x, y, i);
continue;
}
if (elem.type === TYPES.POWDER) updatePowder(x, y, i);
else if (elem.type === TYPES.LIQUID) updateLiquid(x, y, i, elem.id);
else if (elem.type === TYPES.GAS) {
// ä½¿ç”¨æ”¹è¿›çš„æ°”ä½“æ›´æ–°
updateGasImproved(x, y, i, elem);
}
else if (elem.type === TYPES.HEAVY_SOLID) updateHeavySolid(x, y, i);
}
}
for (let i = sparks.length - 1; i >= 0; i--) if (sparks[i].update()) sparks.splice(i, 1);
draw();
animationId = requestAnimationFrame(update);
}

function updateLava(x, y, i) {
const below = idx(x, y + 1);
if (y + 1 < height) {
const belowElem = Object.values(ELEMENTS).find(e => e.id === grid[below]);
if (grid[below] === ELEMENTS.WATER.id) { grid[below] = ELEMENTS.STONE.id; return; }
else if (grid[below] === 0 || (belowElem && (belowElem.type === TYPES.LIQUID || belowElem.type === TYPES.GAS || belowElem.type === TYPES.FUEL_GAS))) {
const temp = grid[below];
grid[below] = ELEMENTS.LAVA.id; grid[i] = 0;
if (temp !== 0 && temp !== ELEMENTS.LAVA.id) {
const dir = Math.random() > 0.5 ? 1 : -1;
const side = idx(x + dir, y);
if (inBounds(x + dir, y) && grid[side] === 0) grid[side] = temp;
}
return;
}
}
const dir = Math.random() > 0.5 ? 1 : -1;
const sideA = idx(x + dir, y);
const sideB = idx(x - dir, y);
if (inBounds(x + dir, y)) {
const sideAElem = Object.values(ELEMENTS).find(e => e.id === grid[sideA]);
if (grid[sideA] === ELEMENTS.WATER.id) { grid[sideA] = ELEMENTS.STONE.id; return; }
else if (grid[sideA] === 0 || (sideAElem && (sideAElem.type === TYPES.LIQUID || sideAElem.type === TYPES.GAS || sideAElem.type === TYPES.FUEL_GAS))) {
const temp = grid[sideA];
grid[sideA] = ELEMENTS.LAVA.id; grid[i] = 0;
if (temp !== 0 && temp !== ELEMENTS.LAVA.id) {
const up = idx(x + dir, y - 1);
if (inBounds(x + dir, y - 1) && grid[up] === 0) grid[up] = temp;
}
return;
}
}
if (inBounds(x - dir, y)) {
const sideBElem = Object.values(ELEMENTS).find(e => e.id === grid[sideB]);
if (grid[sideB] === ELEMENTS.WATER.id) { grid[sideB] = ELEMENTS.STONE.id; return; }
else if (grid[sideB] === 0 || (sideBElem && (sideBElem.type === TYPES.LIQUID || sideBElem.type === TYPES.GAS || sideBElem.type === TYPES.FUEL_GAS))) {
const temp = grid[sideB];
grid[sideB] = ELEMENTS.LAVA.id; grid[i] = 0;
if (temp !== 0 && temp !== ELEMENTS.LAVA.id) {
const up = idx(x - dir, y - 1);
if (inBounds(x - dir, y - 1) && grid[up] === 0) grid[up] = temp;
}
return;
}
}
const diagA = idx(x + dir, y + 1);
const diagB = idx(x - dir, y + 1);
if (y + 1 < height) {
if (inBounds(x + dir, y + 1) && (grid[diagA] === 0 || grid[diagA] === ELEMENTS.WATER.id)) {
if (grid[diagA] === ELEMENTS.WATER.id) grid[diagA] = ELEMENTS.STONE.id;
else { grid[diagA] = ELEMENTS.LAVA.id; grid[i] = 0; }
return;
}
if (inBounds(x - dir, y + 1) && (grid[diagB] === 0 || grid[diagB] === ELEMENTS.WATER.id)) {
if (grid[diagB] === ELEMENTS.WATER.id) grid[diagB] = ELEMENTS.STONE.id;
else { grid[diagB] = ELEMENTS.LAVA.id; grid[i] = 0; }
return;
}
}
}

function updateHeavySolid(x, y, i) {
const below = idx(x, y + 1);
if (y + 1 < height && grid[below] === 0) swap(i, below);
}

function doExplode(cx, cy, r, strength) {
addShockWave(cx, cy, r, strength);
for (let dy = -r; dy <= r; dy++) {
for (let dx = -r; dx <= r; dx++) {
const tx = cx + dx, ty = cy + dy;
if (!inBounds(tx, ty)) continue;
const d2 = dx * dx + dy * dy;
if (d2 > r * r) continue;
const ti = idx(tx, ty);
const target = grid[ti];
const tgtEl = Object.values(ELEMENTS).find(e => e.id === target);
if (!tgtEl) continue;
if (target === ELEMENTS.WALL.id) { grid[ti] = ELEMENTS.STONE.id; continue; }
if (target === 0 || tgtEl.type === TYPES.LIQUID || tgtEl.type === TYPES.POWDER) {
const vx = (dx + Math.random() * 0.4 - 0.2) * 0.8;
const vy = (dy + Math.random() * 0.4 - 0.2) * 0.8 - 1;
sparks.push(new Spark(tx, ty, vx, vy, target));
if (grid[ti] === 0) grid[ti] = ELEMENTS.FIRE.id;
}
}
}
}

function updatePowder(x, y, i) {
const below = idx(x, y + 1);
if (y + 1 < height && (grid[below] === 0 || isLiquid(grid[below]))) { swap(i, below); return; }
const side = Math.random() > 0.5 ? 1 : -1;
const diag = idx(x + side, y + 1);
if (inBounds(x + side, y + 1) && (grid[diag] === 0 || isLiquid(grid[diag]))) swap(i, diag);
}

function updateLiquid(x, y, i, typeId) {
if (typeId === ELEMENTS.LAVA.id) return;
const below = idx(x, y + 1);
if (y + 1 < height && grid[below] === 0) { swap(i, below); return; }
const dir = Math.random() > 0.5 ? 1 : -1;
const sideA = idx(x + dir, y);
const sideB = idx(x - dir, y);
if (inBounds(x + dir, y) && grid[sideA] === 0) swap(i, sideA);
else if (inBounds(x - dir, y) && grid[sideB] === 0) swap(i, sideB);
}

function isLiquid(id) {
const e = Object.values(ELEMENTS).find(el => el.id === id);
return e && (e.type === TYPES.LIQUID || e.type === TYPES.LAVA || e.type === TYPES.SUPER_ACID);
}

function isWaterLike(id) {
return id === ELEMENTS.WATER.id || id === ELEMENTS.OIL.id || id === ELEMENTS.ACID.id || id === ELEMENTS.SEED.id || id === ELEMENTS.SUPER_ACID.id;
}

function swap(i, j) { 
const t = grid[i]; 
grid[i] = grid[j]; 
grid[j] = t; 
    
// äº¤æ¢æ¸©åº¦
if (temperatureSystemEnabled) {
const tempT = temperatures[i];
temperatures[i] = temperatures[j];
temperatures[j] = tempT;
}
}

function updateFPS() {
frameCount++;
const currentTime = performance.now();
const elapsed = currentTime - lastTime;
if (elapsed >= fpsUpdateInterval) {
fps = Math.round((frameCount * 1000) / elapsed);
frameCount = 0;
lastTime = currentTime;
fpsDisplay.textContent = `FPSï¼š${fps}`;
}
}

function draw() {
const data = imageData.data;
for (let i = 0; i < data.length; i += 4) { data[i] = 0; data[i + 1] = 0; data[i + 2] = 0; data[i + 3] = 255; }
for (let i = 0; i < grid.length; i++) {
const id = grid[i];
const p = i * 4;
if (id === 0) continue;
const el = Object.values(ELEMENTS).find(e => e.id === id);
if (el) {
let r = el.color[0], g = el.color[1], b = el.color[2];
const v = el.variance ? (Math.random() * el.variance - el.variance / 2) : 0;
r = clamp(r + v); g = clamp(g + v); b = clamp(b + v);

// æ¸©åº¦ç€è‰²æ•ˆæœ
if (temperatureSystemEnabled && temperatures[i] !== ambientTemperature) {
const temp = temperatures[i];
if (temp > 100) {
// é«˜æ¸©çº¢è‰²è°ƒ
const heatIntensity = Math.min(1, (temp - 100) / 500);
r = clamp(r + 100 * heatIntensity);
g = clamp(g - 50 * heatIntensity);
b = clamp(b - 80 * heatIntensity);
} else if (temp < 0) {
// ä½æ¸©è“è‰²è°ƒ
const coldIntensity = Math.min(1, Math.abs(temp) / 50);
r = clamp(r - 30 * coldIntensity);
g = clamp(g + 20 * coldIntensity);
b = clamp(b + 50 * coldIntensity);
}
}

if (el.id === ELEMENTS.LAVA.id) {
const pulse = Math.sin(performance.now() * 0.005) * 15;
r = clamp(r + pulse); g = clamp(g + pulse * 0.5);
const glowRadius = 1, x = i % width, y = Math.floor(i / width);
for (let dy = -glowRadius; dy <= glowRadius; dy++) {
for (let dx = -glowRadius; dx <= glowRadius; dx++) {
if (dx === 0 && dy === 0) continue;
const nx = x + dx, ny = y + dy;
if (inBounds(nx, ny)) {
const ni = idx(nx, ny);
const np = ni * 4;
const glowStrength = 0.4;
data[np] = Math.min(255, data[np] + r * glowStrength);
data[np + 1] = Math.min(255, data[np + 1] + g * glowStrength);
data[np + 2] = Math.min(255, data[np + 2] + b * glowStrength * 0.3);
}
}
}
} else if (el.id === ELEMENTS.FLOWER.id) {
const pulse = Math.sin(performance.now() * 0.01) * 15;
r = clamp(r + pulse);
g = clamp(g + pulse * 0.3);
} else if (el.id === ELEMENTS.VINE.id || el.id === ELEMENTS.LEAF.id) {
const pulse = Math.sin(performance.now() * 0.003 + i * 0.01) * 5;
r = clamp(r + pulse * 0.5);
g = clamp(g + pulse);
} else if (el.id === ELEMENTS.CLONE.id) {
const pulse = Math.sin(performance.now() * 0.008) * 30;
r = clamp(r + pulse);
g = clamp(g - pulse * 0.3);
b = clamp(b + pulse * 0.5);

const glowRadius = 1, x = i % width, y = Math.floor(i / width);
for (let dy = -glowRadius; dy <= glowRadius; dy++) {
for (let dx = -glowRadius; dx <= glowRadius; dx++) {
if (dx === 0 && dy === 0) continue;
const nx = x + dx, ny = y + dy;
if (inBounds(nx, ny)) {
const ni = idx(nx, ny);
const np = ni * 4;
const glowStrength = 0.2;
data[np] = Math.min(255, data[np] + r * glowStrength);
data[np + 1] = Math.min(255, data[np + 1] + g * glowStrength);
data[np + 2] = Math.min(255, data[np + 2] + b * glowStrength);
}
}
}
} else if (el.id === ELEMENTS.SUPER_ACID.id) {
// è¶…é…¸æœ‰è½»å¾®çš„é—ªçƒæ•ˆæœ
const pulse = Math.sin(performance.now() * 0.01 + i * 0.02) * 10;
r = clamp(r + pulse);
g = clamp(g + pulse * 0.5);
// æ·»åŠ è…èš€æ•ˆæœçš„å…‰æ™•
const glowRadius = 1, x = i % width, y = Math.floor(i / width);
for (let dy = -glowRadius; dy <= glowRadius; dy++) {
for (let dx = -glowRadius; dx <= glowRadius; dx++) {
if (dx === 0 && dy === 0) continue;
const nx = x + dx, ny = y + dy;
if (inBounds(nx, ny)) {
const ni = idx(nx, ny);
const np = ni * 4;
const glowStrength = 0.1;
data[np] = Math.min(255, data[np] + r * glowStrength);
data[np + 1] = Math.min(255, data[np + 1] + g * glowStrength);
data[np + 2] = Math.min(255, data[np + 2] + b * glowStrength * 0.3);
}
}
}
} else if (el.id === ELEMENTS.GLASS.id) {
// ç»ç’ƒæ˜¯åŠé€æ˜çš„
data[p + 3] = 180;
// æ·»åŠ å¾®å°çš„åå…‰æ•ˆæœ
const shine = Math.sin(performance.now() * 0.005 + i * 0.01) * 10 + 10;
r = clamp(r + shine);
g = clamp(g + shine);
b = clamp(b + shine);
} else if (el.id === ELEMENTS.LIFE.id) {
// ç”Ÿå‘½å…ƒç´ ï¼ˆå°è™«ï¼‰æœ‰è„‰åŠ¨æ•ˆæœ
const pulse = Math.sin(performance.now() * 0.015 + i * 0.03) * 20;
r = clamp(r + pulse);
g = clamp(g - pulse * 0.5);
b = clamp(b - pulse * 0.5);
// æ·»åŠ å¾®å°çš„ç§»åŠ¨æ•ˆæœ
const move = Math.sin(performance.now() * 0.02 + i * 0.05) * 0.5;
const offsetX = Math.floor(i % width + move);
const offsetY = Math.floor(Math.floor(i / width));
if (offsetX >= 0 && offsetX < width) {
const offsetIdx = idx(offsetX, offsetY);
const offsetP = offsetIdx * 4;
data[offsetP] = r;
data[offsetP + 1] = g;
data[offsetP + 2] = b;
data[offsetP + 3] = 255;
continue; // è·³è¿‡æ­£å¸¸ç»˜åˆ¶
}
} else if (el.id === ELEMENTS.STEAM.id) {
// è’¸æ±½çš„è„‰åŠ¨æ•ˆæœ
const pulse = Math.sin(performance.now() * 0.01 + i * 0.03) * 15;
r = clamp(r + pulse);
g = clamp(g + pulse);
b = clamp(b + pulse);
}

data[p] = r; data[p + 1] = g; data[p + 2] = b;
data[p + 3] = el.color[3] !== undefined ? el.color[3] : 255;
}
}

// ç»˜åˆ¶é£è¡Œçš„çŸ³å¤´ï¼ˆåœ¨æ­£å¸¸ç»˜åˆ¶ä¹‹åï¼Œè¿™æ ·å®ƒä»¬ä¼šæ˜¾ç¤ºåœ¨æœ€ä¸Šå±‚ï¼‰
for (let i = 0; i < flyingStones.positions.length; i++) {
const [x, y] = flyingStones.positions[i];
const ix = Math.floor(x);
const iy = Math.floor(y);
if (inBounds(ix, iy)) {
const idxPos = idx(ix, iy);
const p = idxPos * 4;
// é£è¡Œçš„çŸ³å¤´é¢œè‰²ï¼ˆæ¯”æ™®é€šçŸ³å¤´äº®ï¼‰
data[p] = 150;
data[p + 1] = 150;
data[p + 2] = 150;
data[p + 3] = 255;
}
}

for (const s of sparks) {
const sx = Math.floor(s.x), sy = Math.floor(s.y);
if (inBounds(sx, sy)) {
const i = idx(sx, sy);
const p = i * 4;
data[p] = 255; data[p + 1] = 200; data[p + 2] = 0; data[p + 3] = 255;
}
}
for (let i = 0; i < window.shockWave.length; i++) {
if (window.shockWave[i] > 30) {
const px = (i % width) * 4;
const py = Math.floor(i / width) * 4;
const base = (py * width + px) * 4;
const waveIntensity = window.shockWave[i] / 255;
data[base] = Math.min(255, data[base] + 255 * waveIntensity);
data[base + 1] = Math.min(255, data[base + 1] + 200 * waveIntensity);
data[base + 2] = Math.min(255, data[base + 2] + 100 * waveIntensity);
}
}
ctx.putImageData(imageData, 0, 0);
updateFPS();
}

const clamp = v => Math.max(0, Math.min(255, v));

function loop() { update(); }

function clearCanvas() {
grid.fill(0);
sparks.length = 0;
window.shockWave.fill(0);
if (temperatureSystemEnabled) {
temperatures.fill(ambientTemperature);
}

// æ¸…ç©ºæ‰€æœ‰ç”Ÿé•¿çŠ¶æ€
seedGrowth.positions = [];
seedGrowth.heights = [];
seedGrowth.directions = [];
seedGrowth.maxHeights = [];
seedGrowth.growthTime = [];

plantWaterGrowth.positions = [];
plantWaterGrowth.waterCount = [];
plantWaterGrowth.lastAbsorbTime = [];
plantWaterGrowth.growDirections = [];
plantWaterGrowth.maxAbsorbCount = [];

vineGrowth.positions = [];
vineGrowth.lastGrowTime = [];
vineGrowth.directions = [];
vineGrowth.spreadCount = [];

cloneElements.positions = [];
cloneElements.lastCopyTime = [];
cloneElements.targetElements = [];
cloneElements.copyCount = [];
cloneElements.maxCopyCount = [];

lifeElements.positions = [];
lifeElements.lastMoveTime = [];
lifeElements.directions = [];
lifeElements.hunger = [];
lifeElements.age = [];
lifeElements.health = [];

destroyedPlants.positions = [];
destroyedPlants.timestamps = [];

flyingStones.positions = [];
flyingStones.velocitiesX = [];
flyingStones.velocitiesY = [];
flyingStones.timestamps = [];
}

// ç§»é™¤ç”Ÿé•¿è®°å½•
function removeGrowthRecords(index) {
// ç§»é™¤ç§å­ç”Ÿé•¿è®°å½•
const seedIdx = seedGrowth.positions.indexOf(index);
if (seedIdx !== -1) {
seedGrowth.positions.splice(seedIdx, 1);
seedGrowth.heights.splice(seedIdx, 1);
seedGrowth.directions.splice(seedIdx, 1);
seedGrowth.maxHeights.splice(seedIdx, 1);
seedGrowth.growthTime.splice(seedIdx, 1);
}

// ç§»é™¤æ¤ç‰©å¸æ°´ç”Ÿé•¿è®°å½•
const plantIdx = plantWaterGrowth.positions.indexOf(index);
if (plantIdx !== -1) {
plantWaterGrowth.positions.splice(plantIdx, 1);
plantWaterGrowth.waterCount.splice(plantIdx, 1);
plantWaterGrowth.lastAbsorbTime.splice(plantIdx, 1);
plantWaterGrowth.growDirections.splice(plantIdx, 1);
plantWaterGrowth.maxAbsorbCount.splice(plantIdx, 1);
}

// ç§»é™¤è—¤è”“ç”Ÿé•¿è®°å½•
const vineIdx = vineGrowth.positions.indexOf(index);
if (vineIdx !== -1) {
vineGrowth.positions.splice(vineIdx, 1);
vineGrowth.lastGrowTime.splice(vineIdx, 1);
vineGrowth.directions.splice(vineIdx, 1);
vineGrowth.spreadCount.splice(vineIdx, 1);
}

// ç§»é™¤å…‹éš†å…ƒç´ è®°å½•
const cloneIdx = cloneElements.positions.indexOf(index);
if (cloneIdx !== -1) {
cloneElements.positions.splice(cloneIdx, 1);
cloneElements.lastCopyTime.splice(cloneIdx, 1);
cloneElements.targetElements.splice(cloneIdx, 1);
cloneElements.copyCount.splice(cloneIdx, 1);
cloneElements.maxCopyCount.splice(cloneIdx, 1);
}

// ç§»é™¤ç”Ÿå‘½å…ƒç´ è®°å½•
const lifeIdx = lifeElements.positions.indexOf(index);
if (lifeIdx !== -1) {
lifeElements.positions.splice(lifeIdx, 1);
lifeElements.lastMoveTime.splice(lifeIdx, 1);
lifeElements.directions.splice(lifeIdx, 1);
lifeElements.hunger.splice(lifeIdx, 1);
lifeElements.age.splice(lifeIdx, 1);
lifeElements.health.splice(lifeIdx, 1);
}
}

let isDrawing = false;

function getGridPos(evt) {
const rect = canvas.getBoundingClientRect();
const [cx, cy] = evt.touches && evt.touches.length ? [evt.touches[0].clientX, evt.touches[0].clientY] : [evt.clientX, evt.clientY];
return {
x: Math.floor((cx - rect.left) / rect.width * width),
y: Math.floor((cy - rect.top) / rect.height * height)
};
}

function paint(evt) {
if (!isDrawing || isPaused) return;
const { x, y } = getGridPos(evt);
const r = parseInt(document.getElementById('brushSize').value);
for (let dy = -r; dy <= r; dy++) {
for (let dx = -r; dx <= r; dx++) {
if (dx * dx + dy * dy <= r * r) {
const px = x + dx, py = y + dy;
if (!inBounds(px, py)) continue;
const i = idx(px, py);
if (currentElement.isEraser) {
grid[i] = 0;
removeGrowthRecords(i);
markAsDestroyed(i);
if (temperatureSystemEnabled) {
temperatures[i] = ambientTemperature;
}
} else {
if (grid[i] === 0) {
grid[i] = currentElement.id;
if (temperatureSystemEnabled) {
temperatures[i] = currentElement.defaultTemp || ambientTemperature;
}
}
}
}
}
}
}

canvas.addEventListener('mousedown', e => { isDrawing = true; paint(e); });
window.addEventListener('mouseup', () => isDrawing = false);
canvas.addEventListener('mousemove', paint);
canvas.addEventListener('touchstart', e => { isDrawing = true; paint(e); e.preventDefault(); }, { passive: false });
window.addEventListener('touchend', () => isDrawing = false);
canvas.addEventListener('touchmove', e => { paint(e); e.preventDefault(); }, { passive: false });

window.addEventListener('beforeunload', saveToLocalStorage);
setInterval(saveToLocalStorage, 10000);

function selectElement(key) {
currentElement = ELEMENTS[key];
updateUI();
toggleSheet(false);
}

function updateUI() {
document.querySelectorAll('.chip').forEach(chip => {
chip.classList.toggle('active', chip.dataset.key === getKeyByValue(currentElement));
});
}

function getKeyByValue(obj) {
return Object.keys(ELEMENTS).find(k => ELEMENTS[k] === obj);
}

function toggleSheet(open) {
document.getElementById('more-sheet').classList.toggle('open', open);
document.getElementById('backdrop').classList.toggle('open', open);
}

function initUI() {
const quickBar = document.getElementById('quick-bar');
const allGrid = document.getElementById('all-elements-grid');
// å°†è¶…é…¸ã€åŸºå²©ã€ç»ç’ƒã€ç”Ÿå‘½æ·»åŠ åˆ°å¿«é€Ÿæ 
const quickKeys = ['SAND', 'WATER', 'STONE', 'WALL', 'ICE', 'LAVA', 'FIRE', 'STEAM', 'SUPER_ACID', 'BEDROCK', 'GLASS', 'LIFE', 'CLONE', 'ERASER'];
quickKeys.forEach(key => {
const el = ELEMENTS[key];
const btn = document.createElement('button');
btn.className = 'chip';
btn.dataset.key = key;
btn.innerText = el.name;
btn.onclick = e => { selectElement(key); };
if (key === 'SAND') btn.classList.add('active');
quickBar.appendChild(btn);
});
Object.keys(ELEMENTS).forEach(key => {
if (key === 'AIR') return;
const el = ELEMENTS[key];
const card = document.createElement('div');
card.className = 'element-card';
card.onclick = e => { selectElement(key); };
const dot = document.createElement('div');
dot.className = 'element-color-dot';
if (el.isEraser) {
dot.style.background = '#fff';
dot.style.border = '2px solid #ccc';
dot.style.backgroundImage = 'linear-gradient(45deg, #ccc 25%, transparent 25%, transparent 75%, #ccc 75%, #ccc), linear-gradient(45deg, #ccc 25%, transparent 25%, transparent 75%, #ccc 75%, #ccc)';
dot.style.backgroundSize = '10px 10px';
dot.style.backgroundPosition = '0 0, 5px 5px';
} else {
if (el.id === ELEMENTS.LAVA.id) {
dot.style.backgroundColor = `rgba(${el.color[0]},${el.color[1]},${el.color[2]},1)`;
dot.style.boxShadow = `0 0 8px rgba(${el.color[0]},${el.color[1]},${el.color[2]},0.9)`;
} else if (el.id === ELEMENTS.FLOWER.id) {
dot.style.backgroundColor = `rgba(${el.color[0]},${el.color[1]},${el.color[2]},1)`;
dot.style.boxShadow = `0 0 6px rgba(${el.color[0]},${el.color[1]},${el.color[2]},0.8)`;
} else if (el.id === ELEMENTS.VINE.id) {
dot.style.backgroundColor = `rgba(${el.color[0]},${el.color[1]},${el.color[2]},0.7)`;
dot.style.border = '1px solid rgba(0,0,0,0.2)';
} else if (el.id === ELEMENTS.LEAF.id) {
dot.style.backgroundColor = `rgba(${el.color[0]},${el.color[1]},${el.color[2]},0.8)`;
dot.style.border = '1px solid rgba(0,0,0,0.1)';
} else if (el.id === ELEMENTS.CLONE.id) {
dot.style.backgroundColor = `rgba(${el.color[0]},${el.color[1]},${el.color[2]},1)`;
dot.style.boxShadow = `0 0 6px rgba(${el.color[0]},${el.color[1]},${el.color[2]},0.8)`;
dot.style.animation = 'pulse 2s infinite';
} else if (el.id === ELEMENTS.SUPER_ACID.id) {
dot.style.backgroundColor = `rgba(${el.color[0]},${el.color[1]},${el.color[2]},1)`;
dot.style.boxShadow = `0 0 6px rgba(${el.color[0]},${el.color[1]},${el.color[2]},0.8)`;
dot.style.animation = 'pulse 1.5s infinite';
} else if (el.id === ELEMENTS.BEDROCK.id) {
dot.style.backgroundColor = `rgba(${el.color[0]},${el.color[1]},${el.color[2]},1)`;
// åŸºå²©æœ‰ç‰¹æ®Šçº¹ç†
dot.style.backgroundImage = 'linear-gradient(45deg, rgba(0,0,0,0.2) 25%, transparent 25%, transparent 75%, rgba(0,0,0,0.2) 75%), linear-gradient(45deg, rgba(0,0,0,0.2) 25%, transparent 25%, transparent 75%, rgba(0,0,0,0.2) 75%)';
dot.style.backgroundSize = '6px 6px';
dot.style.backgroundPosition = '0 0, 3px 3px';
} else if (el.id === ELEMENTS.GLASS.id) {
dot.style.backgroundColor = `rgba(${el.color[0]},${el.color[1]},${el.color[2]},0.7)`;
// ç»ç’ƒæœ‰åå…‰æ•ˆæœ
dot.style.boxShadow = 'inset 0 0 10px rgba(255,255,255,0.5), 0 0 5px rgba(200,220,240,0.8)';
} else if (el.id === ELEMENTS.LIFE.id) {
dot.style.backgroundColor = `rgba(${el.color[0]},${el.color[1]},${el.color[2]},1)`;
dot.style.boxShadow = `0 0 6px rgba(${el.color[0]},${el.color[1]},${el.color[2]},0.8)`;
dot.style.animation = 'pulse 1.2s infinite';
} else if (el.id === ELEMENTS.STEAM.id) {
dot.style.backgroundColor = `rgba(${el.color[0]},${el.color[1]},${el.color[2]},0.8)`;
dot.style.boxShadow = '0 0 6px rgba(220,240,255,0.6)';
dot.style.animation = 'pulse 1.8s infinite';
} else {
dot.style.backgroundColor = `rgba(${el.color[0]},${el.color[1]},${el.color[2]},1)`;
}
}
const name = document.createElement('span');
name.style.fontSize = '14px';
name.innerText = el.name;
card.appendChild(dot);
card.appendChild(name);
allGrid.appendChild(card);
});

// æ·»åŠ CSSåŠ¨ç”»
const style = document.createElement('style');
style.textContent = `
@keyframes pulse {
0% { transform: scale(1); }
50% { transform: scale(1.1); }
100% { transform: scale(1); }
}
`;
document.head.appendChild(style);
}

window.addEventListener('load', () => {
initGame();
initUI();
loadSavedState();
});
</script>
</body>
</html>